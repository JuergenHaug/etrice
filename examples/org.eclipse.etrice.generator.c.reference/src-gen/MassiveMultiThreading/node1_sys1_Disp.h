/**
 * @author generated by eTrice
 *
 * Dispatcher File of Node node1 with SubSystem sys1
 * - one generated message dispatcher (receiveMessage) for each MessageService (Thread)
 * - one generated execute dispatcher (execute) for each MessageService (Thread)
 */

#include "messaging/etMessageReceiver.h"
#include "debugging/etLogger.h"
#include "debugging/etMSCLogger.h"



/**
 * generated dispatch function all messages for the tread "PhysicalThread1"
 */
static void MsgDispatcher_PhysicalThread1_receiveMessage(const etMessage* msg){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_PhysicalThread1", "receiveMessage")
	switch(msg->address){
	
		/* interface items of /LS/sys1/tester */
		case 102:
		Tester_receiveMessage((void*)&_LS_sys1_tester,(etPort*)&_LS_sys1_tester_const.outport, msg);
		break;
		case 103:
		Tester_receiveMessage((void*)&_LS_sys1_tester,(etPort*)&_LS_sys1_tester_const.inport, msg);
		break;
		/* interface items of /LS/sys1/redirect3 */
		case 123:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect3,(etPort*)&_LS_sys1_redirect3_const.inport, msg);
		break;
		case 124:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect3,(etPort*)&_LS_sys1_redirect3_const.outport, msg);
		break;
		/* interface items of /LS/sys1/redirect4 */
		case 126:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect4,(etPort*)&_LS_sys1_redirect4_const.inport, msg);
		break;
		case 127:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect4,(etPort*)&_LS_sys1_redirect4_const.outport, msg);
		break;
		/* interface items of /LS/sys1/redirect5 */
		case 129:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect5,(etPort*)&_LS_sys1_redirect5_const.inport, msg);
		break;
		case 130:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect5,(etPort*)&_LS_sys1_redirect5_const.outport, msg);
		break;
		/* interface items of /LS/sys1/redirect6 */
		case 132:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect6,(etPort*)&_LS_sys1_redirect6_const.inport, msg);
		break;
		case 133:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect6,(etPort*)&_LS_sys1_redirect6_const.outport, msg);
		break;
		/* interface items of /LS/sys1/redirect7 */
		case 135:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect7,(etPort*)&_LS_sys1_redirect7_const.inport, msg);
		break;
		case 136:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect7,(etPort*)&_LS_sys1_redirect7_const.outport, msg);
		break;
		/* interface items of /LS/sys1/redirect8 */
		case 138:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect8,(etPort*)&_LS_sys1_redirect8_const.inport, msg);
		break;
		case 139:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect8,(etPort*)&_LS_sys1_redirect8_const.outport, msg);
		break;
		/* interface items of /LS/sys1/redirect9 */
		case 141:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect9,(etPort*)&_LS_sys1_redirect9_const.inport, msg);
		break;
		case 142:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect9,(etPort*)&_LS_sys1_redirect9_const.outport, msg);
		break;
		/* interface items of /LS/sys1/redirect10 */
		case 144:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect10,(etPort*)&_LS_sys1_redirect10_const.inport, msg);
		break;
		case 145:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect10,(etPort*)&_LS_sys1_redirect10_const.outport, msg);
		break;
		
		default:
			etLogger_logErrorF("MessageService_PhysicalThread1_receiveMessage: address %d does not exist ", msg->address);
		break;
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

/**
 * generated execute function for all cyclic execute calls for the async or datadriven actor instances of thread "PhysicalThread1"
 */
static void MsgDispatcher_PhysicalThread1_execute(void){
	/* nothing to execute -> empty function generated to satisfy interface of message service */
}



/**
 * generated dispatch function all messages for the tread "PhysicalThread2"
 */
static void MsgDispatcher_PhysicalThread2_receiveMessage(const etMessage* msg){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_PhysicalThread2", "receiveMessage")
	switch(msg->address){
	
		/* interface items of /LS/sys1/fork */
		case 105:
			Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.broadcast.ports[0], msg);
		break;
		case 106:
			Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.broadcast.ports[1], msg);
		break;
		case 107:
			Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.broadcast.ports[2], msg);
		break;
		case 108:
			Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.broadcast.ports[3], msg);
		break;
		case 109:
			Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.broadcast.ports[4], msg);
		break;
		case 110:
			Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.broadcast.ports[5], msg);
		break;
		case 111:
			Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.broadcast.ports[6], msg);
		break;
		case 112:
			Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.broadcast.ports[7], msg);
		break;
		case 113:
			Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.broadcast.ports[8], msg);
		break;
		case 114:
			Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.broadcast.ports[9], msg);
		break;
		case 115:
		Fork_receiveMessage((void*)&_LS_sys1_fork,(etPort*)&_LS_sys1_fork_const.inport, msg);
		break;
		/* interface items of /LS/sys1/redirect1 */
		case 117:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect1,(etPort*)&_LS_sys1_redirect1_const.inport, msg);
		break;
		case 118:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect1,(etPort*)&_LS_sys1_redirect1_const.outport, msg);
		break;
		/* interface items of /LS/sys1/redirect2 */
		case 120:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect2,(etPort*)&_LS_sys1_redirect2_const.inport, msg);
		break;
		case 121:
		Redirect_receiveMessage((void*)&_LS_sys1_redirect2,(etPort*)&_LS_sys1_redirect2_const.outport, msg);
		break;
		/* interface items of /LS/sys1/join */
		case 147:
			Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.inport.ports[0], msg);
		break;
		case 148:
			Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.inport.ports[1], msg);
		break;
		case 149:
			Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.inport.ports[2], msg);
		break;
		case 150:
			Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.inport.ports[3], msg);
		break;
		case 151:
			Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.inport.ports[4], msg);
		break;
		case 152:
			Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.inport.ports[5], msg);
		break;
		case 153:
			Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.inport.ports[6], msg);
		break;
		case 154:
			Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.inport.ports[7], msg);
		break;
		case 155:
			Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.inport.ports[8], msg);
		break;
		case 156:
			Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.inport.ports[9], msg);
		break;
		case 157:
		Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.outport, msg);
		break;
		case 158:
		Join_receiveMessage((void*)&_LS_sys1_join,(etPort*)&_LS_sys1_join_const.security, msg);
		break;
		
		default:
			etLogger_logErrorF("MessageService_PhysicalThread2_receiveMessage: address %d does not exist ", msg->address);
		break;
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

/**
 * generated execute function for all cyclic execute calls for the async or datadriven actor instances of thread "PhysicalThread2"
 */
static void MsgDispatcher_PhysicalThread2_execute(void){
	/* nothing to execute -> empty function generated to satisfy interface of message service */
}



/**
 * generated dispatch function all messages for the tread "PhysicalThread3"
 */
static void MsgDispatcher_PhysicalThread3_receiveMessage(const etMessage* msg){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_PhysicalThread3", "receiveMessage")
	switch(msg->address){
	
		/* interface items of /LS/sys1/supervisor */
		case 160:
		Supervisor_receiveMessage((void*)&_LS_sys1_supervisor,(etPort*)&_LS_sys1_supervisor_const.application, msg);
		break;
		
		default:
			etLogger_logErrorF("MessageService_PhysicalThread3_receiveMessage: address %d does not exist ", msg->address);
		break;
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

/**
 * generated execute function for all cyclic execute calls for the async or datadriven actor instances of thread "PhysicalThread3"
 */
static void MsgDispatcher_PhysicalThread3_execute(void){
	/* nothing to execute -> empty function generated to satisfy interface of message service */
}
