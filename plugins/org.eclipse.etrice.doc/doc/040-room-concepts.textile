h1. ROOM Concepts

This chapter gives an overview over the ROOM language elements and their textual and graphical notation.
The formal ROOM grammar based on XText (EBNF) you can find here: "ROOM Grammar":http://git.eclipse.org/c/etrice/org.eclipse.etrice.git/tree/plugins/org.eclipse.etrice.core.room/src/org/eclipse/etrice/core/Room.xtext

h2. Actors

h3. Description
 
The actor is the basic structural building block for building systems with ROOM. An actor can be refined hierarchically and thus can be of arbitrarily large scope. Ports define the interface of an actor. An Actor can also have a behavior usually defined by a finite state machine.

h3. Motivation

* Actors enable the construction of hierarchical structures with composition and layering
* Actors have their own logical thread of execution
* Actors can be freely deployed
* Actors define potentially reusable blocks

h3. Notation

<table title="Actor Class Notation" frame="box" border="1">
	<tr>
		<td align="center">*Element*</td>
		<td align="center">*Graphical Notation*</td>
		<td align="center">*Textual Notation*</td>
	</tr>
	<tr>
		<td>ActorClass</td>
		<td>!images\040-ActorClassNotation.png!</td>
		<td>!images\040-ActorClassTextualNotation.png!</td>
	</tr>
	<tr>
		<td>ActorRef</td>
		<td>!images\040-ActorReferenceNotation.png!</td>
		<td>!images\040-ActorReferenceTextualNotation.png!</td>
	</tr>
</table> 

h3. Details

h4.  Actor Classes, Actor References, Ports and Bindings

An *ActorClass* defines the type (or blueprint) of an actor. Hierarchies are built by ActorClasses that contain *ActorReferences* which have another ActorClass as type. The interface of an ActorClass is always defined by Ports. The ActorClass can also contain Attributes, Operations and a finite state machine. 

*External Ports* define the external interface of an actor and are defined in the *Interface* section of the ActorClass.

*Internal Ports* define the internal interface of an actor and are defined in the *Structure* section of the ActorClass.

*Bindings* connect Ports inside an ActorClass.

Example:

<table title="Actor Class Example" frame="box" border="1">
	<tr>
		<td align="center">*Graphical Notation*</td>
		<td align="center">*Textual Notation*</td>
	</tr>
	<tr>
		<td>!images\040-ActorClass.png!</td>
		<td>!images\040-ActorClassExampleTextualNotation.png!</td>
	</tr>
</table> 


* _ActorClass1_ contains two ActorReferences
* _port1_ is a *External End Port*. Since it connects external Actors with the behavior of the ActorClass, it is defined in the *Interface* section and the *Structure* section of the ActorClass.
* _port2_ and _port3_ are *Internal End Ports* and can only be connected to the ports of contained ActorReferences. Internal End Ports connect the Behavior of an ActorClass with its contained ActorReferences.
* _port4_ is a relay port and connects external Actors to contained ActorReferences. This port can not be accessed by the behavior of the ActorClass.
* *Bindings* can connect ports of the ActorClass and its contained ActorReferences. 

h4.  Attributes

Attributes are part of the Structure of an ActorClass. They can be of a PrimitiveType or a DataClass.

Example:

!images\040-ActorClassAttributes.png!

h4.  Operations

Operations are part of the Behavior of an ActorClass.  Arguments and return values can be of a PrimitiveType or a DataClass. DataClasses can be passed by value (implicit) or by reference (keyword *ref*).

Example:

!images\040-ActorClassOperations.png!

h4. Finite State Machine

h2. Protocols

h3. Description

A ProtocolClass defines a set of incoming and outgoing messages that can be exchanged between two ports.
The exact semantics of a message is defined by the execution model.

h3. Motivation

* ProtocolClasses provide a reusable interface specification for ports
* ProtocolClasses can optionally specify valid message exchange sequences

h3. Notation

ProtocolClasses have only textual notation. 
The example defines a ProtocolClass with 2 incoming and two outgoing messages. Messages can have data attached. The data can be of a primitive type (e.g. int32, float64, ...) or a DataClass.

!images\040-ProtocolClassTextualNotation.png!

h2. Ports

h3. Description

Ports are the only interfaces of actors. A port has always a protocol assigned. 
Service Access Points (SAP) and Service Provision Points (SPP) are specialized ports that are used to define layering.

h3. Motivation

* Ports decouple interface definition (Protocols) from interface usage
* Ports decouple the logical interface from the transport 

h3. Notation

h4. Class Ports

These symbols can only appear on the border of an actor class symbol. 
*Textual Notation:* 
Ports that define an external interface of the ActorClass, are defined in the Interface (e.g. relay ports). Ports that define an internal interface are defined in the Structure (e.g. internal ports).

<table title="Class Port Notation" frame="box" border="1">
	<tr>
		<td align="center">*Element*</td>
		<td align="center">*Graphical Notation*</td>
		<td align="center">*Textual Notation*</td>
	</tr>
	<tr>
		<td>Class End Port</td>
		<td align="center">!images\040-ClassEndPort.png!</td>
		<td></td>
	</tr>
	<tr>
		<td>Conjugated Class End Port</td>
		<td align="center">!images\040-ConjugatedClassEndPort.png!</td>
		<td></td>
	</tr>
	<tr>
		<td>Class Relay Port</td>
		<td align="center">!images\040-ClassRelayPort.png!</td>
		<td></td>
	</tr>
	<tr>
		<td>Conjugated Class Relay Port</td>
		<td align="center">!images\040-ConjugatedClassRelayPort.png!</td>
		<td></td>
	</tr>
	<tr>
		<td>Replicated Class End Port</td>
		<td align="center">!images\040-ReplicatedClassEndPort.png!</td>
		<td></td>
	</tr>
	<tr>
		<td>Conjugated Replicated Class End Port</td>
		<td align="center">!images\040-ConjugatedReplicatedClassEndPort.png!</td>
		<td></td>
	</tr>
	<tr>
		<td>Replicated Class Relay Port</td>
		<td align="center">!images\040-ReplicatedClassRelayPort.png!</td>
		<td></td>
	</tr>
	<tr>
		<td>Conjugated Replicated Class Relay Port</td>
		<td align="center">!images\040-ConjugatedReplicatedClassRelayPort.png!</td>
		<td></td>
	</tr>
</table>

h4. Reference Ports

These symbols can only appear on the border of an ActorReference symbol. Since the type of port is defined in the ActorClass, no textual notation for the Reference Ports exists.

<table title="Title" frame="box" border="1">
	<tr>
		<td align="center">*Element*</td>
		<td align="center">*Graphical Notation*</td>
		<td align="center">*Textual Notation*</td>
	</tr>
	<tr>
		<td>Reference Port</td>
		<td align="center">!images\040-ReferencePort.png!</td>
		<td align="center">_implicit_</td>
	</tr>
	<tr>
		<td>Conjugated Reference Port</td>
		<td align="center">!images\040-ConjugatedReferencePort.png!</td>
		<td align="center">_implicit_</td>
	</tr>
	<tr>
		<td>Replicated Reference Port</td>
		<td align="center">!images\040-ReplicatedReferencePort.png!</td>
		<td align="center">_implicit_</td>
	</tr>
	<tr>
		<td>Conjugated Replicated Reference Port</td>
		<td align="center">!images\040-ConjugatedReplicatedReferencePort.png!</td>
		<td align="center">_implicit_</td>
	</tr>
</table>

h2. DataClass

h3. Description

The DataClass enables the modeling of hierarchical complex datatypes and operations on them. The DataClass is the equivalent to a Class in languages like Java or C++, but has less features. The content of a DataClass can always be sent via message between actors (defined as message data in ProtocolClass).

h3. Notation
  
Example: DataClass using PrimitiveTypes

!images\040-DataClass1.png!

Example: DataClass using other DataClasses:

!images\040-DataClass2.png!

