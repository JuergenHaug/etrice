h1. Introduction to the ROOM Language

h2. Scope of ROOM

This chapter will give a rough overview of what ROOM (*R* eal time *O* bject *O* riented *M* odeling) is and where it is good for. It will try to answer the following questions:
* Where does it come from?
* Which kind of SW-Systems will be addressed?
* What is the relation between OOP and ROOM?
* What are the benefits of ROOM?
* Which consequences must be taken into account?

h3. Where does it come from?

Room was developed in the 1990th on the background of the upcoming mobile applications with the goal to manage the complexity of such huge SW-Systems. From the very beginning ROOM has focused on a certain type of SW-Systems and, is in contrast to the UML, well suited for this kind of systems. In this sense, ROOM is a DSL (Domain Specific Language) for distributed, event driven, real time systems. 

Bran Selic, Garth Gullekson and Paul T. Ward have published the concepts 1994 in the book "REAL-TIME OBJECT-ORIENTED MODELING". The company ??object time?? (TM) developed a ROOM tool which was taken over from ??Rational SW?? (TM) and later on from ??IBM?? (TM). Unfortunately the tool is no longer maintained from ??IBM?? (TM). The company ??Protos SW Gmbh?? (TM) also developed a ROOM tool called ??trice?? (TM) for controlling production machines. ??Trice?? (TM) is the predecessor of eTrice (see Introduction to eTrice). 
 
From our point of view ROOM provides still the clearest, simplest, completest and best suited modeling concepts for the real time domain. All later proposals like the UML does not fit such perfect to this kind of problems.
 

h3. Which kind of SW-Systems will be addressed?

As mentioned before ROOM addresses distributed, event driven, real time systems. But what is a "real time system"? ROOM defines a set of properties which are typically for a real time system. This properties are:
* Timeliness
* dynamic internal structure
* Reactiveness
* Concurrent
* Distributed
* Reliable

Each of this properties has potential to make SW development complex. If a given system can be characterized which some or all of this properties, ROOM might be applied to such a system.  

As an example take a look at a washing machine. The system has to react on user interactions, has to handle some error conditions like a closed water tap or a defective lye pump. It has to react simultaneously to all this inputs. It has to close the water valve in a certain time to avoid flooding the basement. 
So, the system can by characterized as timeliness, concurrent and reactive. As long as the washing machine does not transform to a laundry dryer by themself, the system has no dynamic internal structure and as long as all functions are running on a single microcontroller the (SW)-system is not distributed. 
ROOM fits perfect to such a system.

A SW system which mainly consists of data transformations like signal/image processing or loop controller (PID regulator) cannot be characterized with any of the above mentioned properties. However, in the real world most of the SW systems will be a combination of both. ROOM can be combined with such systems, so that for example an actor provides a ??run to completion?? context for calculating a image processing algorithm.  

h3. What is the relation between OOP and ROOM?

The relation between classic object oriented programming and ROOM is comparable to the relation between assembler programming and C programming. It provides a shift of the object paradigm. As the picture shows, the classic object paradigm provides some kind of information hiding. Attributes can be accessed via access methods. Logical higher level methods provides the requested behavior to the user.   

!images/010-RoomIntroduction01.png!

As the figure illustrates, the classic object paradigm does not care about concurrency issues. The threads of control will be provided from the underlying operating system and the user is responsible to avoid access violations by using operating system mechanisms (semaphore, mutex).

!images/010-RoomIntroduction02.png!

ROOM provides the concept of a logical machine (called actor) with it´s own thread of control. It provides some kind of cooperative communication infrastructure with "run to completion" semantic. That makes developing of business logic easy and save (see basic concepts). The logical machine provides an encapsulation shell including concurrency issues (see chapter "Run to completion"). 

!images/010-RoomIntroduction03.png!

This thinking of an object is much more general than the classic one.  

h3. What are the benefits of ROOM?

ROOM has a lot of benefits and it depends on the users point of view which is the most important one. From a general point of view the most important benefit is, that ROOM allows to create SW systems very efficient, robust and safe due to the fact that it provides some abstract, high level modeling concepts combined with code generation and a small efficient runtime environment.  

In detail:
* ROOM models contain well defined interfaces (protocols). That makes it easy to reuse components in different applications or e.g. in a test harness. 
* Graphical modeling makes it easy to understand, maintain and share code with other developers
* Higher abstraction in combination with automated code generation provides very efficient mechanisms to the developer. 
* ROOM provides graphical model execution, which makes it easy to understand the application or  find defects in a very early phase. 

h3. Which consequences must be taken into account?

Generating code from models will introduce some overhead in terms of footprint as well as performance. For most systems the overhead will be negligible. However, the decision using ROOM should be made explicitly and it is always a tread of between development costs, time to market and costs in terms of a little bit more of memory and performance. As mentioned, in most cases the decision will be very clear. Especially in case of product lines or products which requires maintenance or feature updates, the ROOM methodology has big advantages.  
  
Care must be taken during introduction of the new methodology. Due to the fact that ROOM provides a shift of the object paradigm, developers often needs a phase of adaption. Even some of them will never adapt.

h2. Basic Concepts

h3. Actor, Port, Protocol

The basic elements of ROOM are the actor with its ports and protocols. The protocol provides a formal interface description. The port is an interaction point where the actor interacts with its outside world. Each port has exactly one protocol attached. The sum of all ports builds up the complete interface of an actor. Each port can receive messages with or without data which is defined in the protocol. Each message will be handled from the actors behavior (state machine) or will be delegated to the actors internal structure.

The actor provides access protection for it´s own attributes (including complex types (classic objects)), including concurrency protection. An actor has neither public attributes nor public operations. The only interaction with the outside world takes place via interface ports. This ensures a high degree of reuse ability on actor level and provides an effective and safe programming model to the developer. 

Receiving a message via a port will trigger the internal state machine. A transition will be executed depending on the message and the actual state. Within this transition, detailed code will be executed and response messages can be sent.

"receiving a message":avis\010-room-introduction01.avi

With this model, a complex behavior will be divided into many relatively simple, linked actors. To say it the other way round: The complex behavior will be provided by a network of relatively simple components which are communicating with each other via well defined interfaces.


h3. Hierarchy in Structure and FSM

ROOM provides two types of hierarchy. Behavioral hierarchy and structural hierarchy. Structural hierarchy means that actors can be nested to any level. Usually you will add more and more details to your application with each nesting level. That means you can focus yourself on any level of abstraction with always the same element, the actor. Structural hierarchy provides a power full mechanism to divide your problem in smaller pieces, so that you can focus the level of abstraction you want to work on. 

The actors behavior will be described with a state machine. The states itself may contain sub states. This is also a possibility to focus on an abstraction level. Take the simple FSM from the blinky actor from the blinky tutorial:    

!images\020-Blinky15.png!

From an abstract point of view there is a state "blinking". But a simple LED is not able to blink autonomously. Therefore you have to add more details to your model to make a LED blinking, but for the current work it is not of interest how blinking is realized. This will be done in the next lower level of the hierarchy. 

With this very simple example you can easily imagine how power full this mechanisms is.

The hierarchical FSM provides a rich tool box to describe real world problems. (see "room concepts").
 
h3. Run to Completion

"Run to completion" (RTC) is a very central concept of ROOM. It enables the developer to concentrate on the functional aspects of the system. The developer must not take care about concurrency issues all the time. This job is concentrated to the system designer in a very flexible way.
What does "run to completion" mean:
RTC means that an actor, which is processing a message, can not be receive the next message as long as the processing of the current message has not been finished. Receiving of the next message will be queued from the underlying run time system.

Note: It is very important not to confuse run to completion and preemption. Run to completion means that an actor will finish the processing of a message before he can receive a new one (regardless of its priority). That does not mean that an actor cannot be preempted from an higher prior thread of control. Even a message from this higher prior thread of control will be queued till the current processing has been finished. 

With this mechanism all actor internal attributes and data structures are protected. Due to the fact that multiple actors share one thread of control, all objects are protected which are accessed from one thread of control but multiple actors. This provides the possibility to decompose complex functionality to several actors without the risk to produce access violations.

h3. Layering

h2. Benefits

h2. Execution Models

h3. Logical Machine

* run to completion

h3. Queue Based Execution Model

h3. Polled Execution Model
not implemented yet

h3. Hybrid Execution Model
not implemented yet

port, protocol, actor, interface, asynchronous communication
hierarchical FSM, hierarchical structure

run to completion

