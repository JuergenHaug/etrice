
h1. eTrice Developer's Reference

h2. Architecture

The basic components of eTrice are depicted in the following diagram.

!{width:50%}images/200-components.jpg!

Additional to that the eTrice project comprises runtime libraries and unit tests which are treated in subsequent sections.

h3. Editor and Generator Components

* core
** core.coom is an Xtext based language called Room. It consists of the plug-in _org.eclipse.etrice.core.room_. Room is the basic modeling language of eTrice.
** core.config is an Xtext based language called Config. It consists of the plug-in _org.eclipse.etrice.core.config_. Config is a language designed for the data configuration of model elements. E.g. class and instance attributes can be specified.
** core.genmodel is an EMF based aggregation layer for Room models. It consists of the plugin _org.eclipse.etrice.core.genmodel_. a Room model can be transformed into a genmodel which allows easy access to implicit relations of the Room model.
* ui
** textual
*** room.ui is the ui counterpart of core.room.  It consists of the plug-in _org.eclipse.etrice.core.room.ui_. This plug-in realizes IDE concepts like content assist, error markers and navigation by hyper links for the Room language.
*** config.ui is the ui counterpart of core.config.  It consists of the plug-in _org.eclipse.etrice.core.config.ui_. This plug-in realizes IDE concepts like content assist, error markers and navigation by hyper links for the Config language.
** graphical
*** ui.common is a set of common code for the two diagram editors. It consists of the plug-in _org.eclipse.etrice.ui.common_.
*** ui.commands encapsulates some commands related to the navigation between eTrice editors. It consists of the plug-in _org.eclipse.etrice.ui.commands_.
*** ui.structure is the Graphiti based editor for the Actor structure. It consists of the plug-in _org.eclipse.etrice.ui.structure_.
*** ui.behavior is the Graphiti based editor for the Actor behavior. It consists of the plug-in _org.eclipse.etrice.ui.behavior_.
* generators
** generator is a set of general classes and language independent parts of all generators. It consists of the plug-in _org.eclipse.etrice.generator_.
** generator.c is the generator for the ANSI-C target language. It consists of the plug-in _org.eclipse.etrice.generator.c_.
** generator.java is the generator for the Java target language. It consists of the plug-in _org.eclipse.etrice.generator.java_.
** generator.doc is the generator for the model documentation. It consists of the plug-in _org.eclipse.etrice.generator.doc_.

h3. Runtimes

Currently eTrice ships with a C and a Java runtime. The runtimes are libraries written in the target language against which the generated code is compiled.

h3. Unit Tests

Most plug-ins and other parts of the code have related unit tests.


h2. Component Overview

h3. Room Language Overview

We assume that the reader is familiar with the Xtext concepts. So we concentrate on the details of our implementation that are worth to be pointed out.

h4. Model Tweaks

The Room EMF model is inferred from the grammar. However, this powerful mechanism has to be tweaked at some places.
This is done in the _/org.eclipse.etrice.core.room/src/org/eclipse/etrice/core/RoomPostprocessor.ext_ which is written in the legacy Xtend language.

The following parts of the model are changed or added:
* the default @multiplicity@ of the @Port@ is set to 1
* the operation @isReplicated@ is added to the @Port@
* the default @size@ of the @ActorRef@ is set to 1
* an operation @getName@ is add to the @State@ class
* an operation @getName@ is add to the @StateGraphItem@ class
* an operation @getGeneralProtocol@ is added to the @InterfaceItem@

h4. Imports by URI Using Namespaces

The import mechanism employed is based on URIs. This is configured for one part in the GenerateRoom.mwe2 model workflow by setting the fragments ImportURIScopingFragment and ImportUriValidator). For the other part it is configured in the Guice modules by binding
* @PlatformRelativeUriResolver@ -- this class tries to convert the import URI into a platform relative URI. It also replaces environment variables written in ${} with their respective values.
* @ImportedNamespaceAwareLocalScopeProvider@ -- this is a standard scope provider which is aware of namespaces
* @GlobalNonPlatformURIEditorOpener@ -- this editor opener tries to convert general URIs into platform URIs because editors can only open platform URIs
* @ImportAwareHyperlinkHelper@ -- turns the URI part of an import into a navigatable hyper link

h4. Naming

Two classes provide object names used for link resolution and for labels.
The @RoomNameProvider@ provides frequently used name strings, some of them are hierarchical like State paths.
The @RoomFragmentProvider@ serves a more formal purpose since it provides a link between EMF models (as used by the diagram editors) and the textual model representation used by Xtext.

h4. Helpers

The @RoomHelpers@ class provides a great deal of static methods that help retrieve frequently used information from the model.
Among many, many others
* @getAllEndPorts(ActorClass)@ - returns a list of all end ports of an actor class including inherited ones
* @getInheritedActionCode(Transition, ActorClass)@ - get the inherited part of a transition's action code
* @getSignature(Operation)@ - returns a string representing the operation signature suited for a label

h4. Validation

Validation is used from various places. Therefore all validation code is accumulated in the @ValidationUtil@ class. All methods are static and many of them return a Result object which contains information about the problem detected as well as object and feature as suited for most validation purposes.

h3. Config Language Overview

h4. Model Tweaks

A couple of operations are added to the ConfigModel
* @getActorClassConfigs@
* @getActorInstanceConfigs@
* @getProtocolClassConfigs@
* @getSubSystemConfigs@

h4. Imports by URI Using Namespaces

Imports are treated similar than in the "Room language":#ImportsbyURIUsingNamespaces.

h4. Util

A set of static utility methods can be found in the @ConfigUtil@ class.

h3. Aggregation Layer Overview

The eTrice Generator Model (genmodel) serves as an aggregation layer. Its purpose is to allow easy access to information which is implicitly contained in the Room model but not simple to retrieve.
Examples of this are the state machine with inherited items or a list of all triggers active at a state in the order in which they will be evaluated or the actual peer port of an end port (following bindings through relay ports).

The Generator Model is created from a list of Room models by a call of the

bc. createGeneratorModel(List<RoomModel>, boolean)

method of the @GeneratorModelBuilder@ class.

The @Root@ object of the resulting Generator Model provides chiefly two things:
* a tree of instances starting at each @SubSystem@ with representations of each @ActorInstance@ and @PortInstance@
* for each @ActorClass@ a corresponding @ExpandedActorClass@ with an explicit state machine containing all inherited state graph items

h4. The Instance Model

The instance model allows easy access to instances including their unique paths and object IDs. Also it is possible to get a list of all peer port instances for each port instance without having to bother about port and actor replication.

h4. The Expanded Actor Class

The expanded actor class contains, as already mentioned, the complete state machine of the actor class. This considerably simplifies the task of state machine generation. Note that the generated code always contains the complete state machine of an actor. I.e. no target language inheritance is used to implement the state machine inheritance.
Furthermore the @ExpandedActorClass@ gives access to
* @getIncomingTransitions(StateGraphNode)@ -- the set of incoming transition of a @StateGraphNode@ (@State@, @ChoicePoint@ or @TransitionPoint@)
* @getOutgoingTransitions(StateGraphNode)@ -- the set of outgoing transition of a @StateGraphNode@
* @getActiveTriggers(State)@ -- the triggers that are active in this @State@ in the order they are evaluated

h4. Transition Chains

By transition chains we denote a connected subset of the (hierarchical) state machine that starts with a transition starting at a state and continues over transitional state graph nodes (choice points and transition points) and continuation transitions until a state is reached. In general a transition chain starts at one state and ends in several states (the chain may branch in choice points).
A @TransitionChain@ of a transition is retrieved by a call of @getChain(Transition)@ of the @ExpandedActorClass@.
The @TransitionChain@ accepts an @ITransitionChainVisitor@ which is called along the chain to generate the action codes of involved transitions and the conditional statements arising from the involved choice points. 

h3. Generator Overview

There is one plug-in that consists of base classes and some generic generator parts which are re-used by all language specific generators
 
h4. Base Classes and Interfaces

We just want to mention the most important classes and interfaces.

* @ITranslationProvider@ -- this interface is used by the @DetailCodeTranslator@ for the language dependent translation of e.g. port.message() notation in detail code
* @AbstractGenerator@ -- concrete language generators should derive from this base class
* @DefaultTranslationProvider@ -- a stub implementation of @ITranslationProvider@ from which clients may derive
* @Indexed@ -- provides an indexed iterable of a given iterable
* @GeneratorBaseModule@ -- a Google Guice module that binds a couple of basic services. Concrete language generators should use a module that derives from this

h4. Generic Generator Parts

The generic generator parts provide code generation blocks on a medium granularity. The language dependent top level generators embed those blocks in a larger context (file, class, ...). Language dependent low level constructs are provided by means of an @ILanguageExtension@. This extension and other parts of the generator be configured using Google Guice dependency injection.

h5. GenericActorClassGenerator

The @GenericActorClassGenerator@ generates constants for the interface items of a actor. Those constants are used by the generated state machine.

h5. GenericProtocolClassGenerator

The @GenericProtocolClassGenerator@ generates message ID constants for a protocol.

h5. GenericStateMachineGenerator

The @GenericStateMachineGenerator@ generates the complete state machine implementation. The skeleton of the generated code is

* definition state ID constants
* definition of transition chain constants
* definition of trigger constants
* entry, exit and action code methods
* the @exitTo@ method 
* the @executeTransitionChain@ method
* the @enterHistory@ method
* the @executeInitTransition@ method
* the @receiveEvent@ method

The state machine works as follows. The main entry method is the @receiveEvent@ method. This is the case for both, data driven (polled) and event driven state machines. Then a number of nested switch/case statements evaluates trigger conditions and derives the transition chain that is executed. If a trigger fires then the @exitTo@ method is called to execute all exit codes involved. Then the transition chain action codes are executed and the choice point conditions are evaluated in the @executeTransitionChain@ method. Finally the history of the state where the chain ends is entered and all entry codes are executed by @enterHistory@.

h4. The Java Generator

The Java generator employs the generic parts of the generator. The @JavaTranslationProvider@ is very simple and only handles the case of sending a message from a distinct replicated port: @replPort[2].message()@. Other cases are handled by the base class by returning the original text.

The @DataClassGen@ uses Java inheritance for the generated data classes. Otherwise it is pretty much straight forward.

The @ProtocolClassGen@ generates a class for the protocol with nested static classes for regular and conjugated ports and similar for replicated ports.

The @ActorClassGen@ uses Java inheritance for the generated actor classes. So ports, SAPs and attributes and detail code methods are inherited. Not inherited is the state machine implementation.

h4. The ANSI-C Generator

The C generator translates data, protocol and actor classes into structs together with a set of methods that operate on them and receive a pointer to those data (called @self@ in analogy to the implicit C++ @this@ pointer).
No dynamic memory allocation is employed. All actor instances are statically initialized.
One of the design goals for the generated C code was an optimized footprint in terms of memory and performance to be able to utilize modeling with ROOM also for tiny low end micro controllers.

h4. The Documentation Generator

The documentation generator creates documentation in LaTex format which can be converted into PDF and many other formats.

