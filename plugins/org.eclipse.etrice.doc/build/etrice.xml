<?xml version='1.0' ?><!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
	<title>eTrice User Guide</title>
	<chapter id="eTriceOverview">
		<title>eTrice Overview</title>
		<section id="WhatiseTrice">
			<title>What is eTrice?</title>
			<para>eTrice provides an implementation of the ROOM modeling language (Real Time Object Oriented Modeling) together with editors, code generators for Java, C++ and C code and exemplary target middleware.</para>
			<para>The model is defined in textual form (Xtext) with graphical editors (Graphiti) for the structural and behavioral (i.e. state machine) parts.  </para>
		</section>
		<section id="ReductionofComplexity">
			<title>Reduction of Complexity</title>
			<para>eTrice is all about the reduction of complexity:</para>
			<itemizedlist>
				<listitem>
					<para>structural complexity</para>
					<itemizedlist>
						<listitem>
							<para>by explicit modeling of hierarchical Actor containment and layering</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>behavioral complexity</para>
					<itemizedlist>
						<listitem>
							<para>by hierachical statemachines</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>teamwork complexity</para>
					<itemizedlist>
						<listitem>
							<para>because loosely coupled Actors provide a natural way to structure team work</para>
						</listitem>
						<listitem>
							<para>since textual model notation allows simple branching and merging</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>complexity of concurrent &amp; distributed systems</para>
					<itemizedlist>
						<listitem>
							<para>because loosely coupled Actors are deployable to threads, processes, nodes</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>complexity of variant handling and reuse (e.g. for product lines)</para>
					<itemizedlist>
						<listitem>
							<para>by composition of existing Actors to new structures</para>
						</listitem>
						<listitem>
							<para>since Protocols and Ports make Actors replaceable</para>
						</listitem>
						<listitem>
							<para>by inheritance for structure, behavior and Protocols</para>
						</listitem>
						<listitem>
							<para>by making use of model level libraries</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>complexity of debugging</para>
					<itemizedlist>
						<listitem>
							<para>model level debugging: state machine animation, data inspection and manipulation, message injection, generated message sequence charts</para>
						</listitem>
						<listitem>
							<para>model checking easier for model than for code (detect errors before they occur)</para>
						</listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter id="IntroductiontotheROOMLanguage">
		<title>Introduction to the ROOM Language</title>
		<section id="ScopeofROOM">
			<title>Scope of ROOM</title>
			<para>This chapter will give a rough overview of what ROOM (
				<emphasis role="bold">R</emphasis> eal time 
				<emphasis role="bold">O</emphasis> bject 
				<emphasis role="bold">O</emphasis> riented 
				<emphasis role="bold">M</emphasis> odeling) is and what it is good for. It will try to answer the following questions:
			</para>
			<itemizedlist>
				<listitem>
					<para>Where does it come from?</para>
				</listitem>
				<listitem>
					<para>Which kind of SW-Systems will be addressed?</para>
				</listitem>
				<listitem>
					<para>What is the relation between OOP and ROOM?</para>
				</listitem>
				<listitem>
					<para>What are the benefits of ROOM?</para>
				</listitem>
				<listitem>
					<para>Which consequences must be taken into account?</para>
				</listitem>
			</itemizedlist>
			<section id="Wheredoesitcomefrom">
				<title>Where does it come from?</title>
				<para>Room was developed in the 1990th on the background of the upcoming mobile applications with the goal to manage the complexity of such huge SW-Systems. From the very beginning ROOM has focused on a certain type of SW-Systems and is, in contrast to the UML, well suited for this kind of systems. In this sense, ROOM is a DSL (Domain Specific Language) for distributed, event driven, real time systems. </para>
				<para>Bran Selic, Garth Gullekson and Paul T. Ward have published the concepts 1994 in the book 
					<emphasis role="bold">Real-Time Object-Oriented Modeling</emphasis>. The company 
					<emphasis>object time</emphasis> &#8482; developed a ROOM tool which was taken over by 
					<emphasis>Rational SW</emphasis> &#8482; and later on by 
					<emphasis>IBM</emphasis> &#8482;. 
					The company 
					<emphasis>Protos Software Gmbh</emphasis> &#8482; also developed a ROOM tool called 
					<emphasis>Trice</emphasis> &#8482; for control software for production machines and automotive systems. 
					<emphasis>Trice</emphasis> &#8482; is the predecessor of eTrice (see Introduction to eTrice). 
				</para>
				<para>From our point of view ROOM provides still the clearest, simplest, most complete and best suited modeling concepts for the real time domain. All later proposals like the UML do not fit as well to this kind of problems.</para>
			</section>
			<section id="WhichkindofSWSystemswillbeaddressed">
				<title>Which kind of SW-Systems will be addressed?</title>
				<para>As mentioned before ROOM addresses distributed, event driven, real time systems. But what is a 
					<emphasis role="bold">real time system</emphasis>? ROOM defines a set of properties which are typical for a real time system. These properties are:
				</para>
				<itemizedlist>
					<listitem>
						<para>Timeliness</para>
					</listitem>
					<listitem>
						<para>Dynamic internal structure</para>
					</listitem>
					<listitem>
						<para>Reactiveness</para>
					</listitem>
					<listitem>
						<para>Concurrency</para>
					</listitem>
					<listitem>
						<para>Distribution</para>
					</listitem>
					<listitem>
						<para>Reliability</para>
					</listitem>
				</itemizedlist>
				<para>Each of these properties has potential to make SW development complex. If a given system can be characterized with a combination of or all of these properties, ROOM might be applied to such a system.  </para>
				<para>As an example take a look at a washing machine. The system has to react on user interactions, has to handle some error conditions like a closed water tap or a defective lye pump. It has to react simultaneously to all these inputs. It has to close the water valve in a certain time to avoid flooding the basement. 
					So, the system can be characterized as timely, concurrent and reactive. As long as the washing machine does not transform to a laundry drier by itself, the system has no dynamic internal structure and as long as all functions are running on a single micro controller the (SW)-system is not distributed. 
					ROOM fits perfect to such a system.</para>
				<para>A SW system which mainly consists of data transformations like signal/image processing or a loop controller (e.g. a PID controller) cannot be characterized with any of the above mentioned properties. However, in the real world most of the SW systems will be a combination of both. ROOM can be combined with such systems, so that for example an actor provides a 
					<emphasis role="bold">run to completion</emphasis> context for calculating an image processing algorithm or a PID controller.  
				</para>
			</section>
			<section id="WhatistherelationbetweenOOPandROOM">
				<title>What is the relation between OOP and ROOM?</title>
				<para>The relation between classical object oriented programming and ROOM is comparable to the relation between assembler programming and C programming. It provides a shift of the object paradigm. As the picture shows, the classic object paradigm provides some kind of information hiding. Attributes can be accessed via access methods. Logical higher level methods provide the requested behavior to the user.   </para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/010-RoomIntroduction01.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>As the figure illustrates, the classical object paradigm does not care about concurrency issues. The threads of control will be provided by the underlying operating system and the user is responsible to avoid access violations by using those operating system mechanisms directly (semaphore, mutex).</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/010-RoomIntroduction02.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>ROOM provides the concept of a logical machine (called actor) with its own thread of control. It provides some kind of cooperative communication infrastructure with 
					<emphasis role="bold">run to completion</emphasis> semantic. That makes developing of business logic easy and safe (see basic concepts). The logical machine provides an encapsulation shell including concurrency issues (see chapter 
					<emphasis role="bold">Run to completion</emphasis>). 
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/010-RoomIntroduction03.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>This thinking of an object is much more general than the classic one.  </para>
			</section>
			<section id="WhatarethebenefitsofROOM">
				<title>What are the benefits of ROOM?</title>
				<para>ROOM has a lot of benefits and it depends on the users point of view which is the most important one. From a general point of view the most important benefit is, that ROOM allows to create SW systems very efficient, robust and safe due to the fact that it provides some abstract, high level modeling concepts combined with code generation and a small efficient runtime environment.  </para>
				<para>In detail:</para>
				<itemizedlist>
					<listitem>
						<para>ROOM models contain well defined interfaces (protocols), which makes it easy to reuse components in different applications or e.g. in a test harness. </para>
					</listitem>
					<listitem>
						<para>Graphical modeling makes it easy to understand, maintain and share code with other developers</para>
					</listitem>
					<listitem>
						<para>Higher abstraction in combination with automated code generation provides very efficient mechanisms to the developer. </para>
					</listitem>
					<listitem>
						<para>ROOM provides graphical model execution, which makes it easy to understand the application or find defects in a very early phase. </para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="Whichconsequencesmustbetakenintoaccount">
				<title>Which consequences must be taken into account?</title>
				<para>Generating code from models will introduce some overhead in terms of memory footprint as well as performance. For most systems the overhead will be negligible. However, the decision for using ROOM should be made explicitly and it is always a trade off between development costs, time to market and costs in terms of a little bit more of memory and performance. Thanks to the powerful component model, ROOM is especially well suited for the development of software product lines with their need for reusable core assets.  </para>
				<para>Care must be taken during the introduction of the new methodology. Due to the fact that ROOM provides a shift of the object paradigm, developers and teams need a phase of adaption. Every benefit comes at a price.</para>
			</section>
		</section>
		<section id="BasicConcepts">
			<title>Basic Concepts</title>
			<section id="ActorPortProtocol">
				<title>Actor, Port, Protocol</title>
				<para>The basic elements of ROOM are the actors with their ports and protocols. The protocol provides a formal interface description. The port is an interaction point where the actor interacts with its outside world. Each port has exactly one protocol attached. The sum of all ports builds up the complete interface of an actor. Each port can receive messages, with or without data, which are defined in the attached protocol. Each message will be handled by the actors behavior (state machine) or will be delegated to the actors internal structure.</para>
				<para><table title="Actor and Protocol Example">
						<tr>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-ActorClass.png"/>
						</imageobject>
					</mediaobject></td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-ProtocolClassTextualNotation.png"/>
						</imageobject>
					</mediaobject></td>
						</tr>
						<tr>
							<td align="center">
					<emphasis role="bold">Actor with Subactors</emphasis></td>
							<td align="center">
					<emphasis role="bold">Protocol Definition</emphasis></td>
						</tr>
</table>
				</para>
				<para>The actor provides access protection for its own attributes (including complex types (classical objects)), including concurrency protection. An actor has neither public attributes nor public operations. The only interaction with the outside world takes place via interface ports. This ensures a high degree of reusability on actor level and provides an effective and safe programming model to the developer. </para>
				<para>Receiving a message via a port will trigger the internal state machine. A transition will be executed depending on the message and the current state. Within this transition, detail level code will be executed and response messages can be sent.</para>
				<para>
					<ulink url="http://eclipse.org/etrice/images/010-room-introduction01.avi">video: receiving a message</ulink>
				</para>
				<para>With this model, a complex behavior can be divided into many relatively simple, linked actors. To put it the other way round: The complex behavior will be provided by a network of relatively simple components which are communicating with each other via well defined interfaces.</para>
			</section>
			<section id="HierarchyinStructureandBehavior">
				<title>Hierarchy in Structure and Behavior</title>
				<para>ROOM provides two types of hierarchy. Behavioral hierarchy and structural hierarchy. Structural hierarchy means that actors can be nested to arbitrary depth. Usually you will add more and more details to your application with each nesting level. That means you can focus yourself on any level of abstraction with always the same element, the actor. Structural hierarchy provides a powerful mechanism to divide your problem in smaller pieces, so that you can focus on the level of abstraction you want to work on. </para>
				<para>The actor’s behavior will be described with a state machine. A state in turn may contain sub states. This is another possibility to focus on an abstraction level. Take the simple FSM from the blinky actor from the blinky tutorial. </para>
				<para>Top level:

					<mediaobject>
						<imageobject>
							<imagedata fileref="images\020-Blinky15.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>
					<emphasis>blinking</emphasis> Sub machine:

					<mediaobject>
						<imageobject>
							<imagedata fileref="images\020-Blinky151.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>From an abstract point of view there is a state 
					<emphasis>blinking</emphasis>. But a simple LED is not able to blink autonomously. Therefore you have to add more details to your model to make a LED blinking, but for the current work it is not of interest how the blinking is realized. This will be done in the next lower level of the hierarchy. 
				</para>
				<para>This simple example might give an idea how powerful this mechanisms is.</para>
				<para>The hierarchical FSM provides a rich tool box to describe real world problems (see 
					<emphasis role="bold">room concepts</emphasis>).
				</para>
			</section>
			<section id="Layering">
				<title>Layering</title>
				<para>Layering is another well known form of abstraction to reduce complexity in the structure of systems. ROOM is probably the only language that supports Layering directly as language feature.
					Layering can be expressed in ROOM by Actors with specialized Ports, called Service Access Points (
					<emphasis role="bold">SAP</emphasis>) and Service Provision Points (
					<emphasis role="bold">SPP</emphasis>).
				</para>
				<para>The Actor that provides a service implements an SPP and the client of that service implements an SAP. The Layer Connection connects all SAPs of a specific Protocol within an Actor hierarchy with an SPP that implements the service. From the Actors point of view, SAPs and SPPs behave almost like regular ports.</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\010-LayerExample.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>The Example shows a layered model. The Layer Connections define e.g. that the 
					<emphasis>ApplicationLayer</emphasis> can only use the services of the 
					<emphasis>ServiceLayer</emphasis> and the 
					<emphasis>CommunicationLayer</emphasis>. Actors inside the 
					<emphasis>ApplicationLayer</emphasis> that implement an SAP for those services are connected directly to the implementation of the services. 
					Layering and actor hierarchies with port to port connections can be mixed on every level of granularity. 
				</para>
			</section>
			<section id="RuntoCompletion">
				<title>Run to Completion</title>
				<para>
					<emphasis role="bold">Run to completion</emphasis> (RTC) is a very central concept of ROOM. It enables the developer to concentrate on the functional aspects of the system. The developer doesn’t have to care about concurrency issues all the time. This job is concentrated to the system designer in a very flexible way.
					What does 
					<emphasis role="bold">run to completion</emphasis> mean:
					RTC means that an actor, which is processing a message, can not receive the next message as long as the processing of the current message has been finished. Receiving of the next message will be queued from the underlying run time system.
				</para>
				<para>Note: It is very important not to confuse run to completion and preemption. Run to completion means that an actor will finish the processing of a message before he can receive a new one (regardless of its priority). That does not mean that an actor cannot be preempted from an higher priority thread of control. But even a message from this higher prior thread of control will be queued until the current processing has been finished. </para>
				<para>With this mechanism all actor internal attributes and data structures are protected. Due to the fact that multiple actors share one thread of control, all objects are protected which are accessed from one thread of control but multiple actors. This provides the possibility to decompose complex functionality to several actors without the risk to produce access violations or dead locks.</para>
			</section>
		</section>
		<section id="ExecutionModels">
			<title>Execution Models</title>
			<para>Since from ROOM models executable code can be generated, it is important to define the way the actors are executed and communicate with each other. The combination of communication and execution is called the Execution Model.
				Currently the eTrice tooling only supports the 
				<emphasis role="bold">message driven</emphasis> and parts of the 
				<emphasis role="bold">data driven</emphasis> execution model. In future releases more execution models will be supported, depending on the requirements of the community.
			</para>
			<section id="CommunicationMethods">
				<title>Communication Methods</title>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">message driven</emphasis> (asynchronous, non blocking, no return value): Usually the message driven communication is implemented with message queues. Message queues are inherently asynchronous and enable a very good decoupling of the communicating parties.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">data driven</emphasis> (asynchronous, non blocking, no return value): In data driven communication sender and receiver often have a shared block of data. The sender writes the data and the receiver polls the data.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">function call</emphasis> (synchronous, blocking, return value): Regular function call as known in most programming languages.
						</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="ExecutionMethods">
				<title>Execution Methods</title>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">execution by receive event</emphasis>: The message queue or the event dispatcher calls a 
							<emphasis role="bold">receive event</emphasis> function of the message receiver an thereby executes the processing of the event.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">polled execution</emphasis>: The objects are processed by a cyclic 
							<emphasis role="bold">execute</emphasis> call
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">execution by function call</emphasis>: The caller executes the called object via function call
						</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="ExecutionModels2">
				<title>Execution Models</title>
				<para>In todays embedded systems in most cases one or several of the following execution models are used:</para>
				<section id="messagedriven">
					<title>message driven</title>
					<para>The message driven execution model is a combination of message driven communication and execution by receive event.
						This model allows for distributed systems with a very high throughput.
						It can be deterministic but the determinism is hard to proof.
						This execution model is often found in telecommunication systems and high performance automation control systems.</para>
				</section>
				<section id="datadriven">
					<title>data driven</title>
					<para>The data driven execution model is a combination of data driven communication and polled execution.
						This model is highly deterministic and very robust, but the polling creates a huge performance overhead.
						The determinism is easy to proof (simple mathematics). 
						The execution model is also compatible with the execution model of control software generated by Tools like Matlab&#8482; and LabView&#8482;.
						This model is usually used for systems with requirements for safety, such as automotive and avionic systems.</para>
				</section>
				<section id="synchronous">
					<title>synchronous</title>
					<para>The synchronous execution model could also be called 
						<emphasis role="bold">simple function calls</emphasis>. 
						This model is in general not very well suited to support the 
						<emphasis role="bold">run to completion</emphasis> semantic typical for ROOM models, but could also be generated from ROOM models. 
						With this execution model also lower levels of a software system, such as device drivers, could be generated from ROOM models.
					</para>
				</section>
			</section>
		</section>
	</chapter>
	<chapter id="SettinguptheWorkspace">
		<title>Setting up the Workspace</title>
		<para>ETrice generates code out of ROOM models. The code generator and the generated code relies on a runtime framework and on some ready to use model parts. This parts provide services like:</para>
		<itemizedlist>
			<listitem>
				<para>messaging</para>
			</listitem>
			<listitem>
				<para>logging</para>
			</listitem>
			<listitem>
				<para>timing</para>
			</listitem>
		</itemizedlist>
		<para>Additionally some tutorial models will be provided to make it easy to start with eTrice. All this parts must be available in our workspace before you can start working. After installation of eclipse (indigo) and the eTrice plug in your workspace should look like this:  </para>
		<para>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/013-SetupWorkspace01.png"/>
				</imageobject>
			</mediaobject>
		</para>
		<para>Just the 
			<emphasis>eTrice</emphasis> menu item is visible from the eTrice tool.
			From the 
			<emphasis>File</emphasis> menu select 
			<emphasis>File-&gt;New-&gt;Project</emphasis>
		</para>
		<para>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/013-SetupWorkspace02.png"/>
				</imageobject>
			</mediaobject>
		</para>
		<para>Open the 
			<emphasis>eTrice</emphasis> tab and select 
			<emphasis>eTrice Java Runtime</emphasis>
		</para>
		<para>Press 
			<emphasis>Next</emphasis> and 
			<emphasis>Finish</emphasis> to install the Runtime into your workspace.
		</para>
		<para>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/013-SetupWorkspace03.png"/>
				</imageobject>
			</mediaobject>
		</para>
		<para>Do the same steps for 
			<emphasis>eTrice Java Modellib</emphasis> and 
			<emphasis>eTrice Java Tutorials</emphasis>. To avoid temporary error markers you should keep the proposed order of installation. The resulting workspace should look like this:
		</para>
		<para>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/013-SetupWorkspace04.png"/>
				</imageobject>
			</mediaobject>
		</para>
		<para>Now workspace is set up and you can perform the tutorials or start with your work.</para>
		<para>The tutorial models are available in the 
			<emphasis>org.eclipse.etrice.tutorials</emphasis> project. All tutorials are ready to generate and run without any changes. To start the code generator simply run _gen_org.eclipse.etrice.tutorials.launch_ as _gen_org.eclipse.etrice.tutorials.launch_: 
		</para>
		<para>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/013-SetupWorkspace05.png"/>
				</imageobject>
			</mediaobject>
		</para>
		<para>After generation for each tutorial a java file called _SubSystem_ModelnameRunner.java_ is generated. To run the model simply run this file as a java application:</para>
		<para>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/013-SetupWorkspace06.png"/>
				</imageobject>
			</mediaobject>
		</para>
		<para>To stop the application type 
			<emphasis>quit</emphasis> in the console window.
		</para>
		<para>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/013-SetupWorkspace07.png"/>
				</imageobject>
			</mediaobject>
		</para>
		<para>Performing the tutorials will setup an dedicated project for each tutorial. Therefore there are some slight changes especially whenever a path must be set (e.g. to the model library) within your own projects. All this is described in the tutorials.</para>
	</chapter>
	<chapter id="TutorialHelloWorld">
		<title>Tutorial HelloWorld</title>
		<section id="Scope">
			<title>Scope</title>
			<para>In this tutorial you will build your first very simple eTrice model. The goal is to learn the work flow of eTrice and to understand a few basic features of ROOM. You will perform the following steps:</para>
			<orderedlist>
				<listitem>
					<para>create a new model from scratch</para>
				</listitem>
				<listitem>
					<para>add a very simple state machine to an actor</para>
				</listitem>
				<listitem>
					<para>generate the source code</para>
				</listitem>
				<listitem>
					<para>run the model</para>
				</listitem>
				<listitem>
					<para>open the message sequence chart</para>
				</listitem>
			</orderedlist>
			<para>Make sure that you have set up the workspace as described in 
				<emphasis>Setting up the workspace</emphasis>.
			</para>
			<para>
				<ulink url="http://eclipse.org/etrice/images/015-HelloWorld01.avi">video hello world</ulink>
			</para>
		</section>
		<section id="Createanewmodelfromscratch">
			<title>Create a new model from scratch</title>
			<para>The easiest way to create a new eTrice Project is to use the eclipse project wizard. From the eclipse file menu select 
				<emphasis>File-&gt;New-&gt;Project</emphasis> and create a new eTrice project and name it 
				<emphasis>HelloWorld</emphasis>
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld10.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>The wizard creates everything that is needed to create, build and run an eTrice model. The resulting project should look like this:</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld11.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>Within the model directory the model file 
				<emphasis>HelloWorld.room</emphasis> was created. Open the 
				<emphasis>HelloWorld.room</emphasis> file and delete the contents of the file. Open the content assist with Ctrl+Space and select 
				<emphasis>model skeleton</emphasis>.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld12.png"/>
					</imageobject>
				</mediaobject>   
			</para>
			<para>Edit the template variables by typing the new names and jumping with Tab from name to name.</para>
			<para>The resulting model code should look like this:</para>
			<literallayout><code>RoomModel HelloWorld {

	LogicalSystem System_HelloWorld {
		SubSystemRef subsystem : SubSystem_HelloWorld
	}

	SubSystemClass SubSystem_HelloWorld {
		ActorRef application : HelloWorldTop
	}

	ActorClass HelloWorldTop {
	}
} 
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
			<para>The goal of eTrice is to describe distributed systems on a logical level. In the current version not all elements will be supported. But as prerequisite for further versions the following elements are mandatory for an eTrice model:</para>
			<itemizedlist>
				<listitem>
					<para>the 
						<emphasis>LogicalSystem</emphasis> 
					</para>
				</listitem>
				<listitem>
					<para>at least one 
						<emphasis>SubSystemClass</emphasis>
					</para>
				</listitem>
				<listitem>
					<para>at least one 
						<emphasis>ActorClass</emphasis>
					</para>
				</listitem>
			</itemizedlist>
			<para>The 
				<emphasis>LogicalSystem</emphasis> represents the complete distributed system and contains at least one 
				<emphasis>SubSystemRef</emphasis>. The 
				<emphasis>SubSystemClass</emphasis> represents an address space and contains at least one 
				<emphasis>ActorRef</emphasis>. The 
				<emphasis>ActorClass</emphasis> is the building block of which an application will be built of. It is in general a good idea to define a top level actor that can be used as reference within the subsystem.
			</para>
			<para>The outline view of the textual ROOM editor shows the main modeling elements in an easy to navigate tree.</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld02.png"/>
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="Createastatemachine">
			<title>Create a state machine</title>
			<para>We will implement the Hello World code on the initial transition of the 
				<emphasis>HelloWorldTop</emphasis> actor. Therefore open the state machine editor by right clicking the 
				<emphasis>HelloWorldTop</emphasis> actor in the outline view and select 
				<emphasis>Edit Behavior</emphasis>.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld03.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>The state machine editor will be opened. Drag and drop an 
				<emphasis>Initial Point</emphasis> from the tool box to the diagram into the top level state. Drag and drop a 
				<emphasis>State</emphasis> from the tool box to the diagram. Confirm the dialogue with 
				<emphasis>ok</emphasis>. Select the 
				<emphasis>Transition</emphasis> in the tool box and draw the transition from the 
				<emphasis>Initial Point</emphasis> to the State. Open the transition dialogue by double clicking the caption of the transition and fill in the action code.
			</para>
			<literallayout><code>System.out.println("Hello World !");
</code></literallayout>
			<para>The result should look like this:</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld04.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>Save the diagram and inspect the model file. Note that the textual representation was created after saving the diagram.</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld05.png"/>
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="Buildandrunthemodel">
			<title>Build and run the model</title>
			<para>Now the model is finished and source code can be generated. The project wizard has created a launch configuration that is responsible for generating the source code. From 
				<emphasis>HelloWorld/</emphasis> right click _gen_HelloWorld.launch_ and run it as gen_HelloWorld. All model files in the model directory will be generated.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld06.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>The code will be generated to the src-gen directory. The main function will be contained in _SubSystem_HelloWorldRunner.java_. Select this file and run it as Java application.</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld07.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>The Hello World application starts and the string will be printed on the console window. To stop the application the user must type 
				<emphasis>quit</emphasis> in the console window.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld08.png"/>
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="OpentheMessageSequenceChart">
			<title>Open the Message Sequence Chart</title>
			<para>During runtime the application produced a MSC and wrote it to a file. Open HelloWorld/tmp/log/SubSystem_HelloWorld_Async.seq using Trace2UML (it is open source and can be obtained from  http://trace2uml.tigris.org/). You should see something like this:</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/015-HelloWorld09.png"/>
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="Summary">
			<title>Summary</title>
			<para>Now you have generated your first eTrice model from scratch. You can switch between diagram editor and model (.room file) and you can see what will be generated during editing and saving the diagram files. 
				You should take a look at the generated source files to understand how the state machine is generated and the life cycle of the application. The next tutorials will deal with more complex hierarchies in structure and behavior.</para>
		</section>
	</chapter>
	<chapter id="TutorialBlinky">
		<title>Tutorial Blinky</title>
		<section id="Scope2">
			<title>Scope</title>
			<para>This tutorial describes how to use the 
				<emphasis>TimingService</emphasis>, how to combine a generated model with manual code and how to model a hierarchical state machine. The idea of the tutorial is to switch a LED on and off. The behavior of the LED should be: blinking in a one second interval for 5 seconds, stop blinking for 5 seconds, blinking, stop,...  
				For this exercise we will use a little GUI class that will be used in more sophisticated tutorials too. The GUI simulates a pedestrian traffic crossing. For now, just a simple LED simulation will be used from the GUI. 
			</para>
			<para>After the exercise is created you must copy the GUI to your src directory (see below).</para>
			<para>The package contains four java classes which implements a small window with a 3-light traffic light which simulates the signals for the car traffic and a 2-light traffic light which simulates the pedestrian signals.</para>
			<para>The GUI looks like this:</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky08.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>Within this tutorial we will just toggle the yellow light.</para>
			<para>You will perform the following steps:</para>
			<orderedlist>
				<listitem>
					<para>create a new model from scratch</para>
				</listitem>
				<listitem>
					<para>define a protocol</para>
				</listitem>
				<listitem>
					<para>create an actor structure</para>
				</listitem>
				<listitem>
					<para>create a hierarchical state machine</para>
				</listitem>
				<listitem>
					<para>use the predefined 
						<emphasis>TimingService</emphasis>
					</para>
				</listitem>
				<listitem>
					<para>combine manual code with generated code</para>
				</listitem>
				<listitem>
					<para>build and run the model</para>
				</listitem>
				<listitem>
					<para>open the message sequence chart</para>
				</listitem>
			</orderedlist>
		</section>
		<section id="Createanewmodelfromscratch2">
			<title>Create a new model from scratch</title>
			<para>Remember exercise 
				<emphasis>HelloWorld</emphasis>.
				Create a new eTrice project and name it 
				<emphasis>Blinky</emphasis>
			</para>
			<para>To use the GUI please copy the package 
				<emphasis>org.eclipse.etrice.tutorials.PedLightGUI</emphasis> from 
				<emphasis>org.eclipse.etrice.tutorials/src</emphasis> to your 
				<emphasis role="bold">src</emphasis> directory 
				<emphasis>Blinky/src</emphasis>. For this tutorial you must remove the error markers by editing the file 
				<emphasis>PedestrianLightWndNoTcp.java</emphasis>. Appropriate comments are provided to remove the error marker for this turorial.
			</para>
			<para>Open the 
				<emphasis>Blinky.room</emphasis> file and copy the following code into the file or use content assist to create the model.
			</para>
			<literallayout><code>RoomModel Blinky {

	LogicalSystem System_Blinky {
		SubSystemRef subsystem : SubSystem_Blinky
	}

	SubSystemClass SubSystem_Blinky {
		ActorRef application : BlinkyTop
	}

	ActorClass BlinkyTop {
	}
}
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
		</section>
		<section id="Addtwoadditionalactorclasses">
			<title>Add two additional actor classes</title>
			<para>Position the cursor outside any class definition and right click the mouse within the editor window. From the context menu select 
				<emphasis>Content Assist</emphasis>  
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky02.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>Select 
				<emphasis>ActorClass – actor class skeleton</emphasis> and name it 
				<emphasis>Blinky</emphasis>.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky01.png"/>
					</imageobject>
				</mediaobject> 
			</para>
			<para>Repeat the described procedure and name the new actor 
				<emphasis>BlinkyController</emphasis>.
			</para>
			<para>With Ctrl+Shift+F you can beautify the model code. </para>
			<para>Save the model and visit the outline view.</para>
		</section>
		<section id="Createanewprotocol">
			<title>Create a new protocol</title>
			<para>With the help of 
				<emphasis>Content Assist</emphasis> create a 
				<emphasis>ProtocolClass</emphasis> and name it 
				<emphasis>BlinkyControlProtocol</emphasis>.
				Inside the brackets use the 
				<emphasis>Content Assist</emphasis> (CTRL+Space) to create two incoming messages called 
				<emphasis>start</emphasis> and 
				<emphasis>stop</emphasis>.
			</para>
			<para>The resulting code should look like this:</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky03.png"/>
					</imageobject>
				</mediaobject> 
			</para>
			<para>With Ctrl-Shift+F or selecting 
				<emphasis>Format</emphasis> from the context menu you can format the text. Note that all elements are displayed in the outline view.
			</para>
		</section>
		<section id="ImporttheTimingService">
			<title>Import the Timing Service</title>
			<para>Switching on and off the LED is timing controlled. The timing service is provided from the model library and must be imported before it can be used from the model.</para>
			<para>This is the first time you use an element from the modellib. Make sure that your Java Build Path has the appropriate entry to the modellib. Otherwise the jave code, which will be generated from the modellib, can not be referenced.
				(right click to 
				<emphasis>Blinky</emphasis> and select properties. Select the 
				<emphasis>Java Build Path</emphasis> tab) 
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky16.png"/>
					</imageobject>
				</mediaobject> 
			</para>
			<para>After the build path is set up return to the model and navigate the cursor at the beginning of the model and import the timing service: </para>
			<literallayout><code>RoomModel Blinky {
	
	import room.basic.service.timing.* from "../../org.eclipse.etrice.modellib/models/TimingService.room" 
	
	LogicalSystem System_Blinky {
		SubSystemRef subsystem: SubSystem_Blinky
	}
...	 
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
			<para>Make sure that the path fits to your folder structure.  </para>
			<para>Now it can be used within the model. Right click to _SubSystem_Blinky_ within the outline view. Select 
				<emphasis>Edit Structure</emphasis>. The 
				<emphasis>application</emphasis> is already referenced in the subsystem. Drag and Drop an 
				<emphasis>ActorRef</emphasis> to the _SubSystem_Blinky_ and name it 
				<emphasis>timingService</emphasis>. From the actor class drop down list select 
				<emphasis>room.basic.service.timing.ATimingService</emphasis>. Draw a 
				<emphasis>LayerConnection</emphasis> from 
				<emphasis>application</emphasis> to each service provision point (SPP) of the 
				<emphasis>timingService</emphasis>. The resulting structure should look like this:
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky06.png"/>
					</imageobject>
				</mediaobject> 
			</para>
			<para>The current version of eTrice does not provide a graphical element for a service access point (SAP). Therefore the SAPs to access the timing service must be added in the .room file. Open the 
				<emphasis>Blinky.room</emphasis> file and navigate to the 
				<emphasis>Blinky</emphasis> actor. Add the following line to the structure of the actor:
			</para>
			<literallayout><code>SAP timer: room.basic.service.timing.PTimeout
</code></literallayout>
			<para>Do the same thing for 
				<emphasis>BlinkyController</emphasis>.
			</para>
			<para>The resulting code should look like this:</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky07.png"/>
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="Finishthemodelstructure">
			<title>Finish the model structure</title>
			<para>From the outline view right click to 
				<emphasis>Blinky</emphasis> and select 
				<emphasis>Edit Structure</emphasis>. Drag and Drop an 
				<emphasis>Interface Port</emphasis> to the boarder of the 
				<emphasis>Blinky</emphasis> actor. Note that an interface port is not possible inside the actor. Name the port 
				<emphasis>ControlPort</emphasis> and select 
				<emphasis>BlinkyControlProtocol</emphasis> from the drop down list. Uncheck 
				<emphasis>Conjugated</emphasis> and 
				<emphasis>Is Relay Port</emphasis>. Klick 
				<emphasis>ok</emphasis>. The resulting structure should look like this:
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky04.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>Repeat the above steps for the 
				<emphasis>BlinkyController</emphasis>. Make the port 
				<emphasis>Conjugated</emphasis>
			</para>
			<para>Keep in mind that the protocol defines 
				<emphasis>start</emphasis> and 
				<emphasis>stop</emphasis> as incoming messages. 
				<emphasis>Blinky</emphasis> receives this messages and therefore 
				<emphasis>Blinky</emphasis>'s 
				<emphasis>ControlPort</emphasis> must be a regular port and 
				<emphasis>BlinkyController</emphasis>'s 
				<emphasis>ControlPort</emphasis> must be a conjugated port.
			</para>
			<para>From the outline view right click 
				<emphasis>BlinkyTop</emphasis> and select 
				<emphasis>Edit Structure</emphasis>.
			</para>
			<para>Drag and Drop an 
				<emphasis>ActorRef</emphasis> inside the 
				<emphasis>BlinkyTop</emphasis> actor. Name it 
				<emphasis>blinky</emphasis>. From the actor class drop down list select 
				<emphasis>Blinky</emphasis>. Do the same for 
				<emphasis>controller</emphasis>. Connect the ports via the binding tool. The resulting structure should look like this:
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky05.png"/>
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="ImplementtheBehavior">
			<title>Implement the Behavior</title>
			<para>The application should switch on and off the LED for 5 seconds in a 1 second interval, than stop blinking for 5 seconds and start again. To implement this behavior we will implement two FSMs. One for the 1 second interval and one for the 5 second interval. The 1 second blinking should be implemented in 
				<emphasis>Blinky</emphasis>. The 5 second interval should be implemented in 
				<emphasis>BlinkyController</emphasis>. First implement the Controller.
			</para>
			<para>Right click to 
				<emphasis>BlinkyController</emphasis> and select 
				<emphasis>Edit Behavior</emphasis>.
				Drag and Drop the 
				<emphasis>Initial Point</emphasis> and two 
				<emphasis>States</emphasis> into the top state. Name the states 
				<emphasis>on</emphasis> and 
				<emphasis>off</emphasis>. 
				Use the 
				<emphasis>Transition</emphasis> tool to draw transitions from 
				<emphasis>init</emphasis> to 
				<emphasis>on</emphasis> from 
				<emphasis>on</emphasis> to 
				<emphasis>off</emphasis> and from 
				<emphasis>off</emphasis> to 
				<emphasis>on</emphasis>.
			</para>
			<para>Open the transition dialog by double click the arrow to specify the trigger event and the action code of each transition. Note that the initial transition does not have a trigger event.</para>
			<para>The transition dialog should look like this:</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky09.png"/>
					</imageobject>
				</mediaobject> 
			</para>
			<para>The defined ports will be generated as a member attribute of the actor class from type of the attached protocol. So, to send e message you must state 
				<emphasis>port.message(param);</emphasis>. In this example 
				<emphasis>ControlPort.start()</emphasis> sends the 
				<emphasis>start</emphasis> message via the 
				<emphasis>ControlPort</emphasis> to the outside world. Assuming that 
				<emphasis>Blinky</emphasis> is connected to this port, the message will start the one second blinking FSM. It is the same thing with the 
				<emphasis>timer</emphasis>. The SAP is also a port and follows the same rules. So it is clear that 
				<emphasis>timer.Start(5000);</emphasis> will send the 
				<emphasis>Start</emphasis> message to the timing service. The timing service will send a 
				<emphasis>timeoutTick</emphasis> message back after 5000ms.
			</para>
			<para>Within each transition the timer will be restarted and the appropriate message will be sent via the 
				<emphasis>ControlPort</emphasis>. 
			</para>
			<para>The resulting state machine should look like this:
				(Note that the arrows peak changes if the transition contains action code.)</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky10.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>Save the diagram and inspect the 
				<emphasis>Blinky.room</emphasis> file. The 
				<emphasis>BlinkyController</emphasis> should look like this:
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky11.png"/>
					</imageobject>
				</mediaobject> 
			</para>
			<para>Now we will implement 
				<emphasis>Blinky</emphasis>. Due to the fact that 
				<emphasis>Blinky</emphasis> interacts with the GUI class a view things must to be done in the model file.
			</para>
			<para>Double click 
				<emphasis>Blinky</emphasis> in the outline view to navigate to 
				<emphasis>Blinky</emphasis> within the model file.
				Add the following code:
				(type it or simply copy it from the tutorial project)
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky12.png"/>
					</imageobject>
				</mediaobject> 
			</para>
			<para>
				<emphasis>usercode1</emphasis> will be generated at the beginning of the file, outside the class definition. 
				<emphasis>usercode2</emphasis> will be generated within the class definition. The code imports the GUI class and instantiates the window class. Attributes for the carLights and pedLights will be declared to easily access the lights in the state machine.
				The Operation 
				<emphasis>destroyUser()</emphasis> is a predefined operation that will be called during shutdown of the application. Within this operation, cleanup of manual coded classes can be done.
			</para>
			<para>Now design the FSM of 
				<emphasis>Blinky</emphasis>. Remember, as the name suggested 
				<emphasis>blinking</emphasis> is a state in which the LED must be switched on and off. We will realize that by an hierarchical FSM in which the 
				<emphasis>blinking</emphasis> state has two sub states.
			</para>
			<para>Open the behavior diagram of 
				<emphasis>Blinky</emphasis> by right clicking the 
				<emphasis>Blinky</emphasis> actor in the outline view. Create two states named 
				<emphasis>blinking</emphasis> and 
				<emphasis>off</emphasis>. Right click to 
				<emphasis>blinking</emphasis> and create a subgraph.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky13.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>Create the following state machine. The trigger events between 
				<emphasis>on</emphasis> and 
				<emphasis>off</emphasis> are the 
				<emphasis>timeoutTick</emphasis> from the 
				<emphasis>timer</emphasis> port. 
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky14.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>Create entry code for both states by right clicking the state and select 
				<emphasis>Edit State...</emphasis>
			</para>
			<para>Entry code of 
				<emphasis>on</emphasis> is:
			</para>
			<literallayout><code>timer.Start(1000);
carLights.setState(TrafficLight3.YELLOW); 
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
			<para>Entry code  of 
				<emphasis>off</emphasis> is:
			</para>
			<literallayout><code>timer.Start(1000);
carLights.setState(TrafficLight3.OFF);
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
			<para>Navigate to the Top level state by double clicking the 
				<emphasis>/blinking</emphasis> state. Create the following state machine:
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky15.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>The trigger event from 
				<emphasis>off</emphasis> to 
				<emphasis>blinking</emphasis> is the 
				<emphasis>start</emphasis> event from the 
				<emphasis>ControlPort</emphasis>.The trigger event from 
				<emphasis>blinking</emphasis> to 
				<emphasis>off</emphasis> is the 
				<emphasis>stop</emphasis> event from the 
				<emphasis>ControlPort</emphasis>.
				Note: The transition from 
				<emphasis>blinking</emphasis> to 
				<emphasis>off</emphasis> is a so called group transition. This is a outgoing transition from a super state (state with sub states) without specifying the concrete leave state (state without sub states). An incoming transition to a super state is called history transition.   
			</para>
			<para>Action code of the init transition is:</para>
			<literallayout><code>carLights = light.getCarLights();
pedLights = light.getPedLights();
carLights.setState(TrafficLight3.OFF);
pedLights.setState(TrafficLight2.OFF);
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
			<para>Action code from 
				<emphasis>blinking</emphasis> to 
				<emphasis>off</emphasis> is:
			</para>
			<literallayout><code>timer.Kill();
carLights.setState(TrafficLight3.OFF); 
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
			<para>The model is complete now. You can run and debug the model as described in getting started. Have fun.</para>
			<para>The complete model can be found in /org.eclipse.etrice.tutorials/model/Blinky.</para>
		</section>
		<section id="Summary2">
			<title>Summary</title>
			<para>Run the model and take a look at the generated MSCs. Inspect the generated code to understand the runtime model of eTrice. Within this tutorial you have learned how to create a hierarchical FSM with group transitions and history transitions and you have used entry code. You are now familiar with the basic features of eTrice. The further tutorials will take this knowledge as a precondition.</para>
		</section>
	</chapter>
	<chapter id="TutorialSendingData">
		<title>Tutorial Sending Data</title>
		<section id="Scope3">
			<title>Scope</title>
			<para>This tutorial shows how data will be sent in a eTrice model. Within the example you will create two actors (MrPing and MrPong). MrPong will simply loop back every data it received.
				MrPing will send data and verify the result.   </para>
			<para>You will perform the following steps:</para>
			<orderedlist>
				<listitem>
					<para>create a new model from scratch</para>
				</listitem>
				<listitem>
					<para>create a data class</para>
				</listitem>
				<listitem>
					<para>define a protocol with attached data</para>
				</listitem>
				<listitem>
					<para>create an actor structure</para>
				</listitem>
				<listitem>
					<para>create two simple state machines</para>
				</listitem>
				<listitem>
					<para>build and run the model</para>
				</listitem>
			</orderedlist>
		</section>
		<section id="Createanewmodelfromscratch3">
			<title>Create a new model from scratch</title>
			<para>Remember exercise 
				<emphasis>HelloWorld</emphasis>.
				Create a new eTrice project and name it 
				<emphasis>SendingData</emphasis>
				Open the 
				<emphasis>SendingData.room</emphasis> file and copy the following code into the file or use content assist to create the model.
			</para>
			<literallayout><code>RoomModel SendingData {
		LogicalSystem SendingData_LogSystem {
			SubSystemRef SendingDataAppl:SendingData_SubSystem 
		}
		SubSystemClass SendingData_SubSystem {
			ActorRef SendigDataTopRef:SendingDataTop 
		}
		ActorClass SendingDataTop {
		}
	}
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
		</section>
		<section id="Addadataclass">
			<title>Add a data class</title>
			<para>Position the cursor outside any class definition and right click the mouse within the editor window. From the context menu select 
				<emphasis>Content Assist</emphasis> (or Ctrl+Space).  
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/025-SendingData01.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>Select 
				<emphasis>DataClass – data class skeleton</emphasis> and name it 
				<emphasis>DemoData</emphasis>.
				Remove the operations and add the following Attributes:
			</para>
			<literallayout><code>	DataClass DemoData {
		Attribute int32Val: int32 = "4711"
		Attribute int8Array [ 10 ]: int8 = "{1,2,3,4,5,6,7,8,9,10}"
		Attribute float64Val: float64 = "0.0"
		Attribute stringVal: string = "\"empty\""
	}
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
			<para>Save the model and visit the outline view.
				Note that the outline view contains all data elements as defined in the model. </para>
		</section>
		<section id="Createanewprotocol2">
			<title>Create a new protocol</title>
			<para>With the help of 
				<emphasis>Content Assist</emphasis> create a 
				<emphasis>ProtocolClass</emphasis> and name it 
				<emphasis>PingPongProtocol</emphasis>. Create the following messages:
			</para>
			<literallayout><code>ProtocolClass PingPongProtocol {
					incoming {
						Message ping(data: DemoData)
						Message pingSimple(data:int32)
					}
					outgoing {
						Message pong(data: DemoData)
						Message pongSimple(data:int32)
					}
				}		
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
		</section>
		<section id="CreateMrPingandMrPongActors">
			<title>Create MrPing and MrPong Actors</title>
			<para>With the help of 
				<emphasis>Content Assist</emphasis> create two new actor classes and name them 
				<emphasis>MrPing</emphasis> and 
				<emphasis>MrPong</emphasis>. The resulting model should look like this:
			</para>
			<literallayout><code>RoomModel SendingData {

	LogicalSystem SendingData_LogSystem {
		SubSystemRef SendingDataAppl: SendingData_SubSystem
	}

	SubSystemClass SendingData_SubSystem {
		ActorRef SendigDataTopRef: SendingDataTop
	}

	ActorClass SendingDataTop { }

	DataClass DemoData {
		Attribute int32Val: int32 = "4711"
		Attribute int8Array [ 10 ]: int8 = "{1,2,3,4,5,6,7,8,9,10}"
		Attribute float64Val: float64 = "0.0"
		Attribute stringVal: string = "\"empty\""
	}

	ProtocolClass PingPongProtocol {
		incoming {
			Message ping(data: DemoData)
			Message pingSimple(data: int32)
		}
		outgoing {
			Message pong(data: DemoData)
			Message pongSimple(data: int32)
		}
	}

	ActorClass MrPing {
		Interface { }
		Structure { }
		Behavior { }
	}

	ActorClass MrPong {
		Interface { }
		Structure { }
		Behavior { }
	}
} 

</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
			<para>The outline view should look like this:</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/025-SendingData03.png"/>
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="DefineActorStructureandBehavior">
			<title>Define Actor Structure and Behavior</title>
			<para>Save the model and visit the outline view. Within the outline view, right click on the 
				<emphasis>MrPong</emphasis> actor and select 
				<emphasis>Edit Structure</emphasis>. Select an 
				<emphasis>Interface Port</emphasis> from the toolbox and add it to MrPong. Name the Port 
				<emphasis>PingPongPort</emphasis> and select the 
				<emphasis>PingPongProtocol</emphasis>
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/025-SendingData02.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>Do the same with MrPing but mark the port as 
				<emphasis>conjugated</emphasis>
			</para>
			<section id="DefineMrPongsbehavior">
				<title>Define MrPongs behavior</title>
				<para>Within the outline view, right click MrPong and select 
					<emphasis>Edit Behavior</emphasis>. Create the following state machine:
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/025-SendingData04.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>The transition dialogues should look like this:
					For 
					<emphasis>ping</emphasis>:
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/025-SendingData05.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>For 
					<emphasis>pingSimple</emphasis>:
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/025-SendingData06.png"/>
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section id="DefineMrPingbehavior">
				<title>Define MrPing behavior</title>
				<para>Within the outline view double click MrPing. Navigate the cursor to the behavior of MrPing. With the help of content assist create a new operation.</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/025-SendingData07.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>Name the operation 
					<emphasis>printData</emphasis> and define the DemoData as a parameter.
				</para>
				<para>Fill in the following code:</para>
				<literallayout><code>Operation printData(d: DemoData) : void {
			"System.out.printf(\"d.int32Val: %d\\n\",d.int32Val);"
			"System.out.printf(\"d.float64Val: %f\\n\",d.float64Val);"
			"System.out.printf(\"d.int8Array: \");"
			"for(int i = 0; i&lt;d.int8Array.length; i++) {"
			"System.out.printf(\"%d \",d.int8Array[i]);}"
			"System.out.printf(\"\\nd.stringVal: %s\\n\",d.stringVal);"
		}
</code></literallayout>
				<blockquote>
					<para></para>
				</blockquote>
				<para>For MrPing create the following state machine:
					(Remember that you can copy and paste the action code from the tutorial directory.)</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/025-SendingData08.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>The transition dialogues should look like this:</para>
				<para>For 
					<emphasis>init</emphasis>:
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/025-SendingData09.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>For 
					<emphasis>wait1</emphasis>:
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/025-SendingData10.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>For 
					<emphasis>next</emphasis>:
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/025-SendingData11.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>For 
					<emphasis>wait2</emphasis>:
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/025-SendingData12.png"/>
						</imageobject>
					</mediaobject>
				</para>
			</section>
		</section>
		<section id="Definethetoplevel">
			<title>Define the top level</title>
			<para>Open the Structure from SendingDataTop and add MrPing and MrPong as a reference. Connect the ports.</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/025-SendingData13.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>The model is finished now and can be found in /org.eclipse.etrice.tutorials/model/SendingData.</para>
		</section>
		<section id="Generateandrunthemodel">
			<title>Generate and run the model</title>
			<para>Generate the code by right click to _gen_SendingData.launch_ and run it as _gen_SendingData_. Run the model. 
				The output should look like this:</para>
			<blockquote>
				<para>
					type &#8218;quit’ to exit
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPongSimple
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					data: 1
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPongSimple
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					data: 2
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPongSimple
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					data: 3
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPongSimple
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					data: 4
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPongSimple
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					data: 5
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPongSimple
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					data: 6
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPongSimple
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					data: 7
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPongSimple
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					data: 8
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPongSimple
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					data: 9
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPongSimple
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					data: 10
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPong
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					/SendingData_SubSystem/SendigDataTopRef/ref1 -&gt; looping
					d.int32Val: 4711
					d.float64Val: 0,000000
					d.int8Array: 1 2 3 4 5 6 7 8 9 10 
					d.stringVal: empty
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPong
					d.int32Val: 815
					d.float64Val: 3,141234
					d.int8Array: 100 101 102 103 104 105 106 107 108 109 
					d.stringVal: some contents
					/SendingData_SubSystem/SendigDataTopRef/ref0 -&gt; waitForPong
					quit
					echo: quit</para>
			</blockquote>
			<blockquote>
				<para></para>
			</blockquote>
		</section>
		<section id="Summary3">
			<title>Summary</title>
			<para>Within the first loop an integer value will be incremented by 
				<emphasis>MrPong</emphasis> and sent back to 
				<emphasis>MrPing</emphasis>. As long as the guard is true 
				<emphasis>MrPing</emphasis> sends back the value.
			</para>
			<para>Within the 
				<emphasis>next</emphasis> transition, 
				<emphasis>MrPing</emphasis> creates a data class and sends the default values. Then 
				<emphasis>MrPing</emphasis> changes the values and sends the class again. At this point you should note that during the send operation, a copy of the data class will be created and sent. Otherwise it would not be possible to send the same object two times, even more it would not be possible to send a stack object at all. This type of data passing is called 
				<emphasis>sending data by value</emphasis>.
				However, for performance reasons some applications requires 
				<emphasis>sending data by reference</emphasis>. In this case the user is responsible for the life cycle of the object. In Java the VM takes care of the life cycle of an object. This is not the case for C/C++. Consider that a object which is created within a transition of a state machine will be destroyed when the transition is finished. The receiving FSM would receive an invalid reference. Therefore care must be taken when sending references.      
			</para>
			<para>For sending data by reference you simply have to add the keyword 
				<emphasis>ref</emphasis> to the protocol definition.
			</para>
			<literallayout><code>Message ping(data: DemoData ref)
</code></literallayout>
			<para>Make the test and inspect the console output.</para>
		</section>
	</chapter>
	<chapter id="TutorialPedestrianLights">
		<title>Tutorial Pedestrian Lights</title>
		<section id="Scope4">
			<title>Scope</title>
			<para>The scope of this tutorial is to demonstrate how to receive model messages from outside the model. Calling methods which are not part of the model is simple and you have already done this within the blinky tutorial (this is the other way round: model =&gt; external code). Receiving events from outside the model is a very common problem and a very frequently asked question. Therefore this tutorial shows how an external event (outside the model) can be received by the model.</para>
			<para>This tutorial is not like hello world or blinky. Being familiar with the basic tool features is mandatory for this tutorial. The goal is to understand the mechanism not to learn the tool features.</para>
			<para>The idea behind the exercise is, to control a Pedestrian crossing light. We will use the same GUI as for the blinky tutorial but now we will use the 
				<emphasis>REQUEST</emphasis> button to start a FSM, which controls the traffic lights.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/020-Blinky08.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>The 
				<emphasis>REQUEST</emphasis> must lead to a model message which starts the activity of the lights.
			</para>
			<para>There are several possibilities to receive external events (e.g. TCP/UDP Socket, using OS messaging mechanism), but the easiest way is, to make a port usable from outside the model. To do that a few steps are necessary:</para>
			<orderedlist>
				<listitem>
					<para>specify the messages (within a protocol) which should be sent into the model</para>
				</listitem>
				<listitem>
					<para>model an actor with a port (which uses the specified protocol) and connect the port to the receiver </para>
				</listitem>
				<listitem>
					<para>the external code should know the port (import of the port class)</para>
				</listitem>
				<listitem>
					<para>the external code should provide a registration method, so that the actor is able to allow access to this port</para>
				</listitem>
				<listitem>
					<para>the port can be used from the external code</para>
				</listitem>
			</orderedlist>
		</section>
		<section id="Setupthemodel">
			<title>Setup the model</title>
			<itemizedlist>
				<listitem>
					<para>Use the 
						<emphasis>New Model Wizzard</emphasis> to create a new eTrice project and name it 
						<emphasis>PedLightsController</emphasis>.
					</para>
				</listitem>
				<listitem>
					<para>Copy the package 
						<emphasis>org.eclipse.etrice.tutorials.PedLightGUI</emphasis> to your 
						<emphasis>src</emphasis> directory (see blinky tutorial).
					</para>
				</listitem>
				<listitem>
					<para>In PedestrianLightWndNoTcp.jav uncomment line 15 (import), 36, 122 (usage) and 132-134 (registration). The error markers will disappear after the code is generated from the model.</para>
				</listitem>
				<listitem>
					<para>Copy the model from /org.eclipse.etrice.tutorials/model/PedLightsController to your model file, or run the model directly in the tutorial directory. </para>
				</listitem>
				<listitem>
					<para>Adapt the import statement to your path.</para>
				</listitem>
			</itemizedlist>
			<literallayout><code>import room.basic.service.timing.* from "../../org.eclipse.etrice.modellib/models/TimingService.room" 
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
			<itemizedlist>
				<listitem>
					<para>Generate the code from the model.</para>
				</listitem>
				<listitem>
					<para>Add the org.eclipse.etrice.modellib to the Java Class Path of your project.</para>
				</listitem>
				<listitem>
					<para>All error markers should be disappeared and the model should be operable. </para>
				</listitem>
				<listitem>
					<para>Arrange the Structure and the Statemachines to understand the model</para>
				</listitem>
			</itemizedlist>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/030-PedLights01.png"/>
					</imageobject>
				</mediaobject>
				The 
				<emphasis>GuiAdapter</emphasis> represents the interface to the external code. It registers its 
				<emphasis>ControlPort</emphasis> by the external code.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/030-PedLights02.png"/>
					</imageobject>
				</mediaobject>
				Visit the initial transition to understand the registration. The actor handles the incoming messages as usual and controls the traffic lights as known from blinky. 
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/030-PedLights03.png"/>
					</imageobject>
				</mediaobject>
				The 
				<emphasis>Controller</emphasis> receives the 
				<emphasis>start</emphasis> message and controls the timing of the lights. Note that the 
				<emphasis>start</emphasis> message will be sent from the external code whenever the 
				<emphasis>REQUEST</emphasis> button is pressed.
			</para>
			<itemizedlist>
				<listitem>
					<para> Visit the model and take a closer look to the following elements:</para>
				</listitem>
			</itemizedlist>
			<orderedlist>
				<listitem>
					<para>PedControlProtocol =&gt; notice that the start message is defined as usual</para>
				</listitem>
				<listitem>
					<para>Initial transition of the 
						<emphasis>GuiAdapter</emphasis> =&gt; see the registration
					</para>
				</listitem>
				<listitem>
					<para>The 
						<emphasis>Controller</emphasis> =&gt; notice that the 
						<emphasis>Controller</emphasis> receives the external message (not the 
						<emphasis>GuiAdapter</emphasis>). The 
						<emphasis>GuiAdapter</emphasis> just provides its port and handles the incoming messages.
					</para>
				</listitem>
				<listitem>
					<para>Visit the hand written code =&gt; see the import statement of the protocol class and the usage of the port.</para>
				</listitem>
			</orderedlist>
			<itemizedlist>
				<listitem>
					<para>Generate and test the model</para>
				</listitem>
				<listitem>
					<para>Take a look at the generated MSC =&gt; notice that the start message will shown as if the 
						<emphasis>GuiAdapter</emphasis> had sent it.
					</para>
				</listitem>
			</itemizedlist>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/030-PedLights04.png"/>
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="Whydoesitworkandwhyisitsafe">
			<title>Why does it work and why is it safe?</title>
			<para>The tutorial shows that it is generally possible to use every port from outside the model as long as the port knows its peer. This is guaranteed by describing protocol and the complete structure (especially the bindings) within the model. 
				The only remaining question is: Why is it safe and does not violate the 
				<emphasis role="bold">run to completion</emphasis> semantic. To answer this question, take a look at the 
				<emphasis>MessageService.java</emphasis> from the runtime environment. There you will find the receive method which puts each message into the queue. 
			</para>
			<literallayout><code>	@Override
	public synchronized void receive(Message msg) {
		if (msg!=null) {
			messageQueue.push(msg);
			notifyAll(); // wake up thread to compute message
		}
	}
</code></literallayout>
			<blockquote>
				<para></para>
			</blockquote>
			<para>This method is synchronized. That means, regardless who sends the message, the queue is secured. If we later on (e.g. for performance reasons in C/C++) distinguish between internal and external senders (same thread or not), care must be taken to use the external (secure) queue.</para>
		</section>
	</chapter>
	<chapter id="ROOMConcepts">
		<title>ROOM Concepts</title>
		<para>This chapter gives an overview over the ROOM language elements and their textual and graphical notation.
			The formal ROOM grammar based on Xtext (EBNF) you can find here: 
			<ulink url="http://git.eclipse.org/c/etrice/org.eclipse.etrice.git/tree/plugins/org.eclipse.etrice.core.room/src/org/eclipse/etrice/core/Room.xtext">ROOM Grammar</ulink>
		</para>
		<section id="Actors">
			<title>Actors</title>
			<section id="Description">
				<title>Description</title>
				<para>The actor is the basic structural building block for building systems with ROOM. An actor can be refined hierarchically and thus can be of arbitrarily large scope. Ports define the interface of an actor. An Actor can also have a behavior usually defined by a finite state machine.</para>
			</section>
			<section id="Motivation">
				<title>Motivation</title>
				<itemizedlist>
					<listitem>
						<para>Actors enable the construction of hierarchical structures by composition and layering</para>
					</listitem>
					<listitem>
						<para>Actors have their own logical thread of execution</para>
					</listitem>
					<listitem>
						<para>Actors can be freely deployed</para>
					</listitem>
					<listitem>
						<para>Actors define potentially reusable blocks</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="Notation">
				<title>Notation</title>
				<para><table title="Actor Class Notation" frame="box" border="2" cellpadding="3" cellspacing="0" >
						<tr>
							<td align="center">
					<emphasis role="bold">Element</emphasis></td>
							<td align="center">
					<emphasis role="bold">Graphical Notation</emphasis></td>
							<td align="center">
					<emphasis role="bold">Textual Notation</emphasis></td>
						</tr>
						<tr>
							<td>ActorClass</td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-ActorClassNotation.png"/>
						</imageobject>
					</mediaobject></td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-ActorClassTextualNotation.png"/>
						</imageobject>
					</mediaobject></td>
						</tr>
						<tr>
							<td>ActorRef</td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-ActorReferenceNotation.png"/>
						</imageobject>
					</mediaobject></td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-ActorReferenceTextualNotation.png"/>
						</imageobject>
					</mediaobject></td>
						</tr>
</table>					 
				</para>
			</section>
			<section id="Details">
				<title>Details</title>
				<section id="ActorClassesActorReferencesPortsandBindings">
					<title>Actor Classes, Actor References, Ports and Bindings</title>
					<para>An 
						<emphasis role="bold">ActorClass</emphasis> defines the type (or blueprint) of an actor. Hierarchies are built by ActorClasses that contain 
						<emphasis role="bold">ActorReferences</emphasis> which have another ActorClass as type. The interface of an ActorClass is always defined by Ports. The ActorClass can also contain Attributes, Operations and a finite state machine. 
					</para>
					<para>
						<emphasis role="bold">External Ports</emphasis> define the external interface of an actor and are defined in the 
						<emphasis role="bold">Interface</emphasis> section of the ActorClass.
					</para>
					<para>
						<emphasis role="bold">Internal Ports</emphasis> define the internal interface of an actor and are defined in the 
						<emphasis role="bold">Structure</emphasis> section of the ActorClass.
					</para>
					<para>
						<emphasis role="bold">Bindings</emphasis> connect Ports inside an ActorClass.
					</para>
					<para>Example:</para>
					<para><table title="Actor Class Example" frame="box" border="2" cellpadding="3" cellspacing="0" >
							<tr>
								<td align="center">
						<emphasis role="bold">Graphical Notation</emphasis></td>
								<td align="center">
						<emphasis role="bold">Textual Notation</emphasis></td>
							</tr>
							<tr>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ActorClass.png"/>
							</imageobject>
						</mediaobject></td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ActorClassExampleTextualNotation.png"/>
							</imageobject>
						</mediaobject></td>
							</tr>
</table>						 
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>ActorClass1</emphasis> contains two ActorReferences (of ActorClass2 and ActorClass3)
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>port1</emphasis> is a 
								<emphasis role="bold">External End Port</emphasis>. Since it connects external Actors with the behavior of the ActorClass, it is defined in the 
								<emphasis role="bold">Interface</emphasis> section and the 
								<emphasis role="bold">Structure</emphasis> section of the ActorClass.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>port2</emphasis> and 
								<emphasis>port3</emphasis> are 
								<emphasis role="bold">Internal End Ports</emphasis> and can only be connected to the ports of contained ActorReferences. Internal End Ports connect the Behavior of an ActorClass with its contained ActorReferences.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>port4</emphasis> is a relay port and connects external Actors to contained ActorReferences. This port can not be accessed by the behavior of the ActorClass.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>port5</emphasis> through 
								<emphasis>port9</emphasis> are Ports of contained ActorReferences. 
								<emphasis>port8</emphasis> and 
								<emphasis>port9</emphasis> can communicate without interference with the containing ActorClass.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis role="bold">Bindings</emphasis> can connect ports of the ActorClass and its contained ActorReferences. 
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section id="Attributes">
					<title>Attributes</title>
					<para>Attributes are part of the Structure of an ActorClass. They can be of a PrimitiveType or a DataClass.</para>
					<para>Example:</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ActorClassAttributes.png"/>
							</imageobject>
						</mediaobject>
					</para>
				</section>
				<section id="Operations">
					<title>Operations</title>
					<para>Operations are part of the Behavior of an ActorClass.  Arguments and return values can be of a PrimitiveType or a DataClass. DataClasses can be passed by value (implicit) or by reference (keyword 
						<emphasis role="bold">ref</emphasis>).
					</para>
					<para>Example:</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ActorClassOperations.png"/>
							</imageobject>
						</mediaobject>
					</para>
				</section>
			</section>
		</section>
		<section id="Protocols">
			<title>Protocols</title>
			<section id="Description2">
				<title>Description</title>
				<para>A ProtocolClass defines a set of incoming and outgoing messages that can be exchanged between two ports.
					The exact semantics of a message is defined by the execution model.</para>
			</section>
			<section id="Motivation2">
				<title>Motivation</title>
				<itemizedlist>
					<listitem>
						<para>ProtocolClasses provide a reusable interface specification for ports</para>
					</listitem>
					<listitem>
						<para>ProtocolClasses can optionally specify valid message exchange sequences</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="Notation2">
				<title>Notation</title>
				<para>ProtocolClasses have only textual notation. 
					The example defines a ProtocolClass with 2 incoming and two outgoing messages. Messages can have data attached. The data can be of a primitive type (e.g. int32, float64, ...) or a DataClass.</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-ProtocolClassTextualNotation.png"/>
						</imageobject>
					</mediaobject>
				</para>
			</section>
		</section>
		<section id="Ports">
			<title>Ports</title>
			<para>here is a line</para>
			<para><table border="1" cellpadding="3" cellspacing="0" width="60%">
				  <tr>
				    <th width="50%">Element</th>
				    <th>Graphical Notation</th>
				    <th>Textual Notation</th>
				  </tr>
				  <tr>
				    <td width="50%">Berlin</td>
				    <td>Hamburg</td>
				    <td>M&amp;uuml;nchen</td>
				  </tr>
				  <tr>
				    <td>Milj&amp;ouml;h</td>
				    <td>Kiez</td>
				    <td>Bierdampf</td>
				  </tr>
				  <tr>
				    <td>Buletten</td>
				    <td>Frikadellen</td>
				    <td>Fleischpflanzerl</td>
				  </tr>
</table></para>
			<para>end of table</para>
			<section id="Description3">
				<title>Description</title>
				<para>Ports are the only interfaces of actors. A port has always a protocol assigned. 
					Service Access Points (SAP) and Service Provision Points (SPP) are specialized ports that are used to define layering.</para>
			</section>
			<section id="Motivation3">
				<title>Motivation</title>
				<itemizedlist>
					<listitem>
						<para>Ports decouple interface definition (Protocols) from interface usage</para>
					</listitem>
					<listitem>
						<para>Ports decouple the logical interface from the transport </para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="Notation3">
				<title>Notation</title>
				<section id="ClassPorts">
					<title>Class Ports</title>
					<para>These symbols can only appear on the border of an actor class symbol. </para>
					<para>Ports that define an external interface of the ActorClass, are defined in the 
						<emphasis>Interface</emphasis>. Ports that define an internal interface are defined in the 
						<emphasis>Structure</emphasis> (e.g. internal ports).
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis role="bold">External End Ports</emphasis> are defined in the Interface and the Structure
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis role="bold">Internal End Ports</emphasis> are only defined in the Structure
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis role="bold">Relay Ports</emphasis> are only defined in the Interface
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis role="bold">End Ports</emphasis> are always connected to the internal behavior of the ActorClass
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis role="bold">Replicated Ports</emphasis> can be defined with a fixed replication factor ( e.g. 
								<emphasis>Port port18 [ 5 ]: ProtocolClass1</emphasis> ) or a variable replication factor (e.g. 
								<emphasis>Port port18[ * ]: ProtocolClass1</emphasis> )
							</para>
						</listitem>
					</itemizedlist>
					<para><table title="Class Port Notation" frame="box" border="2" cellpadding="3" cellspacing="0">
							<tr>
								<td align="center">
						<emphasis role="bold">Element</emphasis></td>
								<td align="center" width="15%">
						<emphasis role="bold">Graphical Notation</emphasis></td>
								<td align="center">
						<emphasis role="bold">Textual Notation</emphasis></td>
							</tr>
							<tr>
								<td>Class End Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ClassEndPort.png"/>
							</imageobject>
						</mediaobject></td>
								<td>
									
						<emphasis role="bold">External Class End Port:</emphasis>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ClassEndPortTextual.png"/>
							</imageobject>
						</mediaobject>
									
						<emphasis role="bold">Internal Class End Port:</emphasis>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ClassEndPortInternalTextual.png"/>
							</imageobject>
						</mediaobject>
								</td>
							</tr>
							<tr>
								<td>Conjugated Class End Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedClassEndPort.png"/>
							</imageobject>
						</mediaobject></td>
								<td>
									
						<emphasis role="bold">External Conjugated Class End Port:</emphasis>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedClassEndPortTextual.png"/>
							</imageobject>
						</mediaobject>
									
						<emphasis role="bold">Internal Conjugated Class End Port:</emphasis>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedClassEndPortInternalTextual.png"/>
							</imageobject>
						</mediaobject>
								</td>
							</tr>
							<tr>
								<td>Class Relay Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ClassRelayPort.png"/>
							</imageobject>
						</mediaobject></td>
								<td>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ClassRelayPortTextual.png"/>
							</imageobject>
						</mediaobject>
								</td>
							</tr>
							<tr>
								<td>Conjugated Class Relay Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedClassRelayPort.png"/>
							</imageobject>
						</mediaobject></td>
								<td>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedClassRelayPortTextual.png"/>
							</imageobject>
						</mediaobject>
								</td>
							</tr>
							<tr>
								<td>Replicated Class End Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ReplicatedClassEndPort.png"/>
							</imageobject>
						</mediaobject></td>
								<td>
									
						<emphasis role="bold">External Replicated Class End Port:</emphasis>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ReplicatedClassEndPortTextual.png"/>
							</imageobject>
						</mediaobject>
									
						<emphasis role="bold">Internal Replicated Class End Port:</emphasis>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ReplicatedClassEndPortInternalTextual.png"/>
							</imageobject>
						</mediaobject>
								</td>
							</tr>
							<tr>
								<td>Conjugated Replicated Class End Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedReplicatedClassEndPort.png"/>
							</imageobject>
						</mediaobject></td>
								<td>
									
						<emphasis role="bold">External Conjugated Replicated Class End Port:</emphasis>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedReplicatedClassEndPortTextual.png"/>
							</imageobject>
						</mediaobject>
									
						<emphasis role="bold">Internal Conjugated Replicated Class End Port:</emphasis>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedReplicatedClassEndPortInternalTextual.png"/>
							</imageobject>
						</mediaobject>
								</td>
							</tr>
							<tr>
								<td>Replicated Class Relay Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ReplicatedClassRelayPort.png"/>
							</imageobject>
						</mediaobject></td>
								<td>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ReplicatedClassRelayPortTextual.png"/>
							</imageobject>
						</mediaobject>
								</td>
							</tr>
							<tr>
								<td>Conjugated Replicated Class Relay Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedReplicatedClassRelayPort.png"/>
							</imageobject>
						</mediaobject></td>
								<td>
									
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedReplicatedClassRelayPortTextual.png"/>
							</imageobject>
						</mediaobject>
								</td>
							</tr>
</table>
					</para>
				</section>
				<section id="ReferencePorts">
					<title>Reference Ports</title>
					<para>These symbols can only appear on the border of an ActorReference symbol. Since the type of port is defined in the ActorClass, no textual notation for the Reference Ports exists.</para>
					<para><table title="Title" frame="box" border="2" cellpadding="3" cellspacing="0">
							<tr>
								<td align="center">
						<emphasis role="bold">Element</emphasis></td>
								<td align="center">
						<emphasis role="bold">Graphical Notation</emphasis></td>
								<td align="center">
						<emphasis role="bold">Textual Notation</emphasis></td>
							</tr>
							<tr>
								<td>Reference Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ReferencePort.png"/>
							</imageobject>
						</mediaobject></td>
								<td align="center">
						<emphasis>implicit</emphasis></td>
							</tr>
							<tr>
								<td>Conjugated Reference Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedReferencePort.png"/>
							</imageobject>
						</mediaobject></td>
								<td align="center">
						<emphasis>implicit</emphasis></td>
							</tr>
							<tr>
								<td>Replicated Reference Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ReplicatedReferencePort.png"/>
							</imageobject>
						</mediaobject></td>
								<td align="center">
						<emphasis>implicit</emphasis></td>
							</tr>
							<tr>
								<td>Conjugated Replicated Reference Port</td>
								<td align="center">
						<mediaobject>
							<imageobject>
								<imagedata fileref="images\040-ConjugatedReplicatedReferencePort.png"/>
							</imageobject>
						</mediaobject></td>
								<td align="center">
						<emphasis>implicit</emphasis></td>
							</tr>
</table>
					</para>
				</section>
			</section>
		</section>
		<section id="DataClass">
			<title>DataClass</title>
			<section id="Description4">
				<title>Description</title>
				<para>The DataClass enables the modeling of hierarchical complex datatypes and operations on them. The DataClass is the equivalent to a Class in languages like Java or C++, but has less features. The content of a DataClass can always be sent via message between actors (defined as message data in ProtocolClass).</para>
			</section>
			<section id="Notation4">
				<title>Notation</title>
				<para>Example: DataClass using PrimitiveTypes</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-DataClass1.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>Example: DataClass using other DataClasses:</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-DataClass2.png"/>
						</imageobject>
					</mediaobject>
				</para>
			</section>
		</section>
		<section id="Layering2">
			<title>Layering</title>
			<section id="Description5">
				<title>Description</title>
				<para>In addition to the Actor containment hierarchies, Layering provides another method to hierarchically structure a software system. Layering and actor hierarchies with port to port connections can be mixed on every level of granularity.</para>
				<orderedlist>
					<listitem>
						<para>an ActorClass can define a Service Provision Point (SPP) to publish a specific service, defined by a ProtocolClass</para>
					</listitem>
					<listitem>
						<para>an ActorClass can define a Service Access Point (SAP) if it needs a service, defined by a ProtocolClass</para>
					</listitem>
					<listitem>
						<para>for a given Actor hierarchy, a LayerConnection defines which SAP will be satisfied by (connected to) which SPP</para>
					</listitem>
				</orderedlist>
			</section>
			<section id="Notation5">
				<title>Notation</title>
				<para><table title="Title" frame="box" border="2" cellpadding="3" cellspacing="0">
						<tr>
							<td align="center">
					<emphasis role="bold">Description</emphasis></td>
							<td align="center">
					<emphasis role="bold">Graphical Notation</emphasis></td>
							<td align="center">
					<emphasis role="bold">Textual Notation</emphasis></td>
						</tr>
						<tr>
							<td>The Layer Connections in this model define which services are provided by the 
					<emphasis>ServiceLayer</emphasis>  (
					<emphasis>digitalIO</emphasis> and 
					<emphasis>timer</emphasis>)</td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-LayeringModel.png"/>
						</imageobject>
					</mediaobject></td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-LayeringModelTextual.png"/>
						</imageobject>
					</mediaobject></td>
						</tr>
						<tr>
							<td>The implementation of the services (SPPs) can be delegated to sub actors. In this case the actor 
					<emphasis>ServiceLayer</emphasis> relays (delegates) the implementation services 
					<emphasis>digitalIO</emphasis> and 
					<emphasis>timer</emphasis> to sub actors</td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-LayeringServiceLayer.png"/>
						</imageobject>
					</mediaobject></td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-LayeringServiceLayerTextual.png"/>
						</imageobject>
					</mediaobject></td>
						</tr>
						<tr>
							<td>Every Actor inside the 
					<emphasis>ApplicationLayer</emphasis> that contains an SAP with the same Protocol as 
					<emphasis>timer</emphasis> or 
					<emphasis>digitalIO</emphasis> will be connected to the specified SPP</td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-LayeringApplicationLayer.png"/>
						</imageobject>
					</mediaobject></td>
							<td>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images\040-LayeringApplicationLayerTextual.png"/>
						</imageobject>
					</mediaobject></td>
						</tr>
</table>
				</para>
			</section>
		</section>
		<section id="FiniteStateMachines">
			<title>Finite State Machines</title>
			<section id="Description6">
				<title>Description</title>
				<para>Definition from 
					<ulink url="http://en.wikipedia.org/wiki/Finite-state_machine">Wikipedia</ulink>:
				</para>
				<blockquote>
					<para>
						A finite-state machine (FSM) or finite-state automaton (plural: automata), or simply a state machine, is a mathematical model used to design computer programs and digital logic circuits. It is conceived as an abstract machine that can be in one of a finite number of states. The machine is in only one state at a time; the state it is in at any given time is called the current state. It can change from one state to another when initiated by a triggering event or condition, this is called a transition. A particular FSM is defined by a list of the possible states it can transition to from each state, and the triggering condition for each transition.</para>
				</blockquote>
				<para>In ROOM each actor class can implement its behavior using a state machine. Events occurring at the end ports of an actor will be forwarded to and processed by the state machine. Events possibly trigger state transitions.</para>
			</section>
			<section id="Motivation4">
				<title>Motivation</title>
				<para>For event driven systems a finite state machine is ideal for processing the stream of events. Typically during processing new events are produced which are sent to peer actors.</para>
				<para>We distinguish flat and hierarchical state machines.</para>
			</section>
			<section id="Notation6">
				<title>Notation</title>
				<section id="FlatFiniteStateMachine">
					<title>Flat Finite State Machine</title>
					<para>The simpler flat finite state machines are composed of the following elements:</para>
					<para><table title="Title" frame="box" border="2" cellpadding="3" cellspacing="0">
							<tr>
								<td align="center">
						<emphasis role="bold">Description</emphasis></td>
								<td align="center">
						<emphasis role="bold">Graphical Notation</emphasis></td>
								<td align="center">
						<emphasis role="bold">Textual Notation</emphasis></td>
							</tr>
							<tr>
								<td>State</td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-State.jpg"/>
							</imageobject>
						</mediaobject></td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-StateTextual.jpg"/>
							</imageobject>
						</mediaobject></td>
							</tr>
							<tr>
								<td>InitialPoint</td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-InitialPoint.jpg"/>
							</imageobject>
						</mediaobject></td>
								<td>
						<emphasis>implicit</emphasis></td>
							</tr>
							<tr>
								<td>TransitionPoint</td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-TransitionPoint.jpg"/>
							</imageobject>
						</mediaobject></td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-TransitionPointTextual.jpg"/>
							</imageobject>
						</mediaobject></td>
							</tr>
							<tr>
								<td>ChoicePoint</td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-ChoicePoint.jpg"/>
							</imageobject>
						</mediaobject></td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-ChoicePointTextual.jpg"/>
							</imageobject>
						</mediaobject></td>
							</tr>
							<tr>
								<td>Initial Transition</td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-InitialTransition.jpg"/>
							</imageobject>
						</mediaobject></td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-InitialTransitionTextual.jpg"/>
							</imageobject>
						</mediaobject></td>
							</tr>
							<tr>
								<td>Triggered Transition</td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-TriggeredTransition.jpg"/>
							</imageobject>
						</mediaobject></td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-TriggeredTransitionTextual.jpg"/>
							</imageobject>
						</mediaobject></td>
							</tr>
</table>
					</para>
				</section>
				<section id="HierarchicalFiniteStateMachine">
					<title>Hierarchical Finite State Machine</title>
					<para>The hierarchical finite state machine adds the notion of a sub state machine nested in a state.
						A few modeling elements are added to the set listed above:</para>
					<para><table title="Title" frame="box" border="2" cellpadding="3" cellspacing="0">
							<tr>
								<td align="center">
						<emphasis role="bold">Description</emphasis></td>
								<td align="center">
						<emphasis role="bold">Graphical Notation</emphasis></td>
								<td align="center">
						<emphasis role="bold">Textual Notation</emphasis></td>
							</tr>
							<tr>
								<td>State with sub state machine</td>
								<td>Parent State
								
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-StateWithSubFSM.jpg"/>
							</imageobject>
						</mediaobject>
								Sub state machine
								
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-SubFSM.jpg"/>
							</imageobject>
						</mediaobject></td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-StateWithSubFSMTextual.jpg"/>
							</imageobject>
						</mediaobject></td>
							</tr>
							<tr>
								<td>Entry Point</td>
								<td>In sub state machine
								
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-EntryPoint.jpg"/>
							</imageobject>
						</mediaobject>
								On parent state
								
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-EntryPointRef.jpg"/>
							</imageobject>
						</mediaobject></td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-EntryPointTextual.jpg"/>
							</imageobject>
						</mediaobject></td>
							</tr>
							<tr>
								<td>Exit Point</td>
								<td>In sub state machine
								
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-ExitPoint.jpg"/>
							</imageobject>
						</mediaobject>
								On parent state
								
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-ExitPointRef.jpg"/>
							</imageobject>
						</mediaobject></td>
								<td>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-ExitPointTextual.jpg"/>
							</imageobject>
						</mediaobject></td>
							</tr>
</table>
					</para>
				</section>
			</section>
			<section id="Examples">
				<title>Examples</title>
				<section id="Exampleofaflatfinitestatemachine">
					<title>Example of a flat finite state machine:</title>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-FlatFSM.jpg"/>
							</imageobject>
						</mediaobject>
					</para>
				</section>
				<section id="Exampleofahierarchicalfinitestatemachine">
					<title>Example of a hierarchical finite state machine:</title>
					<para>Top level

						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-HierarchicalFSMTop.jpg"/>
							</imageobject>
						</mediaobject>
					</para>
					<para>Sub state machine of Initializing

						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-HierarchicalFSMInitializing.jpg"/>
							</imageobject>
						</mediaobject>
					</para>
					<para>Sub state machine of Running

						<mediaobject>
							<imageobject>
								<imagedata fileref="images/040-HierarchicalFSMRunning.jpg"/>
							</imageobject>
						</mediaobject>
					</para>
				</section>
			</section>
		</section>
	</chapter>
</book>