<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<title>eTrice Documentation</title>

<link rel="stylesheet" type="text/css" href="css/book.css"/>
<link rel="stylesheet" type="text/css" href="css/custom-common.css"/>

</head>
<body>



	

<h1><a href="#dave-etrice-toolchain-tutorial" name="dave-etrice-toolchain-tutorial"></a>DAVE-eTrice Toolchain Tutorial</h1>
<h2><a href="#introduction" name="introduction"></a>Introduction</h2>
<p>As you already know, eTrice is a ROOM-Tool that provides a high level modeling language for embedded systems. It is perfectly suited for event driven, real time systems. However, each embedded SW relies on an underlying HW, with components like digital I/Os, Sensors, ADCs, DACs, PWMs and so on to connect the real world. Therefore some driver SW is required to control all this HW components and to provide easy access for the higher level SW. To develop the HW-drivers as well as your application logic without changing the development environment, you need a tool chain that provides both, driver development and high level application development. For Infineon’s XMC™ ARM Cortex M0/M4 devices special support is provided to combine the DAVE™ tool for driver development with eTrice for application development. This tutorials will guide you through the first steps.</p>
<p>The tutorials relies on the XMC4700 Relax Lite Kit. As a precondition you should be familiar with DAVE™. It is very easy to adapt the tutorials to any other development board or to your own HW. </p>
<h2><a href="#getting-started-without-operating-system" name="getting-started-without-operating-system"></a>Getting Started without Operating System</h2>
<p>Within this tutorial you will perform the following steps:</p>
<ul>
  <li>create a DAVE CE™ basic model</li>
  <li>run the <em>New Set of eTrice Models</em> wizard</li>
  <li>create a simple blinky model</li>
  <li>generate, build and run the application</li>
  <li>optionally extend the blinky state machine and create a button controller to switch blinky on and off</li>
</ul>
<h3><a href="#step-1-" name="step-1-"></a>Step 1:</h3>
<p>As a starting point you should create a DAVE CE™ project for the target HW. Let’s call the project <em>BlinkyTutorial_RelaxKit4700_ST</em>, where <em>ST</em> stands for <em>Single Threaded</em>. The following APPs should be included:</p>
<ul>
  <li>SYSTIMER</li>
  <li>2 * DIGITAL_IO configured as outputs for the two LEDs.</li>
  <li>2 * DIGITAL_IO configured as inputs for the buttons.</li>
</ul>
<p>Hint: For the basic setup and to reduce the initial effort it is sufficient to create just</p>
<ul>
  <li>SYSTMIER</li>
  <li>1 * DIGITAL_IO configured as output for LED1 “LED1_P5_9”</li>
</ul>
<p>For STEP 5 and following you will need the full set of IO Pins.</p>
<p>The resulting project should look like this:</p>
<p><img src="images/400-DaveBasicProject.png" alt="image"></p>
<p>Make sure that the pins are configured correctly. It is a good idea to run it on the real HW to verify that everything is configured correctly. To setup a debug configuration see also <em>Step 4</em>.</p>
<h3><a href="#step-2-" name="step-2-"></a>Step 2:</h3>
<p>Run the *New Set of new eTrice Models" wizard.</p>
<p>To keep an adequate project structure you should create a new folder called <em>model</em>.<br><em>right click on the project -&gt; new -&gt; other</em></p>
<p><img src="images/400-DaveCreateFolder.png" alt="image"></p>
<p>Name the folder <em>model</em></p>
<p>Run the *New Set of eTrice Models" wizard.<br><em>Right click on the newly created folder -&gt; new -&gt; other</em><br>Select <em>eTrice/C/New Set of eTrice Models</em></p>
<p><img src="images/400-RunNewModelWizzard.png" alt="image"></p>
<p>Click <em>Next</em><br>Name the model <em>BlinkyTutorial</em></p>
<p>Click <em>Next</em><br>Enable the check box <em>Copy C-Runtime into project</em><br>Select <em>ST_XMC_Dave</em> as active platform.<br>Rename the eTrice entry function to <em>etStart</em>.</p>
<p><img src="images/400-SelectRuntime.png" alt="image"></p>
<p>Click <em>Finish</em></p>
<p>The resulting project should look like this:</p>
<p><img src="images/400-FirstEtriceModel.png" alt="image"></p>
<p>The following files/folders should have been created:</p>
<ul>
  <li><em>etrice_c_runtime</em></li>
  <li><em>etrice_c_modellib</em> within the <em>model</em> folder</li>
  <li><em>BlinkyTutorial.etmap</em></li>
  <li><em>BlinkyTutorial.etphys</em></li>
  <li><em>BlinkyTutorial.room</em></li>
  <li><em>gen_BlinkyTutorial.launch</em></li>
  <li><em>run_BlinkyTutorial.launch</em></li>
</ul>
<p>Now you have successfully created your first eTrice model. To complete the step you should generate C-Code out of the model.<br>Right click on <em>gen_BlinkyTutorial.launch -&gt; Run As -&gt; gen_BlinkyTutorial</em></p>
<p><img src="images/400-RunGenerator.png" alt="image"></p>
<p>Make sure that your outline view is activated. <em>Window -&gt; Show View -&gt; Outline</em>.</p>
<p>Once the code is generated you should build the application. After the first build two additional folders are created:<br>- <em>src-gen</em><br>- <em>src-gen-info</em></p>
<p>To start the model, you should call etStart from the DAVE™ generated main function.</p>
<p><img src="images/400-DaveMain.png" alt="image"></p>
<h3><a href="#step-3-" name="step-3-"></a>Step 3:</h3>
<p>Now everything is arranged to start modeling with eTrice. </p>
<p>One of the benefits of a modeling language like ROOM is, that it is very easy to build model based libraries either domain specific or for common use. Some common services are part of the eTrice distribution so that we can use it out of the box. The first application we want to create is a blinking LED, therefore we use the eTrice timing service. We just have to import the libraries.<br>Open the <em>BlinkyTutorial.room</em> and add the two import statements:</p>
<pre><code class="room customHighlighted"><span class="keyword">RoomModel</span> BlinkyTutorial {

    <span class="keyword">import</span> room.basic.types.* <span class="keyword">from</span> <span class="string">"etrice_c_modellib/Types.room"</span>

    <span class="keyword">import</span> room.basic.service.timing.* <span class="keyword">from</span> <span class="string">"etrice_c_modellib/TimingService.room"</span>

    <span class="keyword">LogicalSystem</span> BlinkyTutorial {
        <span class="keyword">SubSystemRef</span> main: MainSubSystem
    }
</code></pre>
<p>Now we can use the timing service within our application. We just need to connect the application and the service.<br>In the outline view right click the SubSystem and open the structure editor:</p>
<p><img src="images/400-OpenStructureEditorSubsystem.png" alt="image"></p>
<p>Drag and Drop an <em>ActorRef</em> into the subsystem.</p>
<p><img src="images/400-AddActorRefDragAndDrop.png" alt="image"></p>
<p>Select the ActorClass <em>ATimingService</em> and name the reference <em>timing</em>.</p>
<p>Draw a connection from <em>application</em> to <em>timing</em>.</p>
<p><img src="images/400-SubSystemWithTimingService.png" alt="image"></p>
<p>Now we can use the timing service inside our application. We will see it later on. Our application should consist of two new actors and a protocol for communication. One actor should represent the HW, the other actor should implement the blinky behavior which is in fact very simple.Creating new elements like actors or protocols are done in the .room file. </p>
<p>Open <em>BlinkyTutorial.room</em> and create a new Actor called AHWAbstraction by adding the following text:</p>
<pre><code class="room customHighlighted"><span class="keyword">ActorClass</span> AHWAbstraction {
    <span class="keyword">Structure</span> {
        <span class="keyword">usercode1</span> <span class="string">'''
            #include "Dave.h"
        '''</span>
    }
}
</code></pre>
<p>Check the outline view to verify that the actor was created.</p>
<p>Create a new protocol class by adding the following:</p>
<pre><code class="room customHighlighted"><span class="keyword">ProtocolClass</span> POnOff {
    <span class="keyword">incoming</span> {
        <span class="keyword">Message</span> on()
        <span class="keyword">Message</span> off()
    }
    <span class="keyword">outgoing</span> { }
}
</code></pre>
<p>Check the outline view to see that the protocol was created.</p>
<p>The <em>AHWAbstarction</em> should be controlled via the <em>POnOff</em> protocol. That means, whenever we send an <em>on</em> message, the LED should be switched on, whenever we send an <em>off</em> message, the LED should be switched off. Therefore we add an <em>Interface Port</em> from type <em>POnOff</em> to the <em>AHWAbstraction</em> actor.<br>In the outline view right click on <em>AHWAbstraction -&gt; Edit Structure</em> to open the structure editor of the actor. </p>
<p><img src="images/400-OpenStructureEditor.png" alt="image"></p>
<p>Within the structure editor create a new <em>Interface Port</em></p>
<p><img src="images/400-CreateInterfacePort.png" alt="image"></p>
<p>Name the port <em>LED1</em>, the port must be from the newly created protocol type <em>POnOff</em>.</p>
<p><img src="images/400-NewInterfacePort.png" alt="image"></p>
<p>Now we need a state machine which is able to handle the defined messages and to perform the required actions.<br>Create the state machine of the <em>AHWAbstraction</em> actor:<br>Inside the structure editor, right click on the actor.<br>Select <em>Open Class Behavior</em></p>
<p><img src="images/400-OpenClassBehaviour.png" alt="image"></p>
<p>The resulting FSM should look like this:</p>
<p><img src="images/400-HWActorFSM.png" alt="image"></p>
<p>It is just one state with two transitions. Each transition carries one action to switch a digital IO. Here we have the interface to the DAVE™ generated code. The transitions will be triggered from the <em>POnOff</em> protocol.</p>
<p>The resulting textual representation should look like this:</p>
<pre><code class="room customHighlighted"><span class="keyword">ActorClass</span> AHWAbstraction {
    <span class="keyword">Interface</span> {
        <span class="keyword">Port</span> LED1: POnOff
    }
    <span class="keyword">Structure</span> {
        <span class="keyword">usercode1</span> <span class="string">'''
            #include "Dave.h"
        '''</span>
        <span class="keyword">external</span> <span class="keyword">Port</span> LED1
    }
    <span class="keyword">Behavior</span> {
        <span class="keyword">StateMachine</span> {
            <span class="keyword">State</span> state0
            <span class="keyword">Transition</span> init: <span class="keyword">initial</span> -&gt; state0
            <span class="keyword">Transition</span> tr0: state0 -&gt; state0 {
                <span class="keyword">triggers</span> {
                    &lt;on: LED1&gt;
                }
                <span class="keyword">action</span> <span class="string">'''
                    DIGITAL_IO_SetOutputHigh(&amp;LED1_P5_9);
                '''</span>
            }
            <span class="keyword">Transition</span> tr1: state0 -&gt; state0 {
                <span class="keyword">triggers</span> {
                    &lt;off: LED1&gt;
                }
                <span class="keyword">action</span> <span class="string">'''
                    DIGITAL_IO_SetOutputLow(&amp;LED1_P5_9);
                '''</span>
            }
        }
    }
}
</code></pre>
<p>Please notice that the <em>off</em> message switches the LED off and vice versa.</p>
<p>To implement the behavior of the <em>ABlinky</em> actor, we just need to create a new actor, add a port for communication and implement the behavior by adding a state machine with appropriate triggers and actions.<br>Create an ActorClass called <em>ABlinky</em> by adding the following text:</p>
<pre><code class="room customHighlighted"><span class="keyword">ActorClass</span> ABlinky {
    <span class="keyword">Structure</span> {
        <span class="keyword">SAP</span> timer: PTimer
    }
}
</code></pre>
<p>Recognize that the structure contains a Service Access Point (SAP) which allows you to use the timing service.</p>
<p>Now, add an additional interface port called <em>out</em> as you did it before and make it a <em>conjugated</em> port. We need to declare the type of the interface (protocol) just once. To define the direction (in or out messages) we need one <em>normal</em> port (*AHWAbstraction*) and one <em>conjugated</em> port (*ABlinky*).</p>
<p>To define the behavior, create the following state machine:</p>
<p><img src="images/400-BlinkyFSM.png" alt="image"></p>
<p>On the initial transition the timer will be started. On the transitions between the states a message <em>on</em> or <em>off</em> will be sent via the <em>out</em> port.</p>
<p>The resulting textual representation looks like this:</p>
<pre><code class="room customHighlighted"><span class="keyword">ActorClass</span> ABlinky {
    <span class="keyword">Interface</span> {
        <span class="keyword">conjugated</span> <span class="keyword">Port</span> ^out: POnOff
    }
    <span class="keyword">Structure</span> {
        <span class="keyword">SAP</span> timer: PTimer
        <span class="keyword">external</span> <span class="keyword">Port</span> ^<span class="keyword">out</span>
    }
    <span class="keyword">Behavior</span> {
        <span class="keyword">StateMachine</span> {
            <span class="keyword">State</span> state0
            <span class="keyword">State</span> state1
            <span class="keyword">Transition</span> init: <span class="keyword">initial</span> -&gt; state0 {
                <span class="keyword">action</span> <span class="string">'''
                    timer.startTimer(300);
                '''</span>
            }
            <span class="keyword">Transition</span> tr0: state0 -&gt; state1 {
                <span class="keyword">triggers</span> {
                    &lt;timeout: timer&gt;
                }
                <span class="keyword">action</span> <span class="string">'''
                    out.on();
                '''</span>
            }
            <span class="keyword">Transition</span> tr1: state1 -&gt; state0 {
                <span class="keyword">triggers</span> {
                    &lt;timeout: timer&gt;
                }
                <span class="keyword">action</span> <span class="string">'''
                    out.off();
                '''</span>
            }
        }
    }
}
</code></pre>
<p>The last step is to build up the application containing the actor classes <em>ABlinky</em> and <em>AHWAbstraction</em>.<br>In the outline view right click to <em>application -&gt; Edit Structure</em><br>Add <em>ActorRef</em> blinky of ActorClass <em>ABlinky</em>. The same for the <em>AHWAbstraction</em>.<br>Draw the binding between the ports. The resulting system should look like this:</p>
<p><img src="images/400-ApplicationABlinkyHW.png" alt="image"></p>
<p>The resulting representation of the complete model should look like this:</p>
<pre><code class="room customHighlighted"><span class="keyword">RoomModel</span> BlinkyTutorial {

    <span class="keyword">import</span> room.basic.types.* <span class="keyword">from</span> <span class="string">"etrice_c_modellib/Types.room"</span>

    <span class="keyword">import</span> room.basic.service.timing.* <span class="keyword">from</span> <span class="string">"etrice_c_modellib/TimingService.room"</span>

    <span class="keyword">LogicalSystem</span> BlinkyTutorial {
        <span class="keyword">SubSystemRef</span> main: MainSubSystem
    }

    <span class="keyword">SubSystemClass</span> MainSubSystem {
        <span class="keyword">ActorRef</span> appl: Application
        <span class="keyword">LogicalThread</span> defaultThread
        <span class="keyword">LayerConnection</span> <span class="keyword">ref</span> appl <span class="keyword">satisfied_by</span> timing.timer
        <span class="keyword">ActorRef</span> timing: ATimingService
    }

    <span class="keyword">ActorClass</span> ABlinky {
        <span class="keyword">Interface</span> {
            <span class="keyword">conjugated</span> <span class="keyword">Port</span> ^out: POnOff
        }
        <span class="keyword">Structure</span> {
            <span class="keyword">SAP</span> timer: PTimer
            <span class="keyword">external</span> <span class="keyword">Port</span> ^<span class="keyword">out</span>
        }
        <span class="keyword">Behavior</span> {
            <span class="keyword">StateMachine</span> {
                <span class="keyword">State</span> state0
                <span class="keyword">State</span> state1
                <span class="keyword">Transition</span> init: <span class="keyword">initial</span> -&gt; state0 {
                    <span class="keyword">action</span> <span class="string">'''
                        timer.startTimer(300);
                    '''</span>
                }
                <span class="keyword">Transition</span> tr0: state0 -&gt; state1 {
                    <span class="keyword">triggers</span> {
                        &lt;timeout: timer&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        out.on();
                    '''</span>
                }
                <span class="keyword">Transition</span> tr1: state1 -&gt; state0 {
                    <span class="keyword">triggers</span> {
                        &lt;timeout: timer&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        out.off();
                    '''</span>
                }
            }
        }
    }

    <span class="keyword">ActorClass</span> AHWAbstraction {
        <span class="keyword">Interface</span> {
            <span class="keyword">Port</span> LED1: POnOff
        }
        <span class="keyword">Structure</span> {
            <span class="keyword">usercode1</span> <span class="string">'''
                #include "Dave.h"
            '''</span>
            <span class="keyword">external</span> <span class="keyword">Port</span> LED1
        }
        <span class="keyword">Behavior</span> {
            <span class="keyword">StateMachine</span> {
                <span class="keyword">State</span> state0
                <span class="keyword">Transition</span> init: <span class="keyword">initial</span> -&gt; state0
                <span class="keyword">Transition</span> tr0: state0 -&gt; state0 {
                    <span class="keyword">triggers</span> {
                        &lt;on: LED1&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        DIGITAL_IO_SetOutputHigh(&amp;LED1_P5_9);
                    '''</span>
                }
                <span class="keyword">Transition</span> tr1: state0 -&gt; state0 {
                    <span class="keyword">triggers</span> {
                        &lt;off: LED1&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        DIGITAL_IO_SetOutputLow(&amp;LED1_P5_9);
                    '''</span>
                }
            }
        }
    }

    <span class="keyword">ProtocolClass</span> POnOff {
        <span class="keyword">incoming</span> {
            <span class="keyword">Message</span> on()
            <span class="keyword">Message</span> off()
        }
        <span class="keyword">outgoing</span> { }
    }

    <span class="keyword">ActorClass</span> Application {
        <span class="keyword">Structure</span> {
            <span class="keyword">ActorRef</span> hw: AHWAbstraction
            <span class="keyword">ActorRef</span> blinky: ABlinky
            <span class="keyword">Binding</span> blinky.^<span class="keyword">out</span> <span class="keyword">and</span> hw.LED1
        }
    }
}
</code></pre>
<p>The model is finished know.<br>If you missed some steps in between, you also can copy the complete model to your .room file.</p>
<h3><a href="#step-4-" name="step-4-"></a>Step 4:</h3>
<p>Generate, build and run the application.</p>
<p>Generate the application as you did it in step2 (Right click on <em>gen_BlinkyTutorial.launch -&gt; Run As -&gt; gen_BlinkyTutorial</em>). Once the code is generated, you are back in your normal C-Development and you can compile and debug your code as usual. Build the generated code and download it to the target as you normally do it.</p>
<p>Right click on the project -&gt; Build Project<br>Right click on the project -&gt; Debug As -&gt; DAVE C/C++ Application</p>
<p>The LED1 should blink in a 300ms interval.</p>
<p>Congratulations, you have built you first eTrice Application on top of the Dave™ drivers!!!</p>
<p>Hint: If you start the debugger the first time (for a new project) it might be necessary to setup the debug configuration:</p>
<p>Right click on the project -&gt; Debug As -&gt; Debug Configurations…</p>
<p><img src="images/400-CreateDebugConfig.png" alt="image"></p>
<p>Select the <em>GDB Segger J_link Debugging</em> and press the <em>New</em> button to create a new debug configuration.<br><img src="images/400-SeggerDebugConfig.png" alt="image"></p>
<p>Keep all default settings and press <em>Debug</em><br><img src="images/400-SeggerDebugConfigTutorial.png" alt="image"></p>
<p>Once the debug configuration is created you can start the debugger either with:<br>Right click on the project -&gt; Debug As -&gt; DAVE C/C++ Application<br>or via the Debug Button: </p>
<p><img src="images/400-StartDebugWithIcon.png" alt="image"></p>
<h3><a href="#step-5-" name="step-5-"></a>Step 5:</h3>
<p>As further exercise you can extend the model in the following way:</p>
<ul>
  <li>add a control port to <em>ABlinky</em> from type <em>POnOff</em></li>
  <li>extend the behavior so that you can switch off and on the blink light</li>
  <li>create a button controller, that recognizes button presses</li>
  <li>do it for both buttons and LEDs</li>
  <li>put everything together to create the complete application</li>
</ul>
<p>There are many solutions. Here is one of the possible solutions:</p>
<p><img src="images/400-DualBlinkyStruct.png" alt="image"></p>
<p>and the complete textual model:</p>
<pre><code class="room customHighlighted"><span class="keyword">RoomModel</span> BlinkyTutorial {

    <span class="keyword">import</span> room.basic.types.* <span class="keyword">from</span> <span class="string">"etrice_c_modellib/Types.room"</span>

    <span class="keyword">import</span> room.basic.service.timing.* <span class="keyword">from</span> <span class="string">"etrice_c_modellib/TimingService.room"</span>

    <span class="keyword">LogicalSystem</span> BlinkyTutorial {
        <span class="keyword">SubSystemRef</span> main: MainSubSystem
    }

    <span class="keyword">SubSystemClass</span> MainSubSystem {
        <span class="keyword">ActorRef</span> appl: Application
        <span class="keyword">LogicalThread</span> defaultThread
        <span class="keyword">LayerConnection</span> <span class="keyword">ref</span> appl <span class="keyword">satisfied_by</span> timing.timer
        <span class="keyword">ActorRef</span> timing: ATimingService
    }

    <span class="keyword">ActorClass</span> ABlinky {
        <span class="keyword">Interface</span> {
            <span class="keyword">conjugated</span> <span class="keyword">Port</span> ^out: POnOff
            <span class="keyword">Port</span> ctrl: POnOff
        }
        <span class="keyword">Structure</span> {
            <span class="keyword">SAP</span> timer: PTimer
            <span class="keyword">external</span> <span class="keyword">Port</span> ^<span class="keyword">out</span>
        <span class="keyword">external</span> <span class="keyword">Port</span> ctrl
        }
        <span class="keyword">Behavior</span> {
            <span class="keyword">StateMachine</span> {
                <span class="keyword">State</span> off
                
                <span class="keyword">State</span> blinking {
                    <span class="keyword">subgraph</span> {
                        <span class="keyword">State</span> on {
                            <span class="keyword">entry</span> <span class="string">'''
                                out.on();
                            '''</span>
                        }
                        <span class="keyword">State</span> off {
                            <span class="keyword">entry</span> <span class="string">'''
                                out.off();
                            '''</span>
                        }
                        <span class="keyword">EntryPoint</span> tp0
                        <span class="keyword">Transition</span> tr0: on -&gt; off {
                            <span class="keyword">triggers</span> {
                                &lt;timeout: timer&gt;
                            }
                        }
                        <span class="keyword">Transition</span> tr1: off -&gt; on {
                            <span class="keyword">triggers</span> {
                                &lt;timeout: timer&gt;
                            }
                        }
                        <span class="keyword">Transition</span> tr2: <span class="keyword">my</span> tp0 -&gt; on {
                            <span class="keyword">action</span> <span class="string">'''
                                timer.startTimer(300);
                            '''</span>
                        }
                    }
                }
                <span class="keyword">Transition</span> init: <span class="keyword">initial</span> -&gt; off {
                    }
                
                <span class="keyword">Transition</span> tr0: off -&gt; tp0 <span class="keyword">of</span> blinking {
                    <span class="keyword">triggers</span> {
                        &lt;on: ctrl&gt;
                    }
                }
            <span class="keyword">Transition</span> tr1: blinking -&gt; off {
                    <span class="keyword">triggers</span> {
                        &lt;off: ctrl&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        timer.kill();
                        out.off();
                    '''</span>
                }
            }
        }
    }

    <span class="keyword">ActorClass</span> AHWAbstraction {
        <span class="keyword">Interface</span> {
            <span class="keyword">Port</span> LED1: POnOff
            <span class="keyword">Port</span> LED2: POnOff
            <span class="keyword">conjugated</span> <span class="keyword">Port</span> BUTTON1: POnOff
            <span class="keyword">conjugated</span> <span class="keyword">Port</span> BUTTON2: POnOff
        }
        <span class="keyword">Structure</span> {
            <span class="keyword">usercode1</span> <span class="string">'''
                #include "Dave.h"
            '''</span>
            <span class="keyword">SAP</span> timer: PTimer
            <span class="keyword">external</span> <span class="keyword">Port</span> LED1
            <span class="keyword">external</span> <span class="keyword">Port</span> LED2
            <span class="keyword">external</span> <span class="keyword">Port</span> BUTTON1
            <span class="keyword">external</span> <span class="keyword">Port</span> BUTTON2
            <span class="keyword">Attribute</span> b1Status: int8
            <span class="keyword">Attribute</span> b2Status: int8
        }
        <span class="keyword">Behavior</span> {
            <span class="keyword">StateMachine</span> {
                <span class="keyword">State</span> state0
                <span class="keyword">Transition</span> init: <span class="keyword">initial</span> -&gt; state0 {
                    <span class="keyword">action</span> <span class="string">'''
                        timer.startTimer(50);
                    '''</span>
                }
                <span class="keyword">Transition</span> tr0: state0 -&gt; state0 {
                    <span class="keyword">triggers</span> {
                        &lt;on: LED1&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        DIGITAL_IO_SetOutputHigh(&amp;LED1_P5_9);
                    '''</span>
                }
                <span class="keyword">Transition</span> tr1: state0 -&gt; state0 {
                    <span class="keyword">triggers</span> {
                        &lt;off: LED1&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        DIGITAL_IO_SetOutputLow(&amp;LED1_P5_9);
                    '''</span>
                }
                <span class="keyword">Transition</span> tr2: state0 -&gt; state0 {
                    <span class="keyword">triggers</span> {
                        &lt;on: LED2&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        DIGITAL_IO_SetOutputHigh(&amp;LED2_P5_8);
                    '''</span>
                }
                <span class="keyword">Transition</span> tr3: state0 -&gt; state0 {
                    <span class="keyword">triggers</span> {
                        &lt;off: LED2&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        DIGITAL_IO_SetOutputLow(&amp;LED2_P5_8);
                    '''</span>
                }
                <span class="keyword">Transition</span> tr4: state0 -&gt; state0 {
                    <span class="keyword">triggers</span> {
                        &lt;timeout: timer&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        if (DIGITAL_IO_GetInput(&amp;BUTTON1_P15_13) == 0) {
                            if (b1Status == 0) {
                                // input changed
                                b1Status = 1;
                                BUTTON1.on();
                            }
                        }
                        else {
                            if (b1Status == 1) {
                                // input changed
                                b1Status = 0;
                            	BUTTON1.off();
                            }
                        }
                        
                        if (DIGITAL_IO_GetInput(&amp;BUTTON2_P15_12) == 0) {
                                if (b2Status == 0){
                                // input changed
                                b2Status = 1;
                                BUTTON2.on();
                            }
                        }
                        else {
                            if (b2Status == 1) {
                                // input changed
                                b2Status = 0;
                                BUTTON2.off();
                            }
                        }
                    '''</span>
                }
            }
        }
    }

    <span class="keyword">ProtocolClass</span> POnOff {
        <span class="keyword">incoming</span> {
            <span class="keyword">Message</span> on()
            <span class="keyword">Message</span> off()
        }
        <span class="keyword">outgoing</span> { }
    }
    <span class="keyword">ActorClass</span> AButtonController {
        <span class="keyword">Interface</span> {
            <span class="keyword">Port</span> ctrl: POnOff
            <span class="keyword">conjugated</span> <span class="keyword">Port</span> ^out: POnOff
        }
        <span class="keyword">Structure</span> {
            <span class="keyword">external</span> <span class="keyword">Port</span> ctrl
            <span class="keyword">external</span> <span class="keyword">Port</span> ^<span class="keyword">out</span>
        }
    <span class="keyword">Behavior</span> {
            <span class="keyword">StateMachine</span> {
                <span class="keyword">State</span> off
                <span class="keyword">State</span> on
                <span class="keyword">Transition</span> init: <span class="keyword">initial</span> -&gt; off
                <span class="keyword">Transition</span> tr0: off -&gt; on {
                    <span class="keyword">triggers</span> {
                        &lt;on: ctrl&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        out.on();
                    '''</span>
                }
                <span class="keyword">Transition</span> tr1: on -&gt; off {
                    <span class="keyword">triggers</span> {
                        &lt;on: ctrl&gt;
                    }
                    <span class="keyword">action</span> <span class="string">'''
                        out.off();
                    '''</span>
                }
            }
        }
    }
    <span class="keyword">ActorClass</span> Application {
        <span class="keyword">Structure</span> {
            <span class="keyword">ActorRef</span> hw: AHWAbstraction
            <span class="keyword">ActorRef</span> blinky1: ABlinky
            <span class="keyword">Binding</span> blinky1.^<span class="keyword">out</span> <span class="keyword">and</span> hw.LED1
        <span class="keyword">Binding</span> blinky2.^<span class="keyword">out</span> <span class="keyword">and</span> hw.LED2
            <span class="keyword">ActorRef</span> blinky2: ABlinky
        <span class="keyword">Binding</span> hw.BUTTON1 <span class="keyword">and</span> button1.ctrl
            <span class="keyword">Binding</span> button2.ctrl <span class="keyword">and</span> hw.BUTTON2
            <span class="keyword">Binding</span> button2.^<span class="keyword">out</span> <span class="keyword">and</span> blinky2.ctrl
            <span class="keyword">Binding</span> blinky1.ctrl <span class="keyword">and</span> button1.^<span class="keyword">out</span>
            <span class="keyword">ActorRef</span> button1: AButtonController
            <span class="keyword">ActorRef</span> button2: AButtonController
        }
    }

}
</code></pre>
<p>In the tutorial we used the Systimer APP as timing base for the model. It is also possible to run the model without the Systimer APP. Please open <em>etrice-c-runtime/src/platforms/ST_XMC_Dave/etPlatform.h</em>. To work without Systimer APP you just need to undef <em>ET_USE_DAVE_SYSTIMER_APP</em>. In this case you have to remove the Systimer APP from the Dave™ model.</p>
<h2><a href="#getting-started-with-freertos" name="getting-started-with-freertos"></a>Getting Started with FreeRTOS</h2>
<p>To start with an operating system the steps are almost the same.</p>
<ul>
  <li>create the Dave™ project and add the FreeRTOS APP and all other required components</li>
  <li>run the "New Set of eTrice models* wizard and select the appropriate runtime library</li>
  <li>model your application (or make a copy from the <em>ST</em>-Tutorial)</li>
  <li>adapt the thread deployment to your needs</li>
</ul>
<h3><a href="#step-1-" name="step-1-"></a>Step 1:</h3>
<p>Create the Dave™ project and add the necessary components. For the <em>BlinkyTutorial</em> we need again two LEDs, two buttons and the FreeRTOS APP.</p>
<p><img src="images/500-DaveProjectFreeRTOS.png" alt="image"></p>
<p>Configure the FreeRTOS APP. Set the Tick rate to 1000.<br><img src="images/500-FreeRtosConfig1.png" alt="image"></p>
<p>Increase the heap size to 8192 bytes and enable <em>Use tick hook</em><br><img src="images/500-FreeRtosConfig2.png" alt="image"></p>
<p>Start the Dave™ code generator, compile and debug the application. Make sure that the Dave™ settings are complete.<br>Hint: The <em>vApplicationTickHook</em> is implemented in the eTrice runtime system. For this test you need to stub this function. </p>
<h3><a href="#step-2-" name="step-2-"></a>Step 2:</h3>
<p>Create a new folder called <em>model</em>, right click on the folder <em>New -&gt; Other</em> select <em>Other/eTrice/C/New Set of eTrice Models</em></p>
<p>Name the model <em>BlinkyTutorial</em>, enable <em>Copy C-runtime into project</em>, select <em>MT_XMC_Dave_FreeRTOS</em> and rename main to <em>etStart</em>.</p>
<p><img src="images/500-NewModelWizzardFreeRTOS.png" alt="image"></p>
<p>Click <em>Finish</em></p>
<p>Run the code generator as you did it in the ST-Tutorial. Compile your project.<br>Hint: Remove the <em>vApplicationTickHook</em> stub from step 1.</p>
<p>Open <em>main.c</em> and call <em>etStart</em> as you did it in the ST-Tutorial.</p>
<h3><a href="#step-3-" name="step-3-"></a>Step 3:</h3>
<p>From now on you can create your model or you can copy the <em>BlinkyTutorial.room</em> file from the ST-Tutorial to the new project.</p>
<p>Generate the code, compile and debug.</p>
<h3><a href="#step-4-" name="step-4-"></a>Step 4:</h3>
<p>In the ST-Tutorial you have created an application that runs without operating system. That means, everything runs in a single main loop. Now we have an underlying preemtive operating system and we can deploy SW-Components to different threads. With eTrice 3 simple steps are necessary:</p>
<ul>
  <li>create physical threads</li>
  <li>create logical threads and map actors to logical threads</li>
  <li>map logical threads to physical threads</li>
</ul>
<p>Physical thread creation must be done in <em>BlinkyTutorial.etphys</em>. Open the file, create 2 additional physical threads:</p>
<pre><code class="etphys customHighlighted"><span class="keyword">PhysicalModel</span> BlinkyTutorial {

    <span class="keyword">PhysicalSystem</span> PhysSys1 {
        <span class="keyword">NodeRef</span> nodeRef1 : NodeClass1
    }

    <span class="keyword">NodeClass</span> NodeClass1 {
        <span class="keyword">runtime</span> = RuntimeClass1
        <span class="keyword">priomin</span> = -10
        <span class="keyword">priomax</span> = 10
        <span class="keyword">DefaultThread</span> PhysicalThread1 {
            <span class="keyword">execmode</span> = <span class="keyword">mixed</span>
            <span class="keyword">interval</span> = 100ms
            <span class="keyword">prio</span> = 2
            <span class="keyword">stacksize</span> = 128
            <span class="keyword">msgblocksize</span> = 32
            <span class="keyword">msgpoolsize</span> = 10
        }
        <span class="keyword">Thread</span> HighPrioThread {
            <span class="keyword">execmode</span> = <span class="keyword">mixed</span>
            <span class="keyword">interval</span> = 10ms
            <span class="keyword">prio</span> = 3
            <span class="keyword">stacksize</span> = 128
            <span class="keyword">msgblocksize</span> = 32
            <span class="keyword">msgpoolsize</span> = 10
        }
        
        <span class="keyword">Thread</span> LowPrioThread {
            <span class="keyword">execmode</span> = <span class="keyword">mixed</span>
            <span class="keyword">interval</span> = 200ms
            <span class="keyword">prio</span> = 3
            <span class="keyword">stacksize</span> = 128
            <span class="keyword">msgblocksize</span> = 32
            <span class="keyword">msgpoolsize</span> = 10
        }
    }

    <span class="keyword">RuntimeClass</span> RuntimeClass1 {
        <span class="keyword">model</span> = <span class="keyword">multiThreaded</span>
    }
}
</code></pre>
<p>Adapt priorities and stack sizes to your needs. Keep in mind to reserve memory in the FREERTOS APP configuration.</p>
<p>Logical thread creation must be done in the logical model <em>BlinkyTutorial.room</em>. Open the file and add two threads and map actor instances to the newly created threads.</p>
<pre><code class="room customHighlighted"><span class="keyword">RoomModel</span> BlinkyTutorial {

    <span class="keyword">import</span> room.basic.types.* <span class="keyword">from</span> <span class="string">"etrice_c_modellib/Types.room"</span>

    <span class="keyword">import</span> room.basic.service.timing.* <span class="keyword">from</span> <span class="string">"etrice_c_modellib/TimingService.room"</span>

    <span class="keyword">LogicalSystem</span> BlinkyTutorial {
        <span class="keyword">SubSystemRef</span> main: MainSubSystem
    }

    <span class="keyword">SubSystemClass</span> MainSubSystem {
        <span class="keyword">ActorRef</span> appl: Application
        <span class="keyword">LogicalThread</span> defaultThread
        <span class="keyword">LogicalThread</span> highPrioThread
        <span class="keyword">LogicalThread</span> lowPrioThread
        <span class="keyword">LayerConnection</span> <span class="keyword">ref</span> appl <span class="keyword">satisfied_by</span> timing.timer
        <span class="keyword">ActorRef</span> timing: ATimingService
        <span class="keyword">ActorInstanceMapping</span> timing -&gt; highPrioThread
        <span class="keyword">ActorInstanceMapping</span> appl/blinky1-&gt;lowPrioThread
        <span class="keyword">ActorInstanceMapping</span> appl/button1-&gt;lowPrioThread
    }
</code></pre>
<p>We created three logical threads and deployed the timing service to the <em>highPrioThread</em>, <em>blinky1</em> and <em>button1</em> to the <em>lowPrioThread</em>. All other actors are automatically deployed to the default thread.<br>Please recognize that you deploy actor instances and not actor classes.</p>
<p>The last step is the mapping of the logical threads to physical threads. Open <em>BlinkyTutorial.etmap</em> and do your mapping:</p>
<pre><code class="etmap customHighlighted"><span class="keyword">MappingModel</span> BlinkyTutorial {
	<span class="keyword">import</span> BlinkyTutorial.* <span class="keyword">from</span> <span class="string">"BlinkyTutorial.room"</span>
	<span class="keyword">import</span> BlinkyTutorial.* <span class="keyword">from</span> <span class="string">"BlinkyTutorial.etphys"</span>
	<span class="keyword">Mapping</span> BlinkyTutorial -&gt; PhysSys1 {
		<span class="keyword">SubSystemMapping</span> main -&gt; nodeRef1 {
			<span class="keyword">ThreadMapping</span> defaultThread -&gt; PhysicalThread1
			<span class="keyword">ThreadMapping</span> highPrioThread -&gt; HighPrioThread
			<span class="keyword">ThreadMapping</span> lowPrioThread -&gt; LowPrioThread
		}
	}
}
</code></pre>
<p>Generate your code, compile and debug the application.<br>Have fun.</p>

</body>
</html>


