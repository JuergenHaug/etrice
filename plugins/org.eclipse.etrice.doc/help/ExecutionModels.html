<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Execution Models</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="eTrice User Guide">
<link rel="up" href="IntroductiontotheROOMLanguage.html" title="Introduction to the ROOM Language">
<link rel="prev" href="BasicConcepts.html" title="Basic Concepts">
<link rel="next" href="SettinguptheWorkspace.html" title="Setting up the Workspace">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Execution Models</h1>
<div class="section" title="Execution Models">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both">
<a name="ExecutionModels"></a>Execution Models</h2>
</div>
</div>
</div>
<p>Since from ROOM models executable code can be generated, it is important to define the way the actors are executed and communicate with each other. The combination of communication and execution is called the Execution Model.
				Currently the eTrice tooling only supports the 
				<span class="bold"><strong>message driven</strong></span> and parts of the 
				<span class="bold"><strong>data driven</strong></span> execution model. In future releases more execution models will be supported, depending on the requirements of the community.
			</p>
<div class="section" title="Communication Methods">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CommunicationMethods"></a>Communication Methods</h3>
</div>
</div>
</div>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<span class="bold"><strong>message driven</strong></span> (asynchronous, non blocking, no return value): Usually the message driven communication is implemented with message queues. Message queues are inherently asynchronous and enable a very good decoupling of the communicating parties.
						</p>
</li>
<li class="listitem">
<p>
							
<span class="bold"><strong>data driven</strong></span> (asynchronous, non blocking, no return value): In data driven communication sender and receiver often have a shared block of data. The sender writes the data and the receiver polls the data.
						</p>
</li>
<li class="listitem">
<p>
							
<span class="bold"><strong>function call</strong></span> (synchronous, blocking, return value): Regular function call as known in most programming languages.
						</p>
</li>
</ul>
</div>
</div>
<div class="section" title="Execution Methods">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ExecutionMethods"></a>Execution Methods</h3>
</div>
</div>
</div>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<span class="bold"><strong>execution by receive event</strong></span>: The message queue or the event dispatcher calls a &bdquo;receive event&rdquo; function of the message receiver an thereby executes the processing of the event.
						</p>
</li>
<li class="listitem">
<p>
							
<span class="bold"><strong>polled execution</strong></span>: The objects are processed by a cyclic &bdquo;execute&rdquo; call
						</p>
</li>
<li class="listitem">
<p>
							
<span class="bold"><strong>execution by function call</strong></span>: The caller executes the called object via function call
						</p>
</li>
</ul>
</div>
</div>
<div class="section" title="Execution Models">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ExecutionModels2"></a>Execution Models</h3>
</div>
</div>
</div>
<p>In todays software systems in most cases one or several of the following execution models are used:</p>
<div class="section" title="message driven">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="messagedriven"></a>message driven</h4>
</div>
</div>
</div>
<p>The message driven execution model is a combination of message driven communication and execution by receive event.
						This model allows for distributed systems with a very high throughput.
						It can be deterministic but the determinism is hard to proof.
						This execution model is often found in telecommunication systems and high performance automation control systems.</p>
</div>
<div class="section" title="data driven">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="datadriven"></a>data driven</h4>
</div>
</div>
</div>
<p>The data driven execution model is a combination of data driven communication and polled execution.
						This model is highly deterministic and very robust, but the polling creates a huge performance overhead.
						The determinism is easy to proof (simple mathematics). 
						The execution model is also compatible with the execution model of control software generated by Tools like Matlab&trade; and LabView&trade;.
						This model is usually used for systems with requirements for safety, such as automotive and avionic systems.</p>
</div>
<div class="section" title="synchronous">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="synchronous"></a>synchronous</h4>
</div>
</div>
</div>
<p>The synchronous execution model could also be called &bdquo;simple function calls&rdquo;. 
						This model is in general not very well suited to support the &bdquo;run to completion&rdquo; semantic typical for ROOM models, but could also be generated from ROOM models. 
						With this execution model also lower levels of a software system, such as device drivers, could be generated from ROOM models.</p>
</div>
</div>
</div>
</body>
</html>
