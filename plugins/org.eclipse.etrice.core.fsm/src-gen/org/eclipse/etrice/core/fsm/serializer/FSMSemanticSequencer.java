/*
 * generated by Xtext
 */
package org.eclipse.etrice.core.fsm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.etrice.core.common.base.Annotation;
import org.eclipse.etrice.core.common.base.AnnotationType;
import org.eclipse.etrice.core.common.base.BasePackage;
import org.eclipse.etrice.core.common.base.BooleanLiteral;
import org.eclipse.etrice.core.common.base.Documentation;
import org.eclipse.etrice.core.common.base.EnumAnnotationAttribute;
import org.eclipse.etrice.core.common.base.Import;
import org.eclipse.etrice.core.common.base.IntLiteral;
import org.eclipse.etrice.core.common.base.KeyValue;
import org.eclipse.etrice.core.common.base.LiteralArray;
import org.eclipse.etrice.core.common.base.RealLiteral;
import org.eclipse.etrice.core.common.base.SimpleAnnotationAttribute;
import org.eclipse.etrice.core.common.base.StringLiteral;
import org.eclipse.etrice.core.common.serializer.BaseSemanticSequencer;
import org.eclipse.etrice.core.fsm.fSM.AbstractInterfaceItem;
import org.eclipse.etrice.core.fsm.fSM.CPBranchTransition;
import org.eclipse.etrice.core.fsm.fSM.ChoicePoint;
import org.eclipse.etrice.core.fsm.fSM.ChoicepointTerminal;
import org.eclipse.etrice.core.fsm.fSM.ContinuationTransition;
import org.eclipse.etrice.core.fsm.fSM.DetailCode;
import org.eclipse.etrice.core.fsm.fSM.EntryPoint;
import org.eclipse.etrice.core.fsm.fSM.ExitPoint;
import org.eclipse.etrice.core.fsm.fSM.FSMModel;
import org.eclipse.etrice.core.fsm.fSM.FSMPackage;
import org.eclipse.etrice.core.fsm.fSM.Guard;
import org.eclipse.etrice.core.fsm.fSM.GuardedTransition;
import org.eclipse.etrice.core.fsm.fSM.InSemanticsRule;
import org.eclipse.etrice.core.fsm.fSM.InitialTransition;
import org.eclipse.etrice.core.fsm.fSM.MessageFromIf;
import org.eclipse.etrice.core.fsm.fSM.ModelComponent;
import org.eclipse.etrice.core.fsm.fSM.OutSemanticsRule;
import org.eclipse.etrice.core.fsm.fSM.ProtocolSemantics;
import org.eclipse.etrice.core.fsm.fSM.RefinedState;
import org.eclipse.etrice.core.fsm.fSM.RefinedTransition;
import org.eclipse.etrice.core.fsm.fSM.SimpleState;
import org.eclipse.etrice.core.fsm.fSM.StateGraph;
import org.eclipse.etrice.core.fsm.fSM.StateTerminal;
import org.eclipse.etrice.core.fsm.fSM.SubStateTrPointTerminal;
import org.eclipse.etrice.core.fsm.fSM.TrPointTerminal;
import org.eclipse.etrice.core.fsm.fSM.TransitionPoint;
import org.eclipse.etrice.core.fsm.fSM.Trigger;
import org.eclipse.etrice.core.fsm.fSM.TriggeredTransition;
import org.eclipse.etrice.core.fsm.services.FSMGrammarAccess;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FSMSemanticSequencer extends BaseSemanticSequencer {

	@Inject
	private FSMGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BasePackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case BasePackage.ANNOTATION_TYPE:
				sequence_AnnotationType(context, (AnnotationType) semanticObject); 
				return; 
			case BasePackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case BasePackage.DOCUMENTATION:
				sequence_Documentation(context, (Documentation) semanticObject); 
				return; 
			case BasePackage.ENUM_ANNOTATION_ATTRIBUTE:
				sequence_EnumAnnotationAttribute(context, (EnumAnnotationAttribute) semanticObject); 
				return; 
			case BasePackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case BasePackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case BasePackage.KEY_VALUE:
				sequence_KeyValue(context, (KeyValue) semanticObject); 
				return; 
			case BasePackage.LITERAL_ARRAY:
				sequence_LiteralArray(context, (LiteralArray) semanticObject); 
				return; 
			case BasePackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case BasePackage.SIMPLE_ANNOTATION_ATTRIBUTE:
				sequence_SimpleAnnotationAttribute(context, (SimpleAnnotationAttribute) semanticObject); 
				return; 
			case BasePackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			}
		else if (epackage == FSMPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FSMPackage.ABSTRACT_INTERFACE_ITEM:
				sequence_AbstractInterfaceItem(context, (AbstractInterfaceItem) semanticObject); 
				return; 
			case FSMPackage.CP_BRANCH_TRANSITION:
				sequence_CPBranchTransition(context, (CPBranchTransition) semanticObject); 
				return; 
			case FSMPackage.CHOICE_POINT:
				sequence_ChoicePoint(context, (ChoicePoint) semanticObject); 
				return; 
			case FSMPackage.CHOICEPOINT_TERMINAL:
				sequence_ChoicepointTerminal(context, (ChoicepointTerminal) semanticObject); 
				return; 
			case FSMPackage.CONTINUATION_TRANSITION:
				sequence_ContinuationTransition(context, (ContinuationTransition) semanticObject); 
				return; 
			case FSMPackage.DETAIL_CODE:
				sequence_DetailCode(context, (DetailCode) semanticObject); 
				return; 
			case FSMPackage.ENTRY_POINT:
				sequence_EntryPoint(context, (EntryPoint) semanticObject); 
				return; 
			case FSMPackage.EXIT_POINT:
				sequence_ExitPoint(context, (ExitPoint) semanticObject); 
				return; 
			case FSMPackage.FSM_MODEL:
				sequence_FSMModel(context, (FSMModel) semanticObject); 
				return; 
			case FSMPackage.GUARD:
				sequence_Guard(context, (Guard) semanticObject); 
				return; 
			case FSMPackage.GUARDED_TRANSITION:
				sequence_GuardedTransition(context, (GuardedTransition) semanticObject); 
				return; 
			case FSMPackage.IN_SEMANTICS_RULE:
				sequence_InSemanticsRule(context, (InSemanticsRule) semanticObject); 
				return; 
			case FSMPackage.INITIAL_TRANSITION:
				sequence_InitialTransition(context, (InitialTransition) semanticObject); 
				return; 
			case FSMPackage.MESSAGE_FROM_IF:
				sequence_MessageFromIf(context, (MessageFromIf) semanticObject); 
				return; 
			case FSMPackage.MODEL_COMPONENT:
				sequence_ModelComponent(context, (ModelComponent) semanticObject); 
				return; 
			case FSMPackage.OUT_SEMANTICS_RULE:
				sequence_OutSemanticsRule(context, (OutSemanticsRule) semanticObject); 
				return; 
			case FSMPackage.PROTOCOL_SEMANTICS:
				sequence_ProtocolSemantics(context, (ProtocolSemantics) semanticObject); 
				return; 
			case FSMPackage.REFINED_STATE:
				sequence_RefinedState(context, (RefinedState) semanticObject); 
				return; 
			case FSMPackage.REFINED_TRANSITION:
				sequence_RefinedTransition(context, (RefinedTransition) semanticObject); 
				return; 
			case FSMPackage.SIMPLE_STATE:
				sequence_SimpleState(context, (SimpleState) semanticObject); 
				return; 
			case FSMPackage.STATE_GRAPH:
				if (rule == grammarAccess.getStateGraphRule()) {
					sequence_StateGraph(context, (StateGraph) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStateMachineRule()) {
					sequence_StateMachine(context, (StateGraph) semanticObject); 
					return; 
				}
				else break;
			case FSMPackage.STATE_TERMINAL:
				sequence_StateTerminal(context, (StateTerminal) semanticObject); 
				return; 
			case FSMPackage.SUB_STATE_TR_POINT_TERMINAL:
				sequence_SubStateTrPointTerminal(context, (SubStateTrPointTerminal) semanticObject); 
				return; 
			case FSMPackage.TR_POINT_TERMINAL:
				sequence_TrPointTerminal(context, (TrPointTerminal) semanticObject); 
				return; 
			case FSMPackage.TRANSITION_POINT:
				sequence_TransitionPoint(context, (TransitionPoint) semanticObject); 
				return; 
			case FSMPackage.TRIGGER:
				sequence_Trigger(context, (Trigger) semanticObject); 
				return; 
			case FSMPackage.TRIGGERED_TRANSITION:
				sequence_TriggeredTransition(context, (TriggeredTransition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractInterfaceItem returns AbstractInterfaceItem
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_AbstractInterfaceItem(ISerializationContext context, AbstractInterfaceItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.ABSTRACT_INTERFACE_ITEM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.ABSTRACT_INTERFACE_ITEM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbstractInterfaceItemAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphItem returns CPBranchTransition
	 *     TransitionBase returns CPBranchTransition
	 *     Transition returns CPBranchTransition
	 *     NonInitialTransition returns CPBranchTransition
	 *     CPBranchTransition returns CPBranchTransition
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         from=TransitionTerminal 
	 *         to=TransitionTerminal 
	 *         docu=Documentation? 
	 *         annotations+=Annotation* 
	 *         condition=DetailCode 
	 *         action=DetailCode?
	 *     )
	 */
	protected void sequence_CPBranchTransition(ISerializationContext context, CPBranchTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphNode returns ChoicePoint
	 *     StateGraphItem returns ChoicePoint
	 *     ChoicePoint returns ChoicePoint
	 *
	 * Constraint:
	 *     (name=ID docu=Documentation?)
	 */
	protected void sequence_ChoicePoint(ISerializationContext context, ChoicePoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransitionTerminal returns ChoicepointTerminal
	 *     ChoicepointTerminal returns ChoicepointTerminal
	 *
	 * Constraint:
	 *     cp=[ChoicePoint|ID]
	 */
	protected void sequence_ChoicepointTerminal(ISerializationContext context, ChoicepointTerminal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.CHOICEPOINT_TERMINAL__CP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.CHOICEPOINT_TERMINAL__CP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChoicepointTerminalAccess().getCpChoicePointIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FSMPackage.Literals.CHOICEPOINT_TERMINAL__CP, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphItem returns ContinuationTransition
	 *     TransitionBase returns ContinuationTransition
	 *     Transition returns ContinuationTransition
	 *     NonInitialTransition returns ContinuationTransition
	 *     ContinuationTransition returns ContinuationTransition
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         from=TransitionTerminal 
	 *         to=TransitionTerminal 
	 *         docu=Documentation? 
	 *         annotations+=Annotation* 
	 *         action=DetailCode?
	 *     )
	 */
	protected void sequence_ContinuationTransition(ISerializationContext context, ContinuationTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DetailCode returns DetailCode
	 *
	 * Constraint:
	 *     (lines+=CC_STRING | (used?='{' lines+=STRING*))?
	 */
	protected void sequence_DetailCode(ISerializationContext context, DetailCode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphNode returns EntryPoint
	 *     StateGraphItem returns EntryPoint
	 *     TrPoint returns EntryPoint
	 *     EntryPoint returns EntryPoint
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EntryPoint(ISerializationContext context, EntryPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.TR_POINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.TR_POINT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntryPointAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphNode returns ExitPoint
	 *     StateGraphItem returns ExitPoint
	 *     TrPoint returns ExitPoint
	 *     ExitPoint returns ExitPoint
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ExitPoint(ISerializationContext context, ExitPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.TR_POINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.TR_POINT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExitPointAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FSMModel returns FSMModel
	 *
	 * Constraint:
	 *     components+=ModelComponent+
	 */
	protected void sequence_FSMModel(ISerializationContext context, FSMModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Guard returns Guard
	 *
	 * Constraint:
	 *     guard=DetailCode
	 */
	protected void sequence_Guard(ISerializationContext context, Guard semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.GUARD__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.GUARD__GUARD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGuardAccess().getGuardDetailCodeParserRuleCall_1_0(), semanticObject.getGuard());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphItem returns GuardedTransition
	 *     TransitionBase returns GuardedTransition
	 *     Transition returns GuardedTransition
	 *     NonInitialTransition returns GuardedTransition
	 *     TransitionChainStartTransition returns GuardedTransition
	 *     GuardedTransition returns GuardedTransition
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         from=TransitionTerminal 
	 *         to=TransitionTerminal 
	 *         docu=Documentation? 
	 *         annotations+=Annotation* 
	 *         guard=DetailCode 
	 *         action=DetailCode?
	 *     )
	 */
	protected void sequence_GuardedTransition(ISerializationContext context, GuardedTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SemanticsRule returns InSemanticsRule
	 *     InSemanticsRule returns InSemanticsRule
	 *
	 * Constraint:
	 *     (msg=[EObject|ID] (followUps+=SemanticsRule | (followUps+=SemanticsRule followUps+=SemanticsRule+))?)
	 */
	protected void sequence_InSemanticsRule(ISerializationContext context, InSemanticsRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphItem returns InitialTransition
	 *     TransitionBase returns InitialTransition
	 *     Transition returns InitialTransition
	 *     InitialTransition returns InitialTransition
	 *
	 * Constraint:
	 *     (name=ID? to=TransitionTerminal docu=Documentation? annotations+=Annotation* action=DetailCode?)
	 */
	protected void sequence_InitialTransition(ISerializationContext context, InitialTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageFromIf returns MessageFromIf
	 *
	 * Constraint:
	 *     (message=[EObject|ID] from=[AbstractInterfaceItem|ID])
	 */
	protected void sequence_MessageFromIf(ISerializationContext context, MessageFromIf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.MESSAGE_FROM_IF__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.MESSAGE_FROM_IF__MESSAGE));
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.MESSAGE_FROM_IF__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.MESSAGE_FROM_IF__FROM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMessageFromIfAccess().getMessageEObjectIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FSMPackage.Literals.MESSAGE_FROM_IF__MESSAGE, false));
		feeder.accept(grammarAccess.getMessageFromIfAccess().getFromAbstractInterfaceItemIDTerminalRuleCall_2_0_1(), semanticObject.eGet(FSMPackage.Literals.MESSAGE_FROM_IF__FROM, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelComponent returns ModelComponent
	 *
	 * Constraint:
	 *     ((abstract?='abstract' | commType=ComponentCommunicationType)* componentName=ID base=[ModelComponent|FQN]? stateMachine=StateMachine)
	 */
	protected void sequence_ModelComponent(ISerializationContext context, ModelComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SemanticsRule returns OutSemanticsRule
	 *     OutSemanticsRule returns OutSemanticsRule
	 *
	 * Constraint:
	 *     (msg=[EObject|ID] (followUps+=SemanticsRule | (followUps+=SemanticsRule followUps+=SemanticsRule+))?)
	 */
	protected void sequence_OutSemanticsRule(ISerializationContext context, OutSemanticsRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProtocolSemantics returns ProtocolSemantics
	 *
	 * Constraint:
	 *     rules+=SemanticsRule*
	 */
	protected void sequence_ProtocolSemantics(ISerializationContext context, ProtocolSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphNode returns RefinedState
	 *     StateGraphItem returns RefinedState
	 *     State returns RefinedState
	 *     RefinedState returns RefinedState
	 *
	 * Constraint:
	 *     (
	 *         target=[State|FQN] 
	 *         docu=Documentation? 
	 *         annotations+=Annotation* 
	 *         entryCode=DetailCode? 
	 *         exitCode=DetailCode? 
	 *         doCode=DetailCode? 
	 *         subgraph=StateGraph?
	 *     )
	 */
	protected void sequence_RefinedState(ISerializationContext context, RefinedState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphItem returns RefinedTransition
	 *     TransitionBase returns RefinedTransition
	 *     RefinedTransition returns RefinedTransition
	 *
	 * Constraint:
	 *     (target=[Transition|FQN] docu=Documentation? annotations+=Annotation* action=DetailCode)
	 */
	protected void sequence_RefinedTransition(ISerializationContext context, RefinedTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphNode returns SimpleState
	 *     StateGraphItem returns SimpleState
	 *     State returns SimpleState
	 *     SimpleState returns SimpleState
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         docu=Documentation? 
	 *         annotations+=Annotation* 
	 *         entryCode=DetailCode? 
	 *         exitCode=DetailCode? 
	 *         doCode=DetailCode? 
	 *         subgraph=StateGraph?
	 *     )
	 */
	protected void sequence_SimpleState(ISerializationContext context, SimpleState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateGraph returns StateGraph
	 *
	 * Constraint:
	 *     (states+=State | trPoints+=TrPoint | chPoints+=ChoicePoint | transitions+=Transition | refinedTransitions+=RefinedTransition)*
	 */
	protected void sequence_StateGraph(ISerializationContext context, StateGraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateMachine returns StateGraph
	 *
	 * Constraint:
	 *     (states+=State | trPoints+=TrPoint | chPoints+=ChoicePoint | transitions+=Transition | refinedTransitions+=RefinedTransition)*
	 */
	protected void sequence_StateMachine(ISerializationContext context, StateGraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransitionTerminal returns StateTerminal
	 *     StateTerminal returns StateTerminal
	 *
	 * Constraint:
	 *     state=[State|ID]
	 */
	protected void sequence_StateTerminal(ISerializationContext context, StateTerminal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.STATE_TERMINAL__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.STATE_TERMINAL__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStateTerminalAccess().getStateStateIDTerminalRuleCall_0_1(), semanticObject.eGet(FSMPackage.Literals.STATE_TERMINAL__STATE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TransitionTerminal returns SubStateTrPointTerminal
	 *     SubStateTrPointTerminal returns SubStateTrPointTerminal
	 *
	 * Constraint:
	 *     (trPoint=[TrPoint|ID] state=[State|ID])
	 */
	protected void sequence_SubStateTrPointTerminal(ISerializationContext context, SubStateTrPointTerminal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.SUB_STATE_TR_POINT_TERMINAL__TR_POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.SUB_STATE_TR_POINT_TERMINAL__TR_POINT));
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.SUB_STATE_TR_POINT_TERMINAL__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.SUB_STATE_TR_POINT_TERMINAL__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubStateTrPointTerminalAccess().getTrPointTrPointIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FSMPackage.Literals.SUB_STATE_TR_POINT_TERMINAL__TR_POINT, false));
		feeder.accept(grammarAccess.getSubStateTrPointTerminalAccess().getStateStateIDTerminalRuleCall_2_0_1(), semanticObject.eGet(FSMPackage.Literals.SUB_STATE_TR_POINT_TERMINAL__STATE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TransitionTerminal returns TrPointTerminal
	 *     TrPointTerminal returns TrPointTerminal
	 *
	 * Constraint:
	 *     trPoint=[TrPoint|ID]
	 */
	protected void sequence_TrPointTerminal(ISerializationContext context, TrPointTerminal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FSMPackage.Literals.TR_POINT_TERMINAL__TR_POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMPackage.Literals.TR_POINT_TERMINAL__TR_POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrPointTerminalAccess().getTrPointTrPointIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FSMPackage.Literals.TR_POINT_TERMINAL__TR_POINT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphNode returns TransitionPoint
	 *     StateGraphItem returns TransitionPoint
	 *     TrPoint returns TransitionPoint
	 *     TransitionPoint returns TransitionPoint
	 *
	 * Constraint:
	 *     (handler?='handler'? name=ID)
	 */
	protected void sequence_TransitionPoint(ISerializationContext context, TransitionPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Trigger returns Trigger
	 *
	 * Constraint:
	 *     (msgFromIfPairs+=MessageFromIf msgFromIfPairs+=MessageFromIf* guard=Guard?)
	 */
	protected void sequence_Trigger(ISerializationContext context, Trigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateGraphItem returns TriggeredTransition
	 *     TransitionBase returns TriggeredTransition
	 *     Transition returns TriggeredTransition
	 *     NonInitialTransition returns TriggeredTransition
	 *     TransitionChainStartTransition returns TriggeredTransition
	 *     TriggeredTransition returns TriggeredTransition
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         from=TransitionTerminal 
	 *         to=TransitionTerminal 
	 *         docu=Documentation? 
	 *         annotations+=Annotation* 
	 *         triggers+=Trigger 
	 *         triggers+=Trigger* 
	 *         action=DetailCode?
	 *     )
	 */
	protected void sequence_TriggeredTransition(ISerializationContext context, TriggeredTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
