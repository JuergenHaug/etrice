/*
* generated by Xtext
*/
package org.eclipse.etrice.core.fsm.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.etrice.core.common.services.BaseGrammarAccess;

@Singleton
public class FSMGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class FSMModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FSMModel");
		private final Assignment cGreetingsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cGreetingsGreetingParserRuleCall_0 = (RuleCall)cGreetingsAssignment.eContents().get(0);
		
		//FSMModel:
		//	greetings+=Greeting*;
		public ParserRule getRule() { return rule; }

		//greetings+=Greeting*
		public Assignment getGreetingsAssignment() { return cGreetingsAssignment; }

		//Greeting
		public RuleCall getGreetingsGreetingParserRuleCall_0() { return cGreetingsGreetingParserRuleCall_0; }
	}

	public class GreetingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Greeting");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHelloKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Greeting:
		//	"Hello" name=ID "!";
		public ParserRule getRule() { return rule; }

		//"Hello" name=ID "!"
		public Group getGroup() { return cGroup; }

		//"Hello"
		public Keyword getHelloKeyword_0() { return cHelloKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_2() { return cExclamationMarkKeyword_2; }
	}
	
	
	private FSMModelElements pFSMModel;
	private GreetingElements pGreeting;
	
	private final Grammar grammar;

	private BaseGrammarAccess gaBase;

	@Inject
	public FSMGrammarAccess(GrammarProvider grammarProvider,
		BaseGrammarAccess gaBase) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaBase = gaBase;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.eclipse.etrice.core.fsm.FSM".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public BaseGrammarAccess getBaseGrammarAccess() {
		return gaBase;
	}

	
	//FSMModel:
	//	greetings+=Greeting*;
	public FSMModelElements getFSMModelAccess() {
		return (pFSMModel != null) ? pFSMModel : (pFSMModel = new FSMModelElements());
	}
	
	public ParserRule getFSMModelRule() {
		return getFSMModelAccess().getRule();
	}

	//Greeting:
	//	"Hello" name=ID "!";
	public GreetingElements getGreetingAccess() {
		return (pGreeting != null) ? pGreeting : (pGreeting = new GreetingElements());
	}
	
	public ParserRule getGreetingRule() {
		return getGreetingAccess().getRule();
	}

	//// **************************************************************
	//// AnnotationType and Annotation Rules
	//Annotation:
	//	"@" type=[AnnotationType|FQN] ("(" attributes+=KeyValue ("," attributes+=KeyValue)* ")")?;
	public BaseGrammarAccess.AnnotationElements getAnnotationAccess() {
		return gaBase.getAnnotationAccess();
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}

	//KeyValue:
	//	key=ID "=" value=Literal;
	public BaseGrammarAccess.KeyValueElements getKeyValueAccess() {
		return gaBase.getKeyValueAccess();
	}
	
	public ParserRule getKeyValueRule() {
		return getKeyValueAccess().getRule();
	}

	//AnnotationType:
	//	"AnnotationType" name=ID docu=Documentation? "{" "target" "=" (targets+=AnnotationTargetType | "{"
	//	targets+=AnnotationTargetType ("," targets+=AnnotationTargetType)* "}") attributes+=AnnotationAttribute* "}";
	public BaseGrammarAccess.AnnotationTypeElements getAnnotationTypeAccess() {
		return gaBase.getAnnotationTypeAccess();
	}
	
	public ParserRule getAnnotationTypeRule() {
		return getAnnotationTypeAccess().getRule();
	}

	////
	//// Sub-grammars should use AnnotationTargetType to refer to 
	//// specific sub-grammar targets. For example, valid values for 
	//// AnnotationTargetType in the Room.xtext sub-grammar include "ActorClass", 
	//// "ActorBehavior", "ProtocolClass", etc. The sub-grammar is responsible for 
	//// implementing validation, quick-fixes, and code completion proposals via the 
	//// usual Xtext mechanisms.
	////
	//AnnotationTargetType:
	//	ID;
	public BaseGrammarAccess.AnnotationTargetTypeElements getAnnotationTargetTypeAccess() {
		return gaBase.getAnnotationTargetTypeAccess();
	}
	
	public ParserRule getAnnotationTargetTypeRule() {
		return getAnnotationTargetTypeAccess().getRule();
	}

	//AnnotationAttribute:
	//	SimpleAnnotationAttribute | EnumAnnotationAttribute;
	public BaseGrammarAccess.AnnotationAttributeElements getAnnotationAttributeAccess() {
		return gaBase.getAnnotationAttributeAccess();
	}
	
	public ParserRule getAnnotationAttributeRule() {
		return getAnnotationAttributeAccess().getRule();
	}

	//SimpleAnnotationAttribute:
	//	(optional?="optional" | "mandatory") "attribute" name=ID ":" type=LiteralType;
	public BaseGrammarAccess.SimpleAnnotationAttributeElements getSimpleAnnotationAttributeAccess() {
		return gaBase.getSimpleAnnotationAttributeAccess();
	}
	
	public ParserRule getSimpleAnnotationAttributeRule() {
		return getSimpleAnnotationAttributeAccess().getRule();
	}

	//EnumAnnotationAttribute:
	//	(optional?="optional" | "mandatory") "attribute" name=ID ":" "{" values+=STRING ("," values+=STRING)* "}";
	public BaseGrammarAccess.EnumAnnotationAttributeElements getEnumAnnotationAttributeAccess() {
		return gaBase.getEnumAnnotationAttributeAccess();
	}
	
	public ParserRule getEnumAnnotationAttributeRule() {
		return getEnumAnnotationAttributeAccess().getRule();
	}

	//// **************************************************************
	//// Import rules
	//// HOWTO: use a combination of URI global scopes and namespace aware local scope provider
	//// this is configured in the work flow by
	////			fragment = scoping.ImportURIScopingFragment {}
	//// and by overriding configureIScopeProviderDelegate in the runtime module with 
	////			ImportedNamespaceAwareLocalScopeProvider
	//// also configure in the RuntimeModule
	////	public Class<? extends ImportUriResolver> bindImportUriResolver() {
	////		return PlatformRelativeUriResolver.class;
	////	}
	//// and in the UiRuntimeModule
	////	public Class<? extends org.eclipse.xtext.ui.editor.IURIEditorOpener> bindIURIEditorOpener() {
	////		return GlobalNonPlatformURIEditorOpener.class;
	////	}
	////	public Class<? extends IHyperlinkHelper> bindIHyperlinkHelper() {
	////		return ImportAwareHyperlinkHelper.class;
	////	}
	//// the attribute 'importedNamespace' is picked up by the ImportedNamespaceAwareLocalScopeProvider
	//// the attribute 'importURI' is picked up by the ImportUriGlobalScopeProvider
	//Import:
	//	"import" (importedNamespace=ImportedFQN "from" | "model") importURI=STRING;
	public BaseGrammarAccess.ImportElements getImportAccess() {
		return gaBase.getImportAccess();
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	//ImportedFQN:
	//	FQN ".*"?;
	public BaseGrammarAccess.ImportedFQNElements getImportedFQNAccess() {
		return gaBase.getImportedFQNAccess();
	}
	
	public ParserRule getImportedFQNRule() {
		return getImportedFQNAccess().getRule();
	}

	//// **************************************************************
	//// Documentation Rule
	//Documentation:
	//	{Documentation} "[" lines+=STRING* "]";
	public BaseGrammarAccess.DocumentationElements getDocumentationAccess() {
		return gaBase.getDocumentationAccess();
	}
	
	public ParserRule getDocumentationRule() {
		return getDocumentationAccess().getRule();
	}

	//// **************************************************************
	//// Time Rule
	//TIME returns ecore::ELong:
	//	INT "s" | INT "ms" | INT "us" | INT "ns";
	public BaseGrammarAccess.TIMEElements getTIMEAccess() {
		return gaBase.getTIMEAccess();
	}
	
	public ParserRule getTIMERule() {
		return getTIMEAccess().getRule();
	}

	//// **************************************************************
	//// Literal Rules
	//enum LiteralType:
	//	BOOL="ptBoolean" | INT="ptInteger" | REAL="ptReal" | CHAR="ptCharacter";
	public BaseGrammarAccess.LiteralTypeElements getLiteralTypeAccess() {
		return gaBase.getLiteralTypeAccess();
	}
	
	public EnumRule getLiteralTypeRule() {
		return getLiteralTypeAccess().getRule();
	}

	//LiteralArray:
	//	literals+=Literal ("," literals+=Literal)*;
	public BaseGrammarAccess.LiteralArrayElements getLiteralArrayAccess() {
		return gaBase.getLiteralArrayAccess();
	}
	
	public ParserRule getLiteralArrayRule() {
		return getLiteralArrayAccess().getRule();
	}

	//// Value Types for Attributes
	//Literal:
	//	BooleanLiteral | NumberLiteral | StringLiteral;
	public BaseGrammarAccess.LiteralElements getLiteralAccess() {
		return gaBase.getLiteralAccess();
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//BooleanLiteral:
	//	{BooleanLiteral} ("false" | isTrue?="true");
	public BaseGrammarAccess.BooleanLiteralElements getBooleanLiteralAccess() {
		return gaBase.getBooleanLiteralAccess();
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//NumberLiteral:
	//	IntLiteral | RealLiteral;
	public BaseGrammarAccess.NumberLiteralElements getNumberLiteralAccess() {
		return gaBase.getNumberLiteralAccess();
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}

	//RealLiteral:
	//	{RealLiteral} value=Real;
	public BaseGrammarAccess.RealLiteralElements getRealLiteralAccess() {
		return gaBase.getRealLiteralAccess();
	}
	
	public ParserRule getRealLiteralRule() {
		return getRealLiteralAccess().getRule();
	}

	//IntLiteral:
	//	{IntLiteral} value=Integer;
	public BaseGrammarAccess.IntLiteralElements getIntLiteralAccess() {
		return gaBase.getIntLiteralAccess();
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}

	//StringLiteral:
	//	{StringLiteral} value=STRING;
	public BaseGrammarAccess.StringLiteralElements getStringLiteralAccess() {
		return gaBase.getStringLiteralAccess();
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//Integer returns ecore::ELong:
	//	SignedInteger | Hexadecimal;
	public BaseGrammarAccess.IntegerElements getIntegerAccess() {
		return gaBase.getIntegerAccess();
	}
	
	public ParserRule getIntegerRule() {
		return getIntegerAccess().getRule();
	}

	//SignedInteger hidden():
	//	("+" | "-")? INT;
	public BaseGrammarAccess.SignedIntegerElements getSignedIntegerAccess() {
		return gaBase.getSignedIntegerAccess();
	}
	
	public ParserRule getSignedIntegerRule() {
		return getSignedIntegerAccess().getRule();
	}

	//Hexadecimal hidden():
	//	HEX;
	public BaseGrammarAccess.HexadecimalElements getHexadecimalAccess() {
		return gaBase.getHexadecimalAccess();
	}
	
	public ParserRule getHexadecimalRule() {
		return getHexadecimalAccess().getRule();
	}

	//Real returns ecore::EDouble:
	//	Decimal | DotDecimal | DecimalDot | DecimalExp;
	public BaseGrammarAccess.RealElements getRealAccess() {
		return gaBase.getRealAccess();
	}
	
	public ParserRule getRealRule() {
		return getRealAccess().getRule();
	}

	//Decimal hidden():
	//	("+" | "-")? INT "." INT;
	public BaseGrammarAccess.DecimalElements getDecimalAccess() {
		return gaBase.getDecimalAccess();
	}
	
	public ParserRule getDecimalRule() {
		return getDecimalAccess().getRule();
	}

	//DotDecimal hidden():
	//	("+" | "-")? "." INT;
	public BaseGrammarAccess.DotDecimalElements getDotDecimalAccess() {
		return gaBase.getDotDecimalAccess();
	}
	
	public ParserRule getDotDecimalRule() {
		return getDotDecimalAccess().getRule();
	}

	//DecimalDot hidden():
	//	("+" | "-")? INT ".";
	public BaseGrammarAccess.DecimalDotElements getDecimalDotAccess() {
		return gaBase.getDecimalDotAccess();
	}
	
	public ParserRule getDecimalDotRule() {
		return getDecimalDotAccess().getRule();
	}

	//DecimalExp hidden():
	//	("+" | "-")? INT "." INT EXP;
	public BaseGrammarAccess.DecimalExpElements getDecimalExpAccess() {
		return gaBase.getDecimalExpAccess();
	}
	
	public ParserRule getDecimalExpRule() {
		return getDecimalExpAccess().getRule();
	}

	//terminal EXP:
	//	("e" | "E") ("+" | "-")? "0".."9"+;
	public TerminalRule getEXPRule() {
		return gaBase.getEXPRule();
	} 

	//terminal HEX:
	//	("0x" | "0X") ("0".."9" | "a".."f" | "A".."F")+;
	public TerminalRule getHEXRule() {
		return gaBase.getHEXRule();
	} 

	//FQN:
	//	ID ("." ID)*;
	public BaseGrammarAccess.FQNElements getFQNAccess() {
		return gaBase.getFQNAccess();
	}
	
	public ParserRule getFQNRule() {
		return getFQNAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaBase.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaBase.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaBase.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaBase.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaBase.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaBase.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaBase.getANY_OTHERRule();
	} 
}
