/**
 * Copyright (c) 2011 Draeger Medical GmbH (http://www.draeger.com).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * CONTRIBUTORS:
 * 		Peter Karlitschek (initial contribution)
 */
package org.eclipse.etrice.generator.cpp.gen;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.eclipse.emf.common.util.EList;
import org.eclipse.etrice.core.genmodel.base.ILogger;
import org.eclipse.etrice.core.genmodel.etricegen.ActorInstance;
import org.eclipse.etrice.core.genmodel.etricegen.InterfaceItemInstance;
import org.eclipse.etrice.core.genmodel.etricegen.Root;
import org.eclipse.etrice.core.genmodel.etricegen.SubSystemInstance;
import org.eclipse.etrice.core.room.RoomModel;
import org.eclipse.etrice.core.room.SubSystemClass;
import org.eclipse.etrice.generator.base.IDataConfiguration;
import org.eclipse.etrice.generator.cpp.gen.CppExtensions;
import org.eclipse.etrice.generator.generic.ProcedureHelpers;
import org.eclipse.etrice.generator.generic.RoomExtensions;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.JavaIoFileSystemAccess;
import org.eclipse.xtext.xbase.lib.Extension;

/**
 * @author Peter Karlitschek
 */
@Singleton
@SuppressWarnings("all")
public class SubSystemClassGen {
  @Inject
  private JavaIoFileSystemAccess fileAccess;
  
  @Inject
  @Extension
  private CppExtensions _cppExtensions;
  
  @Inject
  @Extension
  private RoomExtensions _roomExtensions;
  
  @Inject
  @Extension
  private ProcedureHelpers _procedureHelpers;
  
  @Inject
  private IDataConfiguration dataConfigExt;
  
  @Inject
  private /* ConfigGenAddon */Object configGenAddon;
  
  @Inject
  private /* ConfigGenAddon */Object configAddon;
  
  @Inject
  private ILogger logger;
  
  public void doGenerate(final Root root) {
    EList<SubSystemInstance> _subSystemInstances = root.getSubSystemInstances();
    for (final SubSystemInstance ssi : _subSystemInstances) {
      {
        SubSystemClass _subSystemClass = ssi.getSubSystemClass();
        String _generationTargetPath = this._roomExtensions.getGenerationTargetPath(_subSystemClass);
        SubSystemClass _subSystemClass_1 = ssi.getSubSystemClass();
        String _path = this._roomExtensions.getPath(_subSystemClass_1);
        String path = (_generationTargetPath + _path);
        SubSystemClass _subSystemClass_2 = ssi.getSubSystemClass();
        String file = this._cppExtensions.getCppHeaderFileName(_subSystemClass_2);
        String _plus = ("generating SubSystemClass declaration: \'" + file);
        String _plus_1 = (_plus + "\' in \'");
        String _plus_2 = (_plus_1 + path);
        String _plus_3 = (_plus_2 + "\'");
        this.logger.logInfo(_plus_3);
        this.fileAccess.setOutputPath(path);
        SubSystemClass _subSystemClass_3 = ssi.getSubSystemClass();
        CharSequence _generateHeaderFile = this.generateHeaderFile(root, ssi, _subSystemClass_3);
        this.fileAccess.generateFile(file, _generateHeaderFile);
        SubSystemClass _subSystemClass_4 = ssi.getSubSystemClass();
        String _cppSourceFileName = this._cppExtensions.getCppSourceFileName(_subSystemClass_4);
        file = _cppSourceFileName;
        String _plus_4 = ("generating SubSystemClass implementation: \'" + file);
        String _plus_5 = (_plus_4 + "\' in \'");
        String _plus_6 = (_plus_5 + path);
        String _plus_7 = (_plus_6 + "\'");
        this.logger.logInfo(_plus_7);
        this.fileAccess.setOutputPath(path);
        SubSystemClass _subSystemClass_5 = ssi.getSubSystemClass();
        CharSequence _generateSourceFile = this.generateSourceFile(root, ssi, _subSystemClass_5);
        this.fileAccess.generateFile(file, _generateSourceFile);
      }
    }
  }
  
  public CharSequence generateHeaderFile(final Root root, final SubSystemInstance comp, final SubSystemClass cc) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @author generated by eTrice");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Header File of SubSystemClass ");
    String _name = cc.getName();
    _builder.append(_name, "	 ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    String _name_1 = cc.getName();
    CharSequence _generateIncludeGuardBegin = this._cppExtensions.generateIncludeGuardBegin(_name_1);
    _builder.append(_generateIncludeGuardBegin, "	");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include \"platforms/generic/etDatatypes.h\"");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include \"common/messaging/IRTObject.h\"");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include \"common/modelbase/PortBase.h\"");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include \"common/modelbase/InterfaceItemBase.h\"");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include \"common/modelbase/ActorClassBase.h\"");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include \"common/modelbase/SubSystemClassBase.h\"");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include \"common/messaging/Address.h\"");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include \"common/messaging/IMessageReceiver.h\"");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include \"common/debugging/DebuggingService.h\"");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include <string>");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("#include <vector>");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    {
      EList<RoomModel> _referencedModels = root.getReferencedModels(cc);
      for(final RoomModel model : _referencedModels) {
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _userCode = this._procedureHelpers.userCode(cc, 1);
    _builder.append(_userCode, "	");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("class ");
    String _name_2 = cc.getName();
    _builder.append(_name_2, "	");
    _builder.append(" : public etRuntime::SubSystemClassBase{");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    CharSequence _userCode_1 = this._procedureHelpers.userCode(cc, 2);
    _builder.append(_userCode_1, "		");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("public:");
    _builder.newLine();
    _builder.append("\t\t\t");
    String _name_3 = cc.getName();
    _builder.append(_name_3, "			");
    _builder.append("(IRTObject* parent, std::string name)");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t\t");
    _builder.append(": etRuntime::SubSystemClassBase(parent, name)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("virtual void receiveEvent(etRuntime::InterfaceItemBase* ifitem, int evt, void* data);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("virtual void instantiateMessageServices();");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("virtual void instantiateActors();");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("private:");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("std::vector<etRuntime::MessageService*> m_msgServices;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("};");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    String _name_4 = cc.getName();
    CharSequence _generateIncludeGuardEnd = this._cppExtensions.generateIncludeGuardEnd(_name_4);
    _builder.append(_generateIncludeGuardEnd, "	");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence generateSourceFile(final Root root, final SubSystemInstance comp, final SubSystemClass cc) {
    throw new Error("Unresolved compilation problems:"
      + "\ngenActorInstanceConfig cannot be resolved"
      + "\n> cannot be resolved"
      + "\nlength cannot be resolved");
  }
  
  public CharSequence generateOwnInterfaceItemAddresses(final ActorInstance ai) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("std::vector<std::vector<Address> > ");
    String _name = ai.getName();
    _builder.append(_name, "");
    _builder.append("_ownInterfaceItemAddresses;");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("std::vector<Address> ");
    String _name_1 = ai.getName();
    _builder.append(_name_1, "");
    _builder.append("_actorInstanceAddresses(1);");
    _builder.newLineIfNotEmpty();
    String _name_2 = ai.getName();
    _builder.append(_name_2, "");
    _builder.append("_actorInstanceAddresses[0] = addr_item_");
    String _path = ai.getPath();
    String _pathName = this._roomExtensions.getPathName(_path);
    _builder.append(_pathName, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    String _name_3 = ai.getName();
    _builder.append(_name_3, "");
    _builder.append("_ownInterfaceItemAddresses.push_back(");
    String _name_4 = ai.getName();
    _builder.append(_name_4, "");
    _builder.append("_actorInstanceAddresses);");
    _builder.newLineIfNotEmpty();
    {
      EList<InterfaceItemInstance> _orderedIfItemInstances = ai.getOrderedIfItemInstances();
      for(final InterfaceItemInstance pi : _orderedIfItemInstances) {
        {
          boolean _isReplicated = pi.isReplicated();
          if (_isReplicated) {
            {
              EList<InterfaceItemInstance> _peers = pi.getPeers();
              boolean _isEmpty = _peers.isEmpty();
              if (_isEmpty) {
                _builder.append("std::vector<Address>  ");
                String _name_5 = ai.getName();
                _builder.append(_name_5, "");
                _builder.append("_");
                String _name_6 = pi.getName();
                _builder.append(_name_6, "");
                _builder.append("Addresses;");
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append("std::vector<Address>  ");
                String _name_7 = ai.getName();
                _builder.append(_name_7, "");
                _builder.append("_");
                String _name_8 = pi.getName();
                _builder.append(_name_8, "");
                _builder.append("Addresses(");
                EList<InterfaceItemInstance> _peers_1 = pi.getPeers();
                int _size = _peers_1.size();
                _builder.append(_size, "");
                _builder.append(");");
                _builder.newLineIfNotEmpty();
                {
                  EList<InterfaceItemInstance> _peers_2 = pi.getPeers();
                  for(final InterfaceItemInstance peer : _peers_2) {
                    String _name_9 = ai.getName();
                    _builder.append(_name_9, "");
                    _builder.append("_");
                    String _name_10 = pi.getName();
                    _builder.append(_name_10, "");
                    _builder.append("Addresses[");
                    EList<InterfaceItemInstance> _peers_3 = pi.getPeers();
                    int _indexOf = _peers_3.indexOf(peer);
                    _builder.append(_indexOf, "");
                    _builder.append("] = addr_item_");
                    String _path_1 = pi.getPath();
                    String _pathName_1 = this._roomExtensions.getPathName(_path_1);
                    _builder.append(_pathName_1, "");
                    _builder.append("_");
                    EList<InterfaceItemInstance> _peers_4 = pi.getPeers();
                    int _indexOf_1 = _peers_4.indexOf(peer);
                    _builder.append(_indexOf_1, "");
                    _builder.append(";");
                    _builder.newLineIfNotEmpty();
                  }
                }
              }
            }
          } else {
            _builder.append("std::vector<Address>  ");
            String _name_11 = ai.getName();
            _builder.append(_name_11, "");
            _builder.append("_");
            String _name_12 = pi.getName();
            _builder.append(_name_12, "");
            _builder.append("Addresses(1);");
            _builder.newLineIfNotEmpty();
            String _name_13 = ai.getName();
            _builder.append(_name_13, "");
            _builder.append("_");
            String _name_14 = pi.getName();
            _builder.append(_name_14, "");
            _builder.append("Addresses[0] = addr_item_");
            String _path_2 = pi.getPath();
            String _pathName_2 = this._roomExtensions.getPathName(_path_2);
            _builder.append(_pathName_2, "");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
          }
        }
        String _name_15 = ai.getName();
        _builder.append(_name_15, "");
        _builder.append("_ownInterfaceItemAddresses.push_back(");
        String _name_16 = ai.getName();
        _builder.append(_name_16, "");
        _builder.append("_");
        String _name_17 = pi.getName();
        _builder.append(_name_17, "");
        _builder.append("Addresses);");
        _builder.newLineIfNotEmpty();
        _builder.newLine();
      }
    }
    return _builder;
  }
  
  public CharSequence generatePeerInterfaceItemAddresses(final ActorInstance ai, final SubSystemInstance comp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("std::vector<std::vector<Address> > ");
    String _name = ai.getName();
    _builder.append(_name, "");
    _builder.append("_peerInterfaceItemAddresses;");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("std::vector<Address> ");
    String _name_1 = ai.getName();
    _builder.append(_name_1, "");
    _builder.append("_systemPortAddresses(1);");
    _builder.newLineIfNotEmpty();
    String _name_2 = ai.getName();
    _builder.append(_name_2, "");
    _builder.append("_systemPortAddresses[0] = addr_item_SystemPort_");
    EList<ActorInstance> _allContainedInstances = comp.getAllContainedInstances();
    int _indexOf = _allContainedInstances.indexOf(ai);
    _builder.append(_indexOf, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    String _name_3 = ai.getName();
    _builder.append(_name_3, "");
    _builder.append("_peerInterfaceItemAddresses.push_back(");
    String _name_4 = ai.getName();
    _builder.append(_name_4, "");
    _builder.append("_systemPortAddresses);");
    _builder.newLineIfNotEmpty();
    {
      EList<InterfaceItemInstance> _orderedIfItemInstances = ai.getOrderedIfItemInstances();
      for(final InterfaceItemInstance pi : _orderedIfItemInstances) {
        {
          boolean _and = false;
          boolean _isReplicated = pi.isReplicated();
          if (!_isReplicated) {
            _and = false;
          } else {
            EList<InterfaceItemInstance> _peers = pi.getPeers();
            boolean _isEmpty = _peers.isEmpty();
            _and = (_isReplicated && _isEmpty);
          }
          if (_and) {
          } else {
            {
              EList<InterfaceItemInstance> _peers_1 = pi.getPeers();
              boolean _isEmpty_1 = _peers_1.isEmpty();
              if (_isEmpty_1) {
                _builder.append("std::vector<Address>  ");
                String _name_5 = ai.getName();
                _builder.append(_name_5, "");
                _builder.append("_");
                String _name_6 = pi.getName();
                _builder.append(_name_6, "");
                _builder.append("PeerAddresses;");
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append("std::vector<Address>  ");
                String _name_7 = ai.getName();
                _builder.append(_name_7, "");
                _builder.append("_");
                String _name_8 = pi.getName();
                _builder.append(_name_8, "");
                _builder.append("PeerAddresses(");
                EList<InterfaceItemInstance> _peers_2 = pi.getPeers();
                int _size = _peers_2.size();
                _builder.append(_size, "");
                _builder.append(");");
                _builder.newLineIfNotEmpty();
                {
                  EList<InterfaceItemInstance> _peers_3 = pi.getPeers();
                  for(final InterfaceItemInstance pp : _peers_3) {
                    {
                      boolean _isReplicated_1 = pp.isReplicated();
                      if (_isReplicated_1) {
                        String _name_9 = ai.getName();
                        _builder.append(_name_9, "");
                        _builder.append("_");
                        String _name_10 = pi.getName();
                        _builder.append(_name_10, "");
                        _builder.append("PeerAddresses[");
                        EList<InterfaceItemInstance> _peers_4 = pi.getPeers();
                        int _indexOf_1 = _peers_4.indexOf(pp);
                        _builder.append(_indexOf_1, "");
                        _builder.append("] = addr_item_");
                        String _path = pp.getPath();
                        String _pathName = this._roomExtensions.getPathName(_path);
                        _builder.append(_pathName, "");
                        _builder.append("_");
                        EList<InterfaceItemInstance> _peers_5 = pp.getPeers();
                        int _indexOf_2 = _peers_5.indexOf(pi);
                        _builder.append(_indexOf_2, "");
                        _builder.append(";");
                        _builder.newLineIfNotEmpty();
                      } else {
                        String _name_11 = ai.getName();
                        _builder.append(_name_11, "");
                        _builder.append("_");
                        String _name_12 = pi.getName();
                        _builder.append(_name_12, "");
                        _builder.append("PeerAddresses[");
                        EList<InterfaceItemInstance> _peers_6 = pi.getPeers();
                        int _indexOf_3 = _peers_6.indexOf(pp);
                        _builder.append(_indexOf_3, "");
                        _builder.append("] = addr_item_");
                        String _path_1 = pp.getPath();
                        String _pathName_1 = this._roomExtensions.getPathName(_path_1);
                        _builder.append(_pathName_1, "");
                        _builder.append(";");
                        _builder.newLineIfNotEmpty();
                      }
                    }
                  }
                }
              }
            }
            String _name_13 = ai.getName();
            _builder.append(_name_13, "");
            _builder.append("_peerInterfaceItemAddresses.push_back(");
            String _name_14 = ai.getName();
            _builder.append(_name_14, "");
            _builder.append("_");
            String _name_15 = pi.getName();
            _builder.append(_name_15, "");
            _builder.append("PeerAddresses);");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    return _builder;
  }
}
