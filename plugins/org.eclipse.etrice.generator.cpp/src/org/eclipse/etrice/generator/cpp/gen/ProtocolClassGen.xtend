/*******************************************************************************
 * Copyright (c) 2011 protos software gmbh (http://www.protos.de).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * CONTRIBUTORS:
 * 		Henrik Rentz-Reichert (initial contribution)
 * 		Thomas Schuetz (changed for C code generator)
 * 
 *******************************************************************************/

package org.eclipse.etrice.generator.cpp.gen

import com.google.inject.Inject
import com.google.inject.Singleton
import org.eclipse.etrice.core.room.CommunicationType
import org.eclipse.etrice.core.room.DataClass
import org.eclipse.etrice.core.room.Message
import org.eclipse.etrice.core.room.PrimitiveType
import org.eclipse.etrice.core.room.ProtocolClass

import org.eclipse.etrice.generator.generic.GenericProtocolClassGenerator
import org.eclipse.etrice.generator.generic.ProcedureHelpers
import org.eclipse.etrice.generator.generic.RoomExtensions
import org.eclipse.etrice.generator.generic.TypeHelpers

import org.eclipse.xtext.generator.JavaIoFileSystemAccess

import org.eclipse.etrice.core.genmodel.base.ILogger
import org.eclipse.etrice.core.genmodel.etricegen.Root


@Singleton
class ProtocolClassGen extends GenericProtocolClassGenerator {

	@Inject extension JavaIoFileSystemAccess fileAccess
	@Inject extension CppExtensions stdExt
	@Inject extension RoomExtensions roomExt
	@Inject extension ProcedureHelpers helpers
	@Inject extension TypeHelpers
	@Inject ILogger logger
	
	def doGenerate(Root root) { 
		for (pc: root.usedProtocolClasses) {
			var path = pc.generationTargetPath+pc.getPath

			logger.logInfo("generating ProtocolClass header '"+pc.getCppHeaderFileName+"' in '"+path+"'")
			fileAccess.setOutputPath(path)
			fileAccess.generateFile(pc.getCppHeaderFileName, root.generateHeaderFile(pc))

			logger.logInfo("generating ProtocolClass source '"+pc.getCppSourceFileName+"' in '"+path+"'")
			fileAccess.setOutputPath(path)
			fileAccess.generateFile(pc.getCppSourceFileName, root.generateSourceFile(pc))
		}
	}

	
	def private generateHeaderFile(Root root, ProtocolClass pc) {'''
		/**
		 * @author generated by eTrice
		 *
		 * Header File of ProtocolClass «pc.name»
		 * 
		 */

		«generateIncludeGuardBegin(pc.name)»
		
		#include "platforms/generic/etDatatypes.h"
		#include "common/messaging/IRTObject.h"
		#include "common/modelbase/PortBase.h"
		#include "common/modelbase/InterfaceItemBase.h"
		#include "common/messaging/Address.h"
		#include "common/messaging/Message.h"
		#include <vector>
		#include <string>
				
		namespace etRuntime {
			class IEventReceiver;
			
		}
		
		«helpers.userCode(pc.userCode1)»
		
		«FOR dataClass : root.getReferencedDataClasses(pc)»
			#include "«dataClass.name».h"
		«ENDFOR»

		class «pc.name» {
		   public:
		«IF pc.commType==CommunicationType::EVENT_DRIVEN»	   /* message IDs */
			class Events {
				public:
					«genMessageIDs(pc)»
					static bool isValidEvtID(int evtId) {
						return ((MSG_MIN < evtId) && (evtId < MSG_MAX));
					};
					static bool isValidOutgoingEvtID(int evtId) {
						return ((Events::MSG_MIN < evtId) && (evtId < Events::«IF pc.incomingMessages.size == 0»MSG_MAX«ELSE»IN_«pc.incomingMessages.get(0).name»«ENDIF»));
					};
					static bool isValidIncomingEvtID(int evtId) {
						return ((Events::«IF pc.incomingMessages.size == 0»MSG_MAX«ELSE»IN_«pc.incomingMessages.get(0).name»«ENDIF» <= evtId) && (evtId < Events::MSG_MAX));
					};
					static std::string getMessageString(int msg_id);
				
				private:
					static std::string s_messageStrings[];
			};
		«ENDIF»
				«helpers.userCode(pc.userCode2)»
		
			 		
				«portClassDeclaration(pc, false)»
				«portClassDeclaration(pc, true)»
		};
		«generateIncludeGuardEnd(pc.name)»
	'''
	}
	
	def portClassDeclaration(ProtocolClass pc, Boolean conj) {
		var pclass = pc.getPortClass(conj)
		var portClassName = pc.getPortClassName(conj)
		var replPortClassName = pc.getPortClassName(conj, true)
	'''
		//------------------------------------------------------------------------------------------------------------
		// «IF conj»conjugated «ENDIF»port class
		//------------------------------------------------------------------------------------------------------------
		class «portClassName» : public etRuntime::PortBase {
			«IF pclass!=null»
				«helpers.userCode(pclass.userCode)»
			«ENDIF»
		   public:
			// constructors
			 «portClassName»(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, etRuntime::Address addr, etRuntime::Address peerAddress); 
			 «portClassName»(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, int idx, etRuntime::Address addr, etRuntime::Address peerAddress);
		
			 virtual void receive(etRuntime::Message* m);
			«IF pclass!=null»
				«helpers.attributes(pclass.attributes)»
				«helpers.operationsDeclaration(pclass.operations, portClassName)»
			«ENDIF»
			
			  // outgoing messages
			«FOR m : pc.getOutgoing(conj)»
			  	«sendMessageDeclaration(m,conj)»
			«ENDFOR»
		};
		
		//------------------------------------------------------------------------------------------------------------
		// «IF conj»conjugated «ENDIF»replicated port class
		//------------------------------------------------------------------------------------------------------------
		class «replPortClassName» {
			private:
			    int m_replication;
			    std::vector<«portClassName»> m_ports;
		
			public:
				«replPortClassName»(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, std::vector<etRuntime::Address> addr, std::vector<etRuntime::Address> peerAddress);
				virtual ~«replPortClassName»() {};
				
				int getReplication() {	return m_replication; }
				int getIndexOf(const etRuntime::InterfaceItemBase& ifitem){ return ifitem.getIdx();	}
				«portClassName» get(int i) {return m_ports.at(i);}
				
				 virtual void receive(etRuntime::Message* m);
				«IF pc.commType==CommunicationType::EVENT_DRIVEN»
					 // outgoing messages
					«FOR m : pc.getOutgoing(conj)»
					  	«sendMessageDeclaration(m,conj)»
					«ENDFOR»
				«ENDIF»
				
		};
	'''
	}

	def portClassImplementation(ProtocolClass pc, Boolean conj) {
		var pclass = pc.getPortClass(conj)
		var portClassName = pc.getPortClassName(conj)
		var replPortClassName = pc.getPortClassName(conj, true)
	'''
	//------------------------------------------------------------------------------------------------------------
	// «IF conj»conjugated «ENDIF»port class
	//------------------------------------------------------------------------------------------------------------
	
	«pc.name»::«portClassName»::«portClassName»(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, Address addr, Address peerAddress)
		: PortBase(actor, parent, name, localId, 0, addr, peerAddress)
	{
		DebuggingService::getInstance().addPortInstance(*this);
	}

	«pc.name»::«portClassName»::«portClassName»(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, int idx, Address addr, Address peerAddress)
		: PortBase(actor, parent, name, localId, idx, addr, peerAddress)
	{
		DebuggingService::getInstance().addPortInstance(*this);
	}
		
	void «pc.name»::«portClassName»::receive(Message* msg) {
		if (! Events::isValidIncomingEvtID(msg->getEvtId())) {
			std::cout << "unknown" << std::endl;
		}
		else {
			if (msg->hasDebugFlagSet()) {			// TODO: model switch for activation of this flag
				DebuggingService::getInstance().addMessageAsyncIn(getPeerAddress(), getAddress(), Events::getMessageString(msg->getEvtId()));
			}
			
			«IF pc.handlesReceive(conj)»
			switch (msg.getEvtId()) {
				«FOR hdlr : pc.getReceiveHandlers(conj)»
					case «hdlr.msg.getCodeName()»:
					{
						«FOR command : hdlr.detailCode.commands»
							«command»
						«ENDFOR»
					}
					break;
				«ENDFOR»
				default:
			«ENDIF»	getActor().receiveEvent(*this, msg->getEvtId(),	msg->getData());
			«IF pc.handlesReceive(conj)»
			}
			«ENDIF»
		}
	};

	«IF pclass!=null»
		«helpers.operationsImplementation(pclass.operations, portClassName)»
	«ENDIF»
			
	// sent messages
	«FOR m : pc.getOutgoing(conj)»
		«sendMessage(m, pc.name + "::" + portClassName, conj)»
	«ENDFOR»
		
	//------------------------------------------------------------------------------------------------------------
	// «IF conj»conjugated «ENDIF»replicated port class
	//------------------------------------------------------------------------------------------------------------
	«pc.name»::«replPortClassName»::«replPortClassName»(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, std::vector<Address> addr, std::vector<Address> peerAddress) 
		: m_replication(addr.size()),
	  	  m_ports()
	{
		char numstr[10]; // enough to hold all numbers up to 32-bits
	
		m_ports.reserve(m_replication);
		for (int i = 0; i < m_replication; ++i) {
			snprintf(numstr, sizeof(numstr), "%d", i);
			m_ports.push_back(«portClassName»(actor, parent, name + numstr, localId, i, addr[i], peerAddress[i]));
		}
	};
	
		
	// outgoing messages
	«FOR m : pc.getOutgoing(conj)»
	«messageSignatureDefinition(m, pc.name + "::" + replPortClassName)»{
		for (int i=0; i<m_replication; ++i) {
			m_ports.at(i).«messageCall(m)»;
		}
	}
	«ENDFOR»
	'''
	}
	
	def private generateSourceFile(Root root, ProtocolClass pc) {'''
		/**
		 * @author generated by eTrice
		 *
		 * Source File of ProtocolClass «pc.name»
		 * 
		 */

		#include "«pc.getCppHeaderFileName»"
		#include "common/debugging/DebuggingService.h"
		#include <iostream>

		using namespace etRuntime;
		
		«helpers.userCode(pc.userCode3)»
		
	«IF pc.commType==CommunicationType::EVENT_DRIVEN»
		«helpers.userCode(pc.userCode2)»
	
		«portClassImplementation(pc, false)»
		«portClassImplementation(pc, true)»
		
		/*--------------------- debug helpers */
		«generateDebugHelpersImplementation(root, pc)»
	«ENDIF»
		
		
	'''
	}
	

	
	def private genDataDrivenPortHeaders(ProtocolClass pc) {
		var sentMsgs = pc.allIncomingMessages.filter(m|m.data!=null)
		
		'''
			/* data driven send port (conjugated) */
			typedef struct {
				«FOR msg : sentMsgs»
					«var typeName = msg.data.refType.type.typeName»
					«var refp = if (msg.data.refType.ref) "*" else ""»
					«typeName»«refp» «msg.name»;
				«ENDFOR»
			}
			«pc.getPortClassName(true)»;
			
			/* data driven receive port (regular) */
			typedef struct {
				const «pc.getPortClassName(true)»* peer;
			}
			«pc.getPortClassName(false)»;
			
			«FOR message : sentMsgs»
				«var hasData = message.data!=null»
				«var typeName = if (hasData) message.data.refType.type.typeName else ""»
				«var refp = if (hasData && !(message.data.refType.type instanceof PrimitiveType)) "*" else ""»
				«var data = if (hasData) ", "+typeName+refp+" data" else ""»
				«messageSetterSignature(pc.getPortClassName(true), message.name, data)»;
				«messageGetterSignature(pc.getPortClassName(false), message.name, typeName)»;
				
			«ENDFOR»
		'''
	}
	def private genDataDrivenPortSources(ProtocolClass pc) {
		var messages = pc.allIncomingMessages.filter(m|m.data!=null)
	'''
			«FOR message : messages»
				«var typeName =message.data.refType.type.typeName»
				«var refp = if (!(message.data.refType.type instanceof PrimitiveType)) "*" else ""»
				«var refa = if ((message.data.refType.type instanceof PrimitiveType)) "&" else ""»
				«var data = ", "+typeName+refp+" data"»
				«messageSetterSignature(pc.getPortClassName(true), message.name, data)» {
					self->«message.name» = data;
				}
				«messageGetterSignature(pc.getPortClassName(false), message.name, typeName)» {
					return self->peer->«message.name»;
				}
				
			«ENDFOR»
	'''
	} 
	
	
	
	def private messageSetterSignature(String className, String messageName, String data) {
		"void "+className+"_"+messageName+"_set("+className+"* self"+data+")"
	}
	
	def private messageGetterSignature(String className, String messageName, String type) {
		type+" "+className+"_"+messageName+"_get(const "+className+"* const self)"
	}

	def private messageCall(Message m) {
	'''«m.name»(«IF m.data!=null» «m.data.name»«ENDIF»)'''
	}
	

	def private genReceiveHandlers(ProtocolClass pc, Boolean conj){
	var portClassName = pc.getPortClassName(conj)
	var replPortClassName = pc.getPortClassName(conj, true)
	
	'''
	/* receiver handlers */
	«FOR h:getReceiveHandlers(pc,conj)»
		void «portClassName»_«h.msg.name»_receiveHandler(«portClassName»* self, const etMessage* msg, void * actor, etActorReceiveMessage receiveMessageFunc){
			«userCode(h.detailCode)»
			/* hand over the message to the actor:      */
			/* (*receiveMessageFunc)(actor, self, msg); */
		}
	«ENDFOR»
	'''}	

	
	
	def private generateDebugHelpersImplementation(Root root, ProtocolClass pc){'''
		
«««		TODO: make this optional or different for smaller footprint
		/* message names as strings for debugging (generate MSC) */
		std::string «pc.name»::Events::s_messageStrings[] 
				= {"MIN", 
				   «FOR m : pc.getAllOutgoingMessages()»
				   "«m.name»",
				   «ENDFOR» 
				   «FOR m : pc.getAllIncomingMessages()»
				   "«m.name»",
				   «ENDFOR»
				   "MAX"};
		
		std::string «pc.name»::Events::getMessageString(int msg_id) {
			if ((MSG_MIN < msg_id ) && ( msg_id < MSG_MAX )) {
				return s_messageStrings[msg_id];
			} else {
				// id out of range
				return "Message ID out of range";
			}
		}
		
		'''
	}
	 
	//----------------------------------------------------
	// from java generator
	//---------------------------------------------------
	def messageSignature(Message m) {
		'''«IF m.priv»private:«ELSE»public:«ENDIF» void «m.name»(«IF m.data!=null»«m.data.refType.type.typeName» «m.data.name»«ENDIF»)'''
	}

	def messageSignatureExplicit(Message m) {
		var dc = (m.data.refType.type as DataClass)
		'''public: void «m.name»(«IF dc.base!=null»«dc.base.typeName» _super, «ENDIF»«FOR a : dc.attributes SEPARATOR ", "»«a.refType.type.typeName»«IF a.size>1»[]«ENDIF» «a.name»«ENDFOR»)'''
	}

	def messageSignatureDefinition(Message m, String classPrefix) {
		'''void «classPrefix»::«m.name»(«IF m.data!=null»«m.data.refType.type.typeName» «m.data.name»«ENDIF»)'''
	}

	def messageSignatureExplicitDefinition(Message m, String classPrefix) {
		var dc = (m.data.refType.type as DataClass)
		'''void «classPrefix»::«m.name»(«IF dc.base!=null»«dc.base.typeName» _super, «ENDIF»«FOR a : dc.attributes SEPARATOR ", "»«a.refType.type.typeName»«IF a.size>1»[]«ENDIF» «a.name»«ENDFOR»)'''
	}

//	def messageCall(Message m) {
//		'''«m.name»(«IF m.data!=null» «m.data.name»«ENDIF»)'''
//	}
	
	def sendMessageDeclaration(Message m, boolean conj) {
		'''
			«messageSignature(m)»;
			«IF m.data!=null && m.data.refType.type instanceof DataClass»
				«messageSignatureExplicit(m)»;
			«ENDIF»
		'''
	}
	
	def sendMessage(Message m, String classPrefix, boolean conj) {
		var dir = if (conj) "IN" else "OUT"
		var hdlr = m.getSendHandler(conj)
		'''
			«messageSignatureDefinition(m, classPrefix)» {
				«IF hdlr!=null»
					«FOR command : hdlr.detailCode.commands»	«command»
					«ENDFOR»
				«ELSE»
					DebuggingService::getInstance().addMessageAsyncOut(getAddress(), getPeerAddress(),
																	   Events::getMessageString(Events::«dir»_«m.name»));
					if (getPeerAddress().isValid()){
						«IF m.data==null»getPeerMsgReceiver()->receive(new Message(getPeerAddress(), Events::«dir»_«m.name»));
						«ELSE»getPeerMsgReceiver()->receive(new Message(getPeerAddress(),Events::«dir»_«m.name», reinterpret_cast<void*>(«IF (m.data.refType.ref && !(m.data.refType.type instanceof PrimitiveType))»&«ENDIF»«m.data.name»), sizeof()));
						«ENDIF»
					}
				«ENDIF»
			}
			«IF m.data!=null && m.data.refType.type instanceof DataClass»
				«messageSignatureExplicitDefinition(m, classPrefix)» {
					«m.name»(new «m.data.refType.type.name»(«IF (m.data.refType.type as DataClass).base!=null»_super, «ENDIF»«FOR a : (m.data.refType.type as DataClass).attributes SEPARATOR ", "»«a.name»«ENDFOR»));
				}
			«ENDIF»
		'''
	}
}