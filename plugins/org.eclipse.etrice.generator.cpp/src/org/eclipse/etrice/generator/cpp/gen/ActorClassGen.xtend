/*******************************************************************************
 * Copyright (c) 2011 Draeger Medical GmbH (http://www.draeger.com).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * CONTRIBUTORS:
 * 		Peter Karlitschek (initial contribution)
 *
 *******************************************************************************/

package org.eclipse.etrice.generator.cpp.gen

import com.google.inject.Inject
import com.google.inject.Singleton
import java.util.ArrayList
import java.util.Map
import org.eclipse.etrice.core.fsm.fSM.ComponentCommunicationType
import org.eclipse.etrice.core.genmodel.builder.GenmodelConstants
import org.eclipse.etrice.core.genmodel.etricegen.ExpandedActorClass
import org.eclipse.etrice.core.genmodel.etricegen.Root
import org.eclipse.etrice.core.genmodel.etricegen.WiredActorClass
import org.eclipse.etrice.core.room.ActorClass
import org.eclipse.etrice.generator.cpp.Main
import org.eclipse.etrice.generator.fsm.base.FileSystemHelpers
import org.eclipse.etrice.generator.fsm.base.IGeneratorFileIo
import org.eclipse.etrice.generator.generic.GenericActorClassGenerator
import org.eclipse.etrice.generator.generic.ProcedureHelpers
import org.eclipse.etrice.generator.generic.RoomExtensions
import org.eclipse.etrice.generator.generic.TypeHelpers

@Singleton
class ActorClassGen extends GenericActorClassGenerator {

	@Inject IGeneratorFileIo fileIO
	@Inject extension CppExtensions
	@Inject extension RoomExtensions

	@Inject extension ProcedureHelpers
	@Inject extension Initialization
	@Inject extension StateMachineGen
	@Inject extension TypeHelpers
	@Inject extension FileSystemHelpers

	def doGenerate(Root root) {
		val Map<ActorClass, WiredActorClass> ac2wired = newHashMap
		root.wiredInstances.filter(typeof(WiredActorClass)).forEach[ac2wired.put(actorClass, it)]
		for (xpac: root.xpActorClasses.filter(cl|cl.actorClass.isValidGenerationLocation)) {
			val wired = ac2wired.get(xpac.actorClass)
			val manualBehavior = xpac.actorClass.isBehaviorAnnotationPresent("BehaviorManual")
			val path = xpac.actorClass.generationTargetPath+xpac.actorClass.getPath
			val infopath = xpac.actorClass.generationInfoPath+xpac.actorClass.getPath
			var file = if (manualBehavior) 'Abstract' else ''
			fileIO.generateFile("generating ActorClass declaration", path, infopath, file + xpac.actorClass.getCppHeaderFileName, root.generateHeaderFile(xpac, wired, manualBehavior))
			fileIO.generateFile("generating ActorClass implementation", path, infopath, file + xpac.actorClass.getCppSourceFileName, root.generateSourceFile(xpac, wired, manualBehavior))
		}
	}

	def private generateHeaderFile(Root root, ExpandedActorClass xpac, WiredActorClass wired, boolean manualBehavior) {
		val ac = xpac.actorClass
		val clsname = if (manualBehavior) "Abstract"+ac.name else ac.name
		//val models = root.getReferencedModels(ac)
		val rtBaseClassName = ac.actorBase?.name ?: 'etRuntime::ActorClassBase'

	'''
		/**
		 * @author generated by eTrice
		 *
		 * Header File of ActorClass «clsname»
		 *
		 */

		«generateIncludeGuardBegin(clsname)»

		#include "etDatatypes.h"
		#include "common/messaging/IRTObject.h"
		#include "common/modelbase/PortBase.h"
		#include "common/modelbase/InterfaceItemBase.h"
		#include "common/modelbase/ActorClassBase.h"
		#include "common/modelbase/SubSystemClassBase.h"
		#include "common/messaging/Address.h"
		#include "common/messaging/IMessageReceiver.h"
		#include "common/debugging/DebuggingService.h"
		#include <string>
		#include <vector>

		«FOR pc : root.getReferencedProtocolClasses(ac)»
			#include "«pc.path»«pc.name».h"
		«ENDFOR»
		«FOR dc : root.getReferencedDataClasses(ac)»
			#include "«dc.path»«dc.name».h"
		«ENDFOR»

		using namespace etRuntime; //TODO JH remove

		«ac.userCode(1, true)»

		class «clsname» : public «rtBaseClassName» {


			protected:
				//--------------------- ports
				«FOR ep : ac.getEndPorts»
					«ep.getPortClassName» «ep.name»;
				«ENDFOR»

				//--------------------- saps
				«FOR sap : ac.serviceAccessPoints»
					«sap.getPortClassName» «sap.name»;
				«ENDFOR»

				//--------------------- services
				«FOR svc : ac.serviceImplementations»
					«svc.getPortClassName» «svc.spp.name»;
				«ENDFOR»

				//--------------------- interface item IDs
				«xpac.genInterfaceItemConstants»

				«ac.attributes.attributes»

				«operationsDeclaration(ac.operations, ac.name)»

			public:
				//--------------------- construction
				«ac.name»(etRuntime::IRTObject* parent, const std::string& name);

«««	TODO: check whether attribute setters/getters are necessary at all, if yes own cpp implementation is needed for *,[],& variables
«««				«attributeSettersGettersImplementation(ac.attributes, ac.name)»
				//--------------------- port getters
				«ac.endPorts.map[getterImplementation(portClassName+'&', name, clsname)].join(NEWLINE)»

				«ac.serviceAccessPoints.map[getterImplementation(portClassName+'&', name, clsname)].join(NEWLINE)»

				«ac.serviceImplementations.map[getterImplementation(portClassName+'&', spp.name, clsname)].join(NEWLINE)»

				//--------------------- lifecycle functions
				virtual void destroy();

				«IF ac.hasNonEmptyStateMachine»
					«xpac.genStateMachineConstants»

					«xpac.genStateMachineMethods(false)»
					«IF ac.commType == ComponentCommunicationType::DATA_DRIVEN»
						void receiveEvent(etRuntime::InterfaceItemBase* ifitem, int evt, void* generic_data);
					«ENDIF»
					«IF ac.commType == ComponentCommunicationType::ASYNCHRONOUS || ac.commType == ComponentCommunicationType::DATA_DRIVEN»
						virtual void receive(const etRuntime::Message* msg);
					«ENDIF»
				«ELSEIF xpac.stateMachine.empty»
«««					no state machine in the super classes
					//--------------------- no state machine
					virtual void receiveEvent(etRuntime::InterfaceItemBase* ifitem, int evt, void* data);
					virtual void executeInitTransition() {}
				«ENDIF»

				«ac.userCode(2, false)»

		};


		«generateIncludeGuardEnd(ac.name)»
	'''
	}

	def private generateConstructorInitalizerList(ActorClass ac) {
		var initializerList = new ArrayList<CharSequence>();
		initializerList.add('''«ac.actorBase?.name ?: 'ActorClassBase'»(parent, name)''')

	    // own ports
		for ( ep : ac.getEndPorts() ) {
			initializerList.add('''«ep.name»(this, "«ep.name»", IFITEM_«ep.name»)''');
		}
		// own saps
		for ( sap : ac.serviceAccessPoints ) {
			initializerList.add('''«sap.name»(this, "«sap.name»", IFITEM_«sap.name»)''');
		}
		// own service implementations
		for (svc : ac.serviceImplementations) {
			initializerList.add('''«svc.spp.name»(this, "«svc.spp.name»", IFITEM_«svc.spp.name»)''');
		}
		for (attrib: ac.attributes) {
			initializerList.add(attrib.attributeInitialization(false))
		}

		initializerList.join(',' + NEWLINE)
	}


	def private generateSourceFile(Root root, ExpandedActorClass xpac, WiredActorClass wired, boolean manualBehavior) {
		val ac = xpac.actorClass
		val clsname = if (manualBehavior) "Abstract"+ac.name else ac.name
		//val models = root.getReferencedModels(ac)
		val rtBaseClassName = ac.actorBase?.name ?: 'ActorClassBase'

		'''
		/**
		 * @author generated by eTrice
		 *
		 * Source File of ActorClass «ac.name»
		 *
		 */

		#include "«ac.getCppHeaderFileName»"

		#include "common/messaging/RTObject.h"
		#include "common/messaging/RTServices.h"
		#include "etDatatypes.h"
		#include "etUnit/etUnit.h"
		#include <iostream>
		#include <string>

		«FOR ar : ac.actorRefs»
			#include "«ar.type.path»«ar.type.name».h"
		«ENDFOR»

		using namespace etRuntime;


		«clsname»::«clsname»(etRuntime::IRTObject* parent, const std::string& name) :
				«ac.generateConstructorInitalizerList»
		{
			«IF ac.hasNonEmptyStateMachine»
				for (int i = 0; i < s_numberOfStates; i++) {
					history[i] = NO_STATE;
				}
			«ENDIF»
			setClassName("«ac.name»");
			«ac.attributes.attributeInitialization(false)»

			// sub actors
			«FOR sub : ac.actorRefs»
				«IF sub.multiplicity>1»
					for (int i=0; i<«sub.multiplicity»; ++i) {
						«IF Main::settings.generateMSCInstrumentation»
							DebuggingService::getInstance().addMessageActorCreate(*this, "«sub.name»«GenmodelConstants::INDEX_SEP»"+i);
						«ENDIF»
						new «sub.type.name»(this, "«sub.name»«GenmodelConstants::INDEX_SEP»"+i);
					}
				«ELSE»
					«IF Main::settings.generateMSCInstrumentation»
						DebuggingService::getInstance().addMessageActorCreate(*this, "«sub.name»");
					«ENDIF»
					new «sub.type.name»(this, "«sub.name»");
				«ENDIF»
			«ENDFOR»

			// wiring
			«FOR wire: wired.wires»
				«if (wire.dataDriven) "DataPortBase" else "InterfaceItemBase"»::connect(this, "«wire.path1.join('/')»", "«wire.path2.join('/')»");
			«ENDFOR»

			«IF ac.commType == ComponentCommunicationType::ASYNCHRONOUS || ac.commType == ComponentCommunicationType::DATA_DRIVEN»
				// activate polling for data-driven communication
				RTServices::getInstance().getMsgSvcCtrl().getMsgSvc(getThread())->addPollingMessageReceiver(*this);
			«ENDIF»

			«ac.userStructorBody(true)»
		}

		void «ac.name»::destroy(){
			«ac.userStructorBody(false)»
			«IF Main::settings.generateMSCInstrumentation»
				DebuggingService::getInstance().addMessageActorDestroy(*this);
			«ENDIF»
			«IF ac.commType == ComponentCommunicationType::ASYNCHRONOUS || ac.commType == ComponentCommunicationType::DATA_DRIVEN»
				RTServices::getInstance().getMsgSvcCtrl().getMsgSvc(getThread())->removePollingMessageReceiver(*this);
			«ENDIF»
			«rtBaseClassName»::destroy();
		}

		«operationsImplementation(ac.operations, ac.name)»

		«IF ac.hasNonEmptyStateMachine»
			«xpac.genStateMachineMethods(true)»
			«IF ac.commType == ComponentCommunicationType::DATA_DRIVEN»
				void «ac.name»::receiveEvent(InterfaceItemBase* ifitem, int evt, void* generic_data) {
					handleSystemEvent(ifitem, evt, generic_data);
				}
			«ENDIF»
			«IF ac.commType == ComponentCommunicationType::ASYNCHRONOUS || ac.commType == ComponentCommunicationType::DATA_DRIVEN»
				void «ac.name»::receive(const Message* msg) {
					«IF ac.commType == ComponentCommunicationType::ASYNCHRONOUS»
						receiveEvent(0, -1, 0);
					«ELSE»
						receiveEventInternal();
					«ENDIF»
				}
			«ENDIF»
		«ELSEIF xpac.stateMachine.empty»
«««			no state machine in the super classes
			//--------------------- no state machine
			void «ac.name»::receiveEvent(InterfaceItemBase* ifitem, int evt, void* data) {
				handleSystemEvent(ifitem, evt, data);
			}
		«ENDIF»
		'''
	}


}
