/*******************************************************************************
 * Copyright (c) 2011 protos software gmbh (http://www.protos.de).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * CONTRIBUTORS:
 * 		Henrik Rentz-Reichert (initial contribution)
 * 
 *******************************************************************************/

package org.eclipse.etrice.generator.cpp.gen

import com.google.inject.Inject
import com.google.inject.Singleton
import org.eclipse.etrice.core.room.ActorClass
import org.eclipse.etrice.core.genmodel.base.ILogger
import org.eclipse.etrice.core.genmodel.etricegen.ExpandedActorClass
import org.eclipse.etrice.core.genmodel.etricegen.Root
import org.eclipse.xtext.generator.JavaIoFileSystemAccess
import static extension org.eclipse.etrice.core.room.util.RoomHelpers.*

import org.eclipse.etrice.generator.base.AbstractGenerator
import org.eclipse.etrice.generator.generic.RoomExtensions
import org.eclipse.etrice.generator.generic.ProcedureHelpers
import org.eclipse.etrice.generator.generic.GenericActorClassGenerator
import java.util.ArrayList
import org.eclipse.xtend2.lib.StringConcatenation
import org.eclipse.etrice.core.room.Port
import org.eclipse.etrice.core.room.SAPRef
import org.eclipse.etrice.core.room.SPPRef

@Singleton
class ActorClassGen extends GenericActorClassGenerator {
	
	@Inject JavaIoFileSystemAccess fileAccess
	@Inject extension CppExtensions
	@Inject extension RoomExtensions
	
	@Inject extension ProcedureHelpers
//	@Inject extension StateMachineGen
	@Inject ILogger logger
	
	def doGenerate(Root root) {
		for (xpac: root.xpActorClasses) {
			var path = xpac.actorClass.generationTargetPath+xpac.actorClass.getPath

			logger.logInfo("generating ActorClass header '"+xpac.actorClass.getCppHeaderFileName+"' in '"+path+"'")
			fileAccess.setOutputPath(path)
			fileAccess.generateFile(xpac.actorClass.getCppHeaderFileName, root.generateHeaderFile(xpac, xpac.actorClass))

			logger.logInfo("generating ActorClass source '"+xpac.actorClass.getCppSourceFileName+"' in '"+path+"'")
			fileAccess.setOutputPath(path)
			fileAccess.generateFile(xpac.actorClass.getCppSourceFileName, root.generateSourceFile(xpac, xpac.actorClass))
			
		}
	}
	
	def generateHeaderFile(Root root, ExpandedActorClass xpac, ActorClass ac) {
		val ctor = ac.operations.filter(op|op.constructor).head
		val dtor = ac.operations.filter(op|op.destructor).head
		
	'''
			/**
		 * @author generated by eTrice
		 *
		 * Header File of ActorClass «ac.name»
		 * 
		 */

		«generateIncludeGuardBegin(ac.name)»
	
		#include "platforms/generic/etDatatypes.h"
		#include "common/messaging/IRTObject.h"
		#include "common/modelbase/PortBase.h"
		#include "common/modelbase/InterfaceItemBase.h"
		#include "common/modelbase/ActorClassBase.h"
		#include "common/modelbase/SubSystemClassBase.h"
		#include "common/messaging/Address.h"
		#include "common/messaging/IMessageReceiver.h"
		#include "common/debugging/DebuggingService.h"
		#include <string>
		#include <vector>
		
		«FOR model : root.getReferencedModels(ac)»
			#include "«model.name».h"
		«ENDFOR»
		
		«FOR pc : root.getReferencedProtocolClasses(ac)»
			#include "«pc.^package»/«pc.name».h"
		«ENDFOR»
		
		«ac.userCode(1)»
		
		
		class «ac.name» : public «IF ac.base!=null»«ac.base.name»«ELSE»etRuntime::ActorClassBase«ENDIF» {
		
			
			protected:
				//--------------------- ports
				«ac.endPorts.map(port | '''«port.portClassName» «port.name»;''').join()»
				//--------------------- saps
				«ac.strSAPs.map(sap | '''«sap.portClassName» «sap.name»;''').join()»
				//--------------------- services
				«ac.serviceImplementations.map(svc | '''«svc.portClassName» «svc.spp.name»;''').join()»
			
				//--------------------- interface item IDs
				«genInterfaceItemConstants(xpac, ac)»
					
				«ac.attributes.attributes»
				«ac.operationsImplementation»
		
			//--------------------- construction
			public:
				«ac.name»(etRuntime::IRTObject* parent, std::string name, std::vector<std::vector<etRuntime::Address>*> port_addr, 
																		  std::vector<std::vector<etRuntime::Address>*> peer_addr)
				:«ac.generateConstructorInitalizerList»
				{
					setClassName("«ac.name»");
				
					«ac.attributes.attributeInitialization(false)»
				
					«IF ctor!=null»
					{
						// user defined constructor body
						«AbstractGenerator::getInstance().getTranslatedCode(ctor.detailCode)»
					}
					«ENDIF»
				}
			«attributeSettersGettersImplementation(ac.attributes, ac.name)»
			//--------------------- port getters
			«FOR ep : ac.getEndPorts()»
				«ep.portClassName.getterImplementation(ep.name, ac.name)»
			«ENDFOR»
			«FOR sap : ac.strSAPs»
				«sap.portClassName.getterImplementation(sap.name, ac.name)»
			«ENDFOR»
			«FOR svc : ac.serviceImplementations»
				«svc.portClassName.getterImplementation(svc.spp.name, ac.name)»
			«ENDFOR»
		
			//--------------------- lifecycle functions
			public:
			void init(){
				initUser();
			}
		
			void start(){
				startUser();
			}
		
			«IF !ac.overridesStop()»
			void stop(){
				stopUser();
			}
			«ENDIF»
			
			void destroy(){
				«IF dtor!=null»
					
						// user defined destructor body
						«AbstractGenerator::getInstance().getTranslatedCode(dtor.detailCode)»
				«ENDIF»
			}
		
			«IF ac.hasNonEmptyStateMachine»
«««				«xpac.genStateMachine()»
			«ELSEIF !xpac.hasStateMachine()»
				//--------------------- no state machine
				public: 
				void receiveEvent(etRuntime::InterfaceItemBase ifitem, int evt, void* data) {
					handleSystemEvent(ifitem, evt, data);
				}
				
				void executeInitTransition(){
				}
			«ENDIF»

			«ac.userCode(2)»

		};
		
		
		«generateIncludeGuardEnd(ac.name)»
	'''
	}
	def generateConstructorInitalizerList(ActorClass ac) { 
		var initializerList = new ArrayList<CharSequence>();
		if (ac.base==null) {
			initializerList.add('''etRuntime::ActorClassBase(parent, name, (*port_addr[0])[0], (*peer_addr[0])[0])''')
		}
		else {
			initializerList.add('''«ac.base.name»(parent, name, port_addr, peer_addr)''')
		}
	    // own ports
		for ( ep : ac.getEndPorts() ) {
			initializerList.add('''«ep.name»(this, "«ep.name»", IFITEM_«ep.name», «IF ep.multiplicity==1»0, «ENDIF»port_addr[IFITEM_«ep.name»]«IF ep.multiplicity==1»[0]«ENDIF», peer_addr[IFITEM_«ep.name»]«IF ep.multiplicity==1»[0]«ENDIF»)''');
		}
		// own saps
		for ( sap : ac.strSAPs ) {
			initializerList.add('''«sap.name»(this, "«sap.name»", IFITEM_«sap.name», 0, port_addr[IFITEM_«sap.name»][0], peer_addr[IFITEM_«sap.name»][0])''');
		}
		// own service implementations
		for (svc : ac.serviceImplementations) {
			initializerList.add('''«svc.spp.name»(this, "«svc.spp.name»", IFITEM_«svc.spp.name», port_addr[IFITEM_«svc.spp.name»], peer_addr[IFITEM_«svc.spp.name»])''');
		}
		return initializerList.join(',\n')
	}

	
	def generateSourceFile(Root root, ExpandedActorClass xpac, ActorClass ac) {
		''''''
	}
	
	
}