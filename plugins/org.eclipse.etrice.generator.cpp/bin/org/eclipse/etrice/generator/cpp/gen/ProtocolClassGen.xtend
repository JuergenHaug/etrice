/*******************************************************************************
 * Copyright (c) 2011 protos software gmbh (http://www.protos.de).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * CONTRIBUTORS:
 * 		Henrik Rentz-Reichert (initial contribution)
 * 		Thomas Schuetz (changed for C code generator)
 * 
 *******************************************************************************/

package org.eclipse.etrice.generator.cpp.gen

import com.google.inject.Inject
import com.google.inject.Singleton
import org.eclipse.etrice.core.room.CommunicationType
import org.eclipse.etrice.core.room.DataClass
import org.eclipse.etrice.core.room.Message
import org.eclipse.etrice.core.room.PrimitiveType
import org.eclipse.etrice.core.room.ProtocolClass

import org.eclipse.etrice.generator.generic.GenericProtocolClassGenerator
import org.eclipse.etrice.generator.generic.ProcedureHelpers
import org.eclipse.etrice.generator.generic.RoomExtensions
import org.eclipse.etrice.generator.generic.TypeHelpers

import org.eclipse.xtext.generator.JavaIoFileSystemAccess

import org.eclipse.etrice.core.genmodel.base.ILogger
import org.eclipse.etrice.core.genmodel.etricegen.Root


@Singleton
class ProtocolClassGen extends GenericProtocolClassGenerator {

	@Inject extension JavaIoFileSystemAccess fileAccess
	@Inject extension CppExtensions stdExt
	@Inject extension RoomExtensions roomExt
	@Inject extension ProcedureHelpers helpers
	@Inject extension TypeHelpers
	@Inject ILogger logger
	
	def doGenerate(Root root) { 
		for (pc: root.usedProtocolClasses) {
			var path = pc.generationTargetPath+pc.getPath

			logger.logInfo("generating ProtocolClass header '"+pc.getCppHeaderFileName+"' in '"+path+"'")
			fileAccess.setOutputPath(path)
			fileAccess.generateFile(pc.getCppHeaderFileName, root.generateHeaderFile(pc))

			logger.logInfo("generating ProtocolClass source '"+pc.getCppSourceFileName+"' in '"+path+"'")
			fileAccess.setOutputPath(path)
			fileAccess.generateFile(pc.getCppSourceFileName, root.generateSourceFile(pc))
		}
	}

	
	def private generateHeaderFile(Root root, ProtocolClass pc) {'''
		/**
		 * @author generated by eTrice
		 *
		 * Header File of ProtocolClass «pc.name»
		 * 
		 */

		«generateIncludeGuardBegin(pc.name)»
		
		#include "platforms/generic/etDatatypes.h"
		#include "common/modelbase/PortBase.h"
		#include "common/modelbase/InterfaceItemBase.h"
		#include "common/messaging/Address.h"
		#include "common/messaging/Message.h"
		#include <vector>
		
		namespace etRuntime {
			class IEventReceiver;
		}
		
		«helpers.userCode(pc.userCode1)»
		
		«FOR dataClass : root.getReferencedDataClasses(pc)»
			#include "«dataClass.name».h"
		«ENDFOR»

		class «pc.name» {
		   public:
		«IF pc.commType==CommunicationType::EVENT_DRIVEN»	   /* message IDs */
			  «genMessageIDs(pc)»
		«ELSEIF pc.commType==CommunicationType::DATA_DRIVEN»
		«ELSEIF pc.commType==CommunicationType::SYNCHRONOUS»
			#error "synchronous protocols not implemented yet"
		«ENDIF»
				«helpers.userCode(pc.userCode2)»
		
		   private:
				static char* messageStrings[];
		
		   public:
				char* getMessageString(int msg_id);
			 		
				«portClassDeclaration(pc, false)»
				«portClassDeclaration(pc, true)»
		};
		«generateIncludeGuardEnd(pc.name)»
	'''
	}
	
	def portClassDeclaration(ProtocolClass pc, Boolean conj) {
		var pclass = pc.getPortClass(conj)
		var portClassName = pc.getPortClassName(conj)
		var replPortClassName = pc.getPortClassName(conj, true)
	'''
		//------------------------------------------------------------------------------------------------------------
		// «IF conj»conjugated «ENDIF»port class
		//------------------------------------------------------------------------------------------------------------
		class «portClassName» : public etRuntime::PortBase {
			«IF pclass!=null»
				«helpers.userCode(pclass.userCode)»
			«ENDIF»
		   public:
			// constructors
			 «portClassName»(etRuntime::IEventReceiver actor, char* name, int localId, etRuntime::Address addr, etRuntime::Address peerAddress); 
			 «portClassName»(etRuntime::IEventReceiver actor, char* name, int localId, int idx, etRuntime::Address addr, etRuntime::Address peerAddress);
		
			 virtual void receive(etRuntime::Message m);
			«IF pclass!=null»
				«helpers.attributes(pclass.attributes)»
				«helpers.operationsDeclaration(pclass.operations, portClassName)»
			«ENDIF»
			
			  // sent messages
			«FOR m : pc.getOutgoing(conj)»
			  	«sendMessageDeclaration(m,conj)»
			«ENDFOR»
		};
		
		//------------------------------------------------------------------------------------------------------------
		// «IF conj»conjugated «ENDIF»replicated port class
		//------------------------------------------------------------------------------------------------------------
		class «replPortClassName» {
			private:
			 std::vector<«portClassName»> ports;
			 int replication;
		
			public:
			// constructor
			«replPortClassName»(etRuntime::IEventReceiver actor, char* name, int localId, std::vector<etRuntime::Address> addr, std::vector<etRuntime::Address> peerAddress);
			
			int getReplication() {	return replication; }
			int getIndexOf(const etRuntime::InterfaceItemBase& ifitem){ return ifitem.getIdx();	}
			«portClassName» get(int i) {return ports[i];}
			
		«IF pc.commType==CommunicationType::EVENT_DRIVEN»
			«IF conj»
				// incoming messages
				
			«FOR m : pc.getAllIncomingMessages()»	«messageSignature(m)»;
			«ENDFOR»
			«ELSE»
				// outgoing messages
			«FOR m : pc.getAllOutgoingMessages()»	«messageSignature(m)»;
			«ENDFOR»
			«ENDIF»
		«ELSEIF pc.commType==CommunicationType::DATA_DRIVEN»
			    /*--------------------- port structs and methods */
			«pc.genDataDrivenPortHeaders»
		«ELSEIF pc.commType==CommunicationType::SYNCHRONOUS»
			#error "synchronous protocols not implemented yet"
		«ENDIF»
			
		};
	'''
	}

	def portClassImplementation(ProtocolClass pc, Boolean conj) {
		var pclass = pc.getPortClass(conj)
		var portClassName = pc.getPortClassName(conj)
		var replPortClassName = pc.getPortClassName(conj, true)
	'''
	«pc.name»::«portClassName»::«portClassName»(IEventReceiver actor, char* name, int localId, Address addr, Address peerAddress)
		: PortBase(actor, name, localId, 0, addr, peerAddress)
	{
		DebuggingService::getInstance().addPortInstance(*this);
	}

	«pc.name»::«portClassName»::«portClassName»(IEventReceiver actor, char* name, int localId, int idx, Address addr, Address peerAddress)
		: PortBase(actor, name, localId, idx, addr, peerAddress)
	{
		DebuggingService::getInstance().addPortInstance(*this);
	}
		
	void «pc.name»::«portClassName»::receive(Message msg) {
		//if (!(m instanceof EventMessage)) return;
		//EventMessage msg = (EventMessage) m;
		if (msg.getEvtId() <= 0 || msg.getEvtId() >= MSG_MAX)
			printf("unknown");
		else {
			if (messageStrings[msg.getEvtId()] != "timerTick"){
«««							TODOTS: model switch for activation
				DebuggingService::getInstance().addMessageAsyncIn(getPeerAddress(), getAddress(), messageStrings[msg.getEvtId()]);
			}
		}
		«IF pc.handlesReceive(conj)»
		switch (msg.getEvtId()) {
			«FOR hdlr : pc.getReceiveHandlers(conj)»
				case «hdlr.msg.getCodeName()»:
				{
					«FOR command : hdlr.detailCode.commands»
						«command»
					«ENDFOR»
				}
				break;
			«ENDFOR»
			default:
		«ENDIF»	getActor().receiveEvent(*this, msg.getEvtId(), msg.getData());
		«IF pc.handlesReceive(conj)»
		}
		«ENDIF»
	}
	«IF pclass!=null»
		«helpers.operationsImplementation(pclass.operations, portClassName)»
	«ENDIF»
			
	// sent messages
	«FOR m : pc.getOutgoing(conj)»
		«sendMessage(m, pc.name + "::" + portClassName, conj)»
	«ENDFOR»
		
	//-------------------------------------------------------------------------------
	// replicated port class
	//-------------------------------------------------------------------------------
	«pc.name»::«replPortClassName»::«replPortClassName»(IEventReceiver actor, char* name, int localId, std::vector<Address> addr, std::vector<Address> peerAddress) {
		int replication = addr.size();
		ports = new std::vector<«pc.name»::«portClassName»>(replication);
		for (int i=0; i<replication; ++i) {
			ports[i] = new «pc.name»::«portClassName»(actor, name+i, localId, i, addr[i], peerAddress[i]);
		}
	}
		
	«IF conj»
	// incoming messages
	«FOR m : pc.getAllIncomingMessages()»
	«messageSignatureDefinition(m, pc.name + "::" + replPortClassName)»{
		for (int i=0; i<replication; ++i) {
			ports[i].«messageCall(m)»;
		}
	}
	«ENDFOR»
	«ELSE»
	// outgoing messages
	«FOR m : pc.getAllOutgoingMessages()»
	«messageSignatureDefinition(m, pc.name + "::" + replPortClassName)»{
		for (int i=0; i<replication; ++i) {
			ports[i].«messageCall(m)»;
		}
	}
	«ENDFOR»
	«ENDIF»
	'''
	}
	
	def private generateSourceFile(Root root, ProtocolClass pc) {'''
		/**
		 * @author generated by eTrice
		 *
		 * Source File of ProtocolClass «pc.name»
		 * 
		 */

		#include "«pc.getCppHeaderFileName»"
		#include "common/debugging/DebuggingService.h"
		#include <stdio.h>

		using namespace etRuntime;
		
		«helpers.userCode(pc.userCode3)»
		
	«IF pc.commType==CommunicationType::EVENT_DRIVEN»
		
		//----------------------------------------------
		// java code
		//----------------------------------------------
		
		«helpers.userCode(pc.userCode2)»
	
		char* «pc.name»::messageStrings[] = {"MIN", «FOR m : pc.getAllOutgoingMessages()»"«m.name»",«ENDFOR» «FOR m : pc.getAllIncomingMessages()»"«m.name»",«ENDFOR»"MAX"};
	
		char* «pc.name»::getMessageString(int msg_id) {
			if (msg_id<MSG_MIN || msg_id>MSG_MAX+1){
				// id out of range
				return "Message ID out of range";
			}
			else{
				return messageStrings[msg_id];
			}
		}
	
		«portClassImplementation(pc, false)»
		«portClassImplementation(pc, true)»
		
		/*--------------------- debug helpers */
		«generateDebugHelpersImplementation(root, pc)»
	«ELSEIF pc.commType==CommunicationType::DATA_DRIVEN»
		«pc.genDataDrivenPortSources»
	«ELSEIF pc.commType==CommunicationType::SYNCHRONOUS»
		#error "synchronoue protocols not implemented yet"
	«ENDIF»
		
		
	'''
	}
	
	def private portClassHeader(ProtocolClass pc, Boolean conj){
		var portClassName = pc.getPortClassName(conj)
		var replPortClassName = pc.getPortClassName(conj, true)
		var messages = if (conj) pc.allIncomingMessages else pc.allOutgoingMessages
		
		'''
		typedef etPort «portClassName»;
		typedef etReplPort «replPortClassName»;
		
		«IF pc.getPortClass(conj)!=null»	
			«IF !(pc.getPortClass(conj).attributes.empty)»
/* variable part of PortClass (RAM) */
typedef struct «portClassName»_var «portClassName»_var; 
struct «portClassName»_var {
	«helpers.attributes(pc.getPortClass(conj).attributes)»
	};
				«FOR a:pc.getPortClass(conj).attributes»
					«IF a.defaultValueLiteral!=null»
						«logger.logInfo(portClassName+" "+a.name+": Attribute initialization not supported in C")»
					«ENDIF»
				«ENDFOR»
			«ENDIF»
		«ENDIF»
			
		«FOR message : messages»
			«var hasData = message.data!=null»
			«var typeName = if (hasData) message.data.refType.type.typeName else ""»
			«var refp = if (hasData && (!(message.data.refType.type instanceof PrimitiveType)||(message.data.refType.ref))) "*" else ""»
			«var data = if (hasData) ", "+typeName+refp+" data" else ""»
			«messageSignature(portClassName, message.name, "", data)»;
			«messageSignature(replPortClassName, message.name, "_broadcast", data)»;
			«messageSignature(replPortClassName, message.name, "", ", int idx"+data)»;
		«ENDFOR»
			
		«IF (pc.getPortClass(conj) != null)»	
			«helpers.operationsDeclaration(pc.getPortClass(conj).operations, portClassName)»
			«helpers.operationsDeclaration(pc.getPortClass(conj).operations, replPortClassName)»
		«ENDIF»
		
 		«IF pc.handlesReceive(conj)»
			«FOR h:getReceiveHandlers(pc,conj)»
void «portClassName»_«h.msg.name»_receiveHandler(«portClassName»* self, const etMessage* msg, void * actor, etActorReceiveMessage receiveMessageFunc);
			«ENDFOR»
		«ENDIF»
		'''
	}


	
	def private genDataDrivenPortHeaders(ProtocolClass pc) {
		var sentMsgs = pc.allIncomingMessages.filter(m|m.data!=null)
		
		'''
			/* data driven send port (conjugated) */
			typedef struct {
				«FOR msg : sentMsgs»
					«var typeName = msg.data.refType.type.typeName»
					«var refp = if (msg.data.refType.ref) "*" else ""»
					«typeName»«refp» «msg.name»;
				«ENDFOR»
			}
			«pc.getPortClassName(true)»;
			
			/* data driven receive port (regular) */
			typedef struct {
				const «pc.getPortClassName(true)»* peer;
			}
			«pc.getPortClassName(false)»;
			
			«FOR message : sentMsgs»
				«var hasData = message.data!=null»
				«var typeName = if (hasData) message.data.refType.type.typeName else ""»
				«var refp = if (hasData && !(message.data.refType.type instanceof PrimitiveType)) "*" else ""»
				«var data = if (hasData) ", "+typeName+refp+" data" else ""»
				«messageSetterSignature(pc.getPortClassName(true), message.name, data)»;
				«messageGetterSignature(pc.getPortClassName(false), message.name, typeName)»;
				
			«ENDFOR»
		'''
	}
	def private genDataDrivenPortSources(ProtocolClass pc) {
		var messages = pc.allIncomingMessages.filter(m|m.data!=null)
	'''
			«FOR message : messages»
				«var typeName =message.data.refType.type.typeName»
				«var refp = if (!(message.data.refType.type instanceof PrimitiveType)) "*" else ""»
				«var refa = if ((message.data.refType.type instanceof PrimitiveType)) "&" else ""»
				«var data = ", "+typeName+refp+" data"»
				«messageSetterSignature(pc.getPortClassName(true), message.name, data)» {
					self->«message.name» = data;
				}
				«messageGetterSignature(pc.getPortClassName(false), message.name, typeName)» {
					return self->peer->«message.name»;
				}
				
			«ENDFOR»
	'''
	} 
	
	def private portClassSource(ProtocolClass pc, Boolean conj){
		var portClassName = pc.getPortClassName(conj)
		var replPortClassName = pc.getPortClassName(conj, true)
		var messages = if (conj) pc.allIncomingMessages else pc.allOutgoingMessages
		var dir = if (conj) "IN_" else "OUT_"

		'''
			«FOR message : messages»
				«var hasData = message.data!=null»
				«var typeName = if (hasData) message.data.refType.type.typeName else ""»
				«var refp = if (hasData && ((message.data.refType.ref))) "*" else ""»
				«var refpd = if (hasData && (!(message.data.refType.type instanceof PrimitiveType)||(message.data.refType.ref))) "*" else ""»
				«var refa = if (hasData && (!(message.data.refType.type instanceof PrimitiveType))&&(!(message.data.refType.ref))) "" else "&"»
				«var data = if (hasData) ", "+typeName+refpd+" data" else ""»
				«var dataCall = if (hasData) ", data" else ""»
				«var hdlr = message.getSendHandler(conj)»
				
				«messageSignature(portClassName, message.name, "", data)» {
					«IF hdlr != null»
						«FOR command : hdlr.detailCode.commands»	«command»
						«ENDFOR»									
					«ELSE»
						ET_MSC_LOGGER_SYNC_ENTRY("«portClassName»", "«message.name»")
							«sendMessageCall(hasData, "self", memberInUse(pc.name, dir+message.name), typeName+refp, refa+"data")»
						ET_MSC_LOGGER_SYNC_EXIT
					«ENDIF»
				}
				
				«messageSignature(replPortClassName, message.name, "_broadcast", data)» {
					«IF hdlr != null»
						int i;
						for (i=0; i<((etReplPort*)self)->size; ++i) {
							«portClassName»_«message.name»((etPort*)&((etReplPort*)self)->ports[i]«dataCall»);
						}					
					«ELSE»
						int i;
						ET_MSC_LOGGER_SYNC_ENTRY("«replPortClassName»", "«message.name»")
						for (i=0; i<((etReplPort*)self)->size; ++i) {
							«sendMessageCall(hasData, "((etPort*)&((etReplPort*)self)->ports[i])", memberInUse(pc.name, dir+message.name), typeName+refp, refa+"data")»
						}
						ET_MSC_LOGGER_SYNC_EXIT
					«ENDIF»
				}
				
				«messageSignature(replPortClassName, message.name, "", ", int idx"+data)» {
					«IF hdlr != null»
						«portClassName»_«message.name»((etPort*)&((etReplPort*)self)->ports[idx]«dataCall»);
					«ELSE»					
						ET_MSC_LOGGER_SYNC_ENTRY("«replPortClassName»", "«message.name»")
						if (0<=idx && idx<((etReplPort*)self)->size) {
							«sendMessageCall(hasData, "((etPort*)&((etReplPort*)self)->ports[idx])", memberInUse(pc.name, dir+message.name), typeName+refp, refa+"data")»
						}
						ET_MSC_LOGGER_SYNC_EXIT
					«ENDIF»
				}
			«ENDFOR»
			
			«IF (pc.getPortClass(conj) != null)»
				«helpers.operationsImplementation(pc.getPortClass(conj).operations, portClassName)»
				«helpers.operationsImplementation(pc.getPortClass(conj).operations, replPortClassName)»
			«ENDIF»

			// getReplication
			etInt32 «replPortClassName»_getReplication(const «replPortClassName»* self) {
				return ((etReplPort*)self)->size;
			}
			
			«IF pc.handlesReceive(conj)»
				«genReceiveHandlers(pc,conj)»
			«ENDIF»
			
		'''
	}

	def private sendMessageCall(boolean hasData, String self, String msg, String typeName, String data) {
		if (hasData)
			"etPort_sendMessage("+self+", "+msg+", sizeof("+typeName+"), "+data+");"
		else
			"etPort_sendMessage("+self+", "+msg+", 0, NULL);"
	}
	
	def private messageSignature(String className, String messageName, String methodSuffix, String data) {
		"void "+className+"_"+messageName+methodSuffix+"(const "+className+"* self"+data+")"
	}
	
	def private messageSetterSignature(String className, String messageName, String data) {
		"void "+className+"_"+messageName+"_set("+className+"* self"+data+")"
	}
	
	def private messageGetterSignature(String className, String messageName, String type) {
		type+" "+className+"_"+messageName+"_get(const "+className+"* const self)"
	}

	def private messageCall(Message m) {'''
	«m.name»(«IF m.data!=null» «m.data.name»«ENDIF»)
	'''}
	
//	def sendMessage(Message m, boolean conj) {'''
//	«var dir = if (conj) "IN" else "OUT"»
//	«var hdlr = m.getSendHandler(conj)»
//	«messageSignature(m)»{
//		if (getPeerAddress()!= 0)
//				«IF m.data==null»getPeerMsgReceiver().receive(new EventMessage(getPeerAddress(), «dir»_«m.name»));
//				«ELSE»getPeerMsgReceiver().receive(new EventWithDataMessage(getPeerAddress(), «dir»_«m.name», «m.data.name»«IF (!m.data.ref)».deepCopy()«ENDIF»));
//			«ENDIF»
//	}
//	'''
//	}
	
	def private genReceiveHandlers(ProtocolClass pc, Boolean conj){
	var portClassName = pc.getPortClassName(conj)
	var replPortClassName = pc.getPortClassName(conj, true)
	
	'''
	/* receiver handlers */
	«FOR h:getReceiveHandlers(pc,conj)»
		void «portClassName»_«h.msg.name»_receiveHandler(«portClassName»* self, const etMessage* msg, void * actor, etActorReceiveMessage receiveMessageFunc){
			«userCode(h.detailCode)»
			/* hand over the message to the actor:      */
			/* (*receiveMessageFunc)(actor, self, msg); */
		}
	«ENDFOR»
	'''}	

	
	
	def private generateDebugHelpersImplementation(Root root, ProtocolClass pc){'''
		
«««		TODO: make this optional or different for smaller footprint
		/* message names as strings for debugging (generate MSC) */
		static const char* «pc.name»_messageStrings[] = {"MIN", «FOR m : pc.getAllOutgoingMessages()»"«m.name»",«ENDFOR»«FOR m : pc.getAllIncomingMessages()»"«m.name»", «ENDFOR»"MAX"};

		const char* «pc.name»_getMessageString(int msg_id) {
			if (msg_id < «pc.name»::MSG_MIN || msg_id > «pc.name»::MSG_MAX+1){
				/* id out of range */
				return "Message ID out of range";
			}
			else{
				return «pc.name»_messageStrings[msg_id];
			}
		}
		'''
	}
	 
	//----------------------------------------------------
	// from java generator
	//---------------------------------------------------
	def messageSignature(Message m) {
		'''«IF m.priv»private:«ELSE»public:«ENDIF» void «m.name»(«IF m.data!=null»«m.data.refType.type.typeName» «m.data.name»«ENDIF»)'''
	}

	def messageSignatureExplicit(Message m) {
		var dc = (m.data.refType.type as DataClass)
		'''public: void «m.name»(«IF dc.base!=null»«dc.base.typeName» _super, «ENDIF»«FOR a : dc.attributes SEPARATOR ", "»«a.refType.type.typeName»«IF a.size>1»[]«ENDIF» «a.name»«ENDFOR»)'''
	}

	def messageSignatureDefinition(Message m, String classPrefix) {
		'''void «classPrefix»::«m.name»(«IF m.data!=null»«m.data.refType.type.typeName» «m.data.name»«ENDIF»)'''
	}

	def messageSignatureExplicitDefinition(Message m, String classPrefix) {
		var dc = (m.data.refType.type as DataClass)
		'''void «classPrefix»::«m.name»(«IF dc.base!=null»«dc.base.typeName» _super, «ENDIF»«FOR a : dc.attributes SEPARATOR ", "»«a.refType.type.typeName»«IF a.size>1»[]«ENDIF» «a.name»«ENDFOR»)'''
	}

//	def messageCall(Message m) {
//		'''«m.name»(«IF m.data!=null» «m.data.name»«ENDIF»)'''
//	}
	
	def sendMessageDeclaration(Message m, boolean conj) {
		'''
			«messageSignature(m)»;
			«IF m.data!=null && m.data.refType.type instanceof DataClass»
				«messageSignatureExplicit(m)»;
			«ENDIF»
		'''
	}
	def sendMessage(Message m, String classPrefix, boolean conj) {
		var dir = if (conj) "IN" else "OUT"
		var hdlr = m.getSendHandler(conj)
		'''
			«messageSignatureDefinition(m, classPrefix)» {
				«IF hdlr!=null»
					«FOR command : hdlr.detailCode.commands»	«command»
					«ENDFOR»
				«ELSE»
					if (messageStrings[ «dir»_«m.name»] != "timerTick"){
«««						TODOTS: model switch for activation
						DebuggingService::getInstance().addMessageAsyncOut(getAddress(), getPeerAddress(), messageStrings[«dir»_«m.name»]);
					}
					if (getPeerAddress().isValid()){
						«IF m.data==null»getPeerMsgReceiver().receive(new Message(getPeerAddress(), «dir»_«m.name»));
						«ELSE»getPeerMsgReceiver().receive(new Message(getPeerAddress(), «dir»_«m.name», reinterpret_cast<void*>(«IF (m.data.refType.ref && !(m.data.refType.type instanceof PrimitiveType))»&«ENDIF»«m.data.name»)));
					«ENDIF»
					}
				«ENDIF»
			}
			«IF m.data!=null && m.data.refType.type instanceof DataClass»
				«messageSignatureExplicitDefinition(m, classPrefix)» {
					«m.name»(new «m.data.refType.type.name»(«IF (m.data.refType.type as DataClass).base!=null»_super, «ENDIF»«FOR a : (m.data.refType.type as DataClass).attributes SEPARATOR ", "»«a.name»«ENDFOR»));
				}
			«ENDIF»
		'''
	}
}