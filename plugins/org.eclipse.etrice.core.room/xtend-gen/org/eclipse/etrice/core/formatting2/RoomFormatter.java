/**
 * generated by Xtext
 */
package org.eclipse.etrice.core.formatting2;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.inject.Inject;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.etrice.core.common.base.Annotation;
import org.eclipse.etrice.core.common.base.AnnotationType;
import org.eclipse.etrice.core.common.base.Documentation;
import org.eclipse.etrice.core.common.base.Import;
import org.eclipse.etrice.core.fsm.fSM.DetailCode;
import org.eclipse.etrice.core.fsm.fSM.ProtocolSemantics;
import org.eclipse.etrice.core.fsm.fSM.State;
import org.eclipse.etrice.core.fsm.fSM.StateGraph;
import org.eclipse.etrice.core.fsm.fSM.Transition;
import org.eclipse.etrice.core.fsm.fSM.Trigger;
import org.eclipse.etrice.core.fsm.fSM.TriggeredTransition;
import org.eclipse.etrice.core.fsm.formatting2.FSMFormatter;
import org.eclipse.etrice.core.room.ActorClass;
import org.eclipse.etrice.core.room.Attribute;
import org.eclipse.etrice.core.room.DataClass;
import org.eclipse.etrice.core.room.EnumerationType;
import org.eclipse.etrice.core.room.ExternalType;
import org.eclipse.etrice.core.room.GeneralProtocolClass;
import org.eclipse.etrice.core.room.Operation;
import org.eclipse.etrice.core.room.PortClass;
import org.eclipse.etrice.core.room.PrimitiveType;
import org.eclipse.etrice.core.room.RoomClass;
import org.eclipse.etrice.core.room.RoomModel;
import org.eclipse.etrice.core.room.SubSystemClass;
import org.eclipse.etrice.core.room.VarDecl;
import org.eclipse.etrice.core.services.RoomGrammarAccess;
import org.eclipse.xtext.AbstractRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import org.eclipse.xtext.formatting2.IHiddenRegionFormatter;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionsFinder;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

@SuppressWarnings("all")
public class RoomFormatter extends FSMFormatter {
  @Inject
  @Extension
  private RoomGrammarAccess _roomGrammarAccess;
  
  @Override
  public void formatAllByKeywords(final EObject it, @Extension final IFormattableDocument document) {
    super.formatAllByKeywords(it, document);
    ISemanticRegionsFinder _allRegionsFor = this.textRegionExtensions.allRegionsFor(it);
    List<ISemanticRegion> _keywords = _allRegionsFor.keywords("default", "void", "sends", "sub", "of", "and", "satisfied_by");
    final Consumer<ISemanticRegion> _function = (ISemanticRegion it_1) -> {
      final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it_2) -> {
        it_2.oneSpace();
      };
      document.surround(it_1, _function_1);
    };
    _keywords.forEach(_function);
    ISemanticRegionsFinder _allRegionsFor_1 = this.textRegionExtensions.allRegionsFor(it);
    List<ISemanticRegion> _keywords_1 = _allRegionsFor_1.keywords("/");
    final Consumer<ISemanticRegion> _function_1 = (ISemanticRegion it_1) -> {
      final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it_2) -> {
        it_2.noSpace();
      };
      document.surround(it_1, _function_2);
    };
    _keywords_1.forEach(_function_1);
    Grammar _grammar = this._roomGrammarAccess.getGrammar();
    List<AbstractRule> _allRules = GrammarUtil.allRules(_grammar);
    final Function1<AbstractRule, Iterable<Keyword>> _function_2 = (AbstractRule it_1) -> {
      TreeIterator<EObject> _eAllContents = it_1.eAllContents();
      Iterator<Keyword> _filter = Iterators.<Keyword>filter(_eAllContents, Keyword.class);
      final Function1<Keyword, Boolean> _function_3 = (Keyword it_2) -> {
        String _value = it_2.getValue();
        return Boolean.valueOf((!Objects.equal(_value, "ref")));
      };
      Iterator<Keyword> _filter_1 = IteratorExtensions.<Keyword>filter(_filter, _function_3);
      final Function1<Keyword, Boolean> _function_4 = (Keyword it_2) -> {
        String _value = it_2.getValue();
        char[] _charArray = _value.toCharArray();
        final Function1<Character, Boolean> _function_5 = (Character it_3) -> {
          return Boolean.valueOf(Character.isLetter((it_3).charValue()));
        };
        return Boolean.valueOf(IterableExtensions.<Character>forall(((Iterable<Character>)Conversions.doWrapArray(_charArray)), _function_5));
      };
      Iterator<Keyword> _filter_2 = IteratorExtensions.<Keyword>filter(_filter_1, _function_4);
      return IteratorExtensions.<Keyword>toIterable(_filter_2);
    };
    List<Iterable<Keyword>> _map = ListExtensions.<AbstractRule, Iterable<Keyword>>map(_allRules, _function_2);
    final Iterable<Keyword> textKeywords = Iterables.<Keyword>concat(_map);
    ISemanticRegionsFinder _allRegionsFor_2 = this.textRegionExtensions.allRegionsFor(it);
    List<ISemanticRegion> _keywords_2 = _allRegionsFor_2.keywords(((Keyword[])Conversions.unwrapArray(textKeywords, Keyword.class)));
    final Consumer<ISemanticRegion> _function_3 = (ISemanticRegion it_1) -> {
      final Procedure1<IHiddenRegionFormatter> _function_4 = (IHiddenRegionFormatter it_2) -> {
        it_2.oneSpace();
      };
      document.append(it_1, _function_4);
    };
    _keywords_2.forEach(_function_3);
  }
  
  protected void _format(final RoomModel it, @Extension final IFormattableDocument document) {
    this.formatAllByKeywords(it, document);
    EList<EObject> _eContents = it.eContents();
    EObject _head = IterableExtensions.<EObject>head(_eContents);
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it_1) -> {
      it_1.setNewLines(2);
    };
    document.<EObject>prepend(_head, _function);
    EList<EObject> _eContents_1 = it.eContents();
    Iterable<EObject> _tail = IterableExtensions.<EObject>tail(_eContents_1);
    Iterable<DataClass> _filter = Iterables.<DataClass>filter(_tail, DataClass.class);
    final Consumer<DataClass> _function_1 = (DataClass it_1) -> {
      final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it_2) -> {
        it_2.setNewLines(2);
      };
      document.<DataClass>prepend(it_1, _function_2);
    };
    _filter.forEach(_function_1);
    EList<EObject> _eContents_2 = it.eContents();
    Iterable<EObject> _tail_1 = IterableExtensions.<EObject>tail(_eContents_2);
    Iterable<GeneralProtocolClass> _filter_1 = Iterables.<GeneralProtocolClass>filter(_tail_1, GeneralProtocolClass.class);
    final Consumer<GeneralProtocolClass> _function_2 = (GeneralProtocolClass it_1) -> {
      final Procedure1<IHiddenRegionFormatter> _function_3 = (IHiddenRegionFormatter it_2) -> {
        it_2.setNewLines(2);
      };
      document.<GeneralProtocolClass>prepend(it_1, _function_3);
    };
    _filter_1.forEach(_function_2);
    EList<EObject> _eContents_3 = it.eContents();
    Iterable<EObject> _tail_2 = IterableExtensions.<EObject>tail(_eContents_3);
    Iterable<ActorClass> _filter_2 = Iterables.<ActorClass>filter(_tail_2, ActorClass.class);
    final Consumer<ActorClass> _function_3 = (ActorClass it_1) -> {
      final Procedure1<IHiddenRegionFormatter> _function_4 = (IHiddenRegionFormatter it_2) -> {
        it_2.setNewLines(2);
      };
      document.<ActorClass>prepend(it_1, _function_4);
    };
    _filter_2.forEach(_function_3);
    EList<EObject> _eContents_4 = it.eContents();
    Iterable<EObject> _tail_3 = IterableExtensions.<EObject>tail(_eContents_4);
    Iterable<SubSystemClass> _filter_3 = Iterables.<SubSystemClass>filter(_tail_3, SubSystemClass.class);
    final Consumer<SubSystemClass> _function_4 = (SubSystemClass it_1) -> {
      final Procedure1<IHiddenRegionFormatter> _function_5 = (IHiddenRegionFormatter it_2) -> {
        it_2.setNewLines(2);
      };
      document.<SubSystemClass>prepend(it_1, _function_5);
    };
    _filter_3.forEach(_function_4);
    EList<EObject> _eContents_5 = it.eContents();
    Iterable<EObject> _tail_4 = IterableExtensions.<EObject>tail(_eContents_5);
    Iterable<AnnotationType> _filter_4 = Iterables.<AnnotationType>filter(_tail_4, AnnotationType.class);
    final Consumer<AnnotationType> _function_5 = (AnnotationType it_1) -> {
      final Procedure1<IHiddenRegionFormatter> _function_6 = (IHiddenRegionFormatter it_2) -> {
        it_2.setNewLines(2);
      };
      document.<AnnotationType>prepend(it_1, _function_6);
    };
    _filter_4.forEach(_function_5);
    EList<EObject> _eContents_6 = it.eContents();
    Iterable<EObject> _tail_5 = IterableExtensions.<EObject>tail(_eContents_6);
    Iterable<AnnotationType> _filter_5 = Iterables.<AnnotationType>filter(_tail_5, AnnotationType.class);
    final Consumer<AnnotationType> _function_6 = (AnnotationType it_1) -> {
      final Procedure1<IHiddenRegionFormatter> _function_7 = (IHiddenRegionFormatter it_2) -> {
        it_2.setNewLines(2);
      };
      document.<AnnotationType>prepend(it_1, _function_7);
    };
    _filter_5.forEach(_function_6);
    EList<EObject> _eContents_7 = it.eContents();
    Iterable<EObject> _tail_6 = IterableExtensions.<EObject>tail(_eContents_7);
    Iterable<Import> _filter_6 = Iterables.<Import>filter(_tail_6, Import.class);
    final Consumer<Import> _function_7 = (Import it_1) -> {
      this.prependDefaultNewLines(it_1, document);
    };
    _filter_6.forEach(_function_7);
    EList<EObject> _eContents_8 = it.eContents();
    Iterable<EObject> _tail_7 = IterableExtensions.<EObject>tail(_eContents_8);
    Iterable<PrimitiveType> _filter_7 = Iterables.<PrimitiveType>filter(_tail_7, PrimitiveType.class);
    final Consumer<PrimitiveType> _function_8 = (PrimitiveType it_1) -> {
      this.prependDefaultNewLines(it_1, document);
    };
    _filter_7.forEach(_function_8);
    EList<EObject> _eContents_9 = it.eContents();
    Iterable<EObject> _tail_8 = IterableExtensions.<EObject>tail(_eContents_9);
    Iterable<EnumerationType> _filter_8 = Iterables.<EnumerationType>filter(_tail_8, EnumerationType.class);
    final Consumer<EnumerationType> _function_9 = (EnumerationType it_1) -> {
      this.prependDefaultNewLines(it_1, document);
    };
    _filter_8.forEach(_function_9);
    EList<EObject> _eContents_10 = it.eContents();
    Iterable<EObject> _tail_9 = IterableExtensions.<EObject>tail(_eContents_10);
    Iterable<ExternalType> _filter_9 = Iterables.<ExternalType>filter(_tail_9, ExternalType.class);
    final Consumer<ExternalType> _function_10 = (ExternalType it_1) -> {
      this.prependDefaultNewLines(it_1, document);
    };
    _filter_9.forEach(_function_10);
    TreeIterator<EObject> _eAllContents = it.eAllContents();
    final Procedure1<EObject> _function_11 = (EObject it_1) -> {
      document.<EObject>format(it_1);
    };
    IteratorExtensions.<EObject>forEach(_eAllContents, _function_11);
  }
  
  protected void _format(final RoomClass it, @Extension final IFormattableDocument document) {
    EList<EObject> _eContents = it.eContents();
    final Function1<EObject, Boolean> _function = (EObject it_1) -> {
      return Boolean.valueOf((!((it_1 instanceof DetailCode) || (it_1 instanceof Documentation))));
    };
    Iterable<EObject> _filter = IterableExtensions.<EObject>filter(_eContents, _function);
    final Consumer<EObject> _function_1 = (EObject it_1) -> {
      this.prependDefaultNewLines(it_1, document);
    };
    _filter.forEach(_function_1);
    ISemanticRegionsFinder _regionFor = this.textRegionExtensions.regionFor(it);
    List<ISemanticRegion> _keywords = _regionFor.keywords("usercode1", "usercode2", "usercode3", "incoming", "outgoing", "regular", "conjugated", "Interface", "Structure", "Behavior");
    final Consumer<ISemanticRegion> _function_2 = (ISemanticRegion it_1) -> {
      this.prependDefaultNewLines(it_1, document);
    };
    _keywords.forEach(_function_2);
  }
  
  protected void _format(final PortClass it, @Extension final IFormattableDocument document) {
    EList<EObject> _eContents = it.eContents();
    final Function1<EObject, Boolean> _function = (EObject it_1) -> {
      return Boolean.valueOf((!((it_1 instanceof DetailCode) || (it_1 instanceof Documentation))));
    };
    Iterable<EObject> _filter = IterableExtensions.<EObject>filter(_eContents, _function);
    final Consumer<EObject> _function_1 = (EObject it_1) -> {
      this.prependDefaultNewLines(it_1, document);
    };
    _filter.forEach(_function_1);
  }
  
  protected void _format(final Operation it, @Extension final IFormattableDocument document) {
    EList<VarDecl> _arguments = it.getArguments();
    final Consumer<VarDecl> _function = (VarDecl it_1) -> {
      final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it_2) -> {
        it_2.noSpace();
      };
      document.<VarDecl>append(it_1, _function_1);
    };
    _arguments.forEach(_function);
  }
  
  protected void _format(final Attribute it, @Extension final IFormattableDocument document) {
    ISemanticRegionsFinder _regionFor = this.textRegionExtensions.regionFor(it);
    List<Pair<ISemanticRegion, ISemanticRegion>> _keywordPairs = _regionFor.keywordPairs("[", "]");
    final Consumer<Pair<ISemanticRegion, ISemanticRegion>> _function = (Pair<ISemanticRegion, ISemanticRegion> it_1) -> {
      ISemanticRegion _key = it_1.getKey();
      final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it_2) -> {
        it_2.oneSpace();
      };
      document.prepend(_key, _function_1);
      final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it_2) -> {
        it_2.noSpace();
      };
      document.<ISemanticRegion, ISemanticRegion>interior(it_1, _function_2);
    };
    _keywordPairs.forEach(_function);
  }
  
  public void format(final Object it, final IFormattableDocument document) {
    if (it instanceof TriggeredTransition) {
      _format((TriggeredTransition)it, document);
      return;
    } else if (it instanceof State) {
      _format((State)it, document);
      return;
    } else if (it instanceof XtextResource) {
      _format((XtextResource)it, document);
      return;
    } else if (it instanceof Transition) {
      _format((Transition)it, document);
      return;
    } else if (it instanceof Annotation) {
      _format((Annotation)it, document);
      return;
    } else if (it instanceof AnnotationType) {
      _format((AnnotationType)it, document);
      return;
    } else if (it instanceof Documentation) {
      _format((Documentation)it, document);
      return;
    } else if (it instanceof Import) {
      _format((Import)it, document);
      return;
    } else if (it instanceof DetailCode) {
      _format((DetailCode)it, document);
      return;
    } else if (it instanceof ProtocolSemantics) {
      _format((ProtocolSemantics)it, document);
      return;
    } else if (it instanceof StateGraph) {
      _format((StateGraph)it, document);
      return;
    } else if (it instanceof Trigger) {
      _format((Trigger)it, document);
      return;
    } else if (it instanceof Attribute) {
      _format((Attribute)it, document);
      return;
    } else if (it instanceof Operation) {
      _format((Operation)it, document);
      return;
    } else if (it instanceof PortClass) {
      _format((PortClass)it, document);
      return;
    } else if (it instanceof RoomClass) {
      _format((RoomClass)it, document);
      return;
    } else if (it instanceof RoomModel) {
      _format((RoomModel)it, document);
      return;
    } else if (it instanceof EObject) {
      _format((EObject)it, document);
      return;
    } else if (it == null) {
      _format((Void)null, document);
      return;
    } else if (it != null) {
      _format(it, document);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(it, document).toString());
    }
  }
}
