/**
 * generated by Xtext
 */
package org.eclipse.etrice.core.formatting2;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.inject.Inject;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.etrice.core.common.base.Annotation;
import org.eclipse.etrice.core.common.base.AnnotationType;
import org.eclipse.etrice.core.common.base.Documentation;
import org.eclipse.etrice.core.common.base.Import;
import org.eclipse.etrice.core.fsm.fSM.DetailCode;
import org.eclipse.etrice.core.fsm.fSM.ProtocolSemantics;
import org.eclipse.etrice.core.fsm.fSM.State;
import org.eclipse.etrice.core.fsm.fSM.StateGraph;
import org.eclipse.etrice.core.fsm.fSM.Transition;
import org.eclipse.etrice.core.fsm.fSM.Trigger;
import org.eclipse.etrice.core.fsm.fSM.TriggeredTransition;
import org.eclipse.etrice.core.fsm.formatting2.FSMFormatter;
import org.eclipse.etrice.core.room.ActorClass;
import org.eclipse.etrice.core.room.Attribute;
import org.eclipse.etrice.core.room.DataClass;
import org.eclipse.etrice.core.room.EnumerationType;
import org.eclipse.etrice.core.room.ExternalType;
import org.eclipse.etrice.core.room.GeneralProtocolClass;
import org.eclipse.etrice.core.room.Operation;
import org.eclipse.etrice.core.room.PortClass;
import org.eclipse.etrice.core.room.PrimitiveType;
import org.eclipse.etrice.core.room.RoomClass;
import org.eclipse.etrice.core.room.RoomModel;
import org.eclipse.etrice.core.room.SubSystemClass;
import org.eclipse.etrice.core.room.VarDecl;
import org.eclipse.etrice.core.services.RoomGrammarAccess;
import org.eclipse.xtext.AbstractRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import org.eclipse.xtext.formatting2.IHiddenRegionFormatter;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionsFinder;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

@SuppressWarnings("all")
public class RoomFormatter extends FSMFormatter {
  @Inject
  @Extension
  private RoomGrammarAccess _roomGrammarAccess;
  
  @Override
  public void formatAllByKeywords(final EObject it, @Extension final IFormattableDocument document) {
    super.formatAllByKeywords(it, document);
    ISemanticRegionsFinder _allRegionsFor = this.textRegionExtensions.allRegionsFor(it);
    List<ISemanticRegion> _keywords = _allRegionsFor.keywords("default", "void", "sends", "sub", "of", "and", "satisfied_by");
    final Procedure1<ISemanticRegion> _function = new Procedure1<ISemanticRegion>() {
      @Override
      public void apply(final ISemanticRegion it) {
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.oneSpace();
          }
        };
        document.surround(it, _function);
      }
    };
    IterableExtensions.<ISemanticRegion>forEach(_keywords, _function);
    ISemanticRegionsFinder _allRegionsFor_1 = this.textRegionExtensions.allRegionsFor(it);
    List<ISemanticRegion> _keywords_1 = _allRegionsFor_1.keywords("/");
    final Procedure1<ISemanticRegion> _function_1 = new Procedure1<ISemanticRegion>() {
      @Override
      public void apply(final ISemanticRegion it) {
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.noSpace();
          }
        };
        document.surround(it, _function);
      }
    };
    IterableExtensions.<ISemanticRegion>forEach(_keywords_1, _function_1);
    Grammar _grammar = this._roomGrammarAccess.getGrammar();
    List<AbstractRule> _allRules = GrammarUtil.allRules(_grammar);
    final Function1<AbstractRule, Iterable<Keyword>> _function_2 = new Function1<AbstractRule, Iterable<Keyword>>() {
      @Override
      public Iterable<Keyword> apply(final AbstractRule it) {
        TreeIterator<EObject> _eAllContents = it.eAllContents();
        Iterator<Keyword> _filter = Iterators.<Keyword>filter(_eAllContents, Keyword.class);
        final Function1<Keyword, Boolean> _function = new Function1<Keyword, Boolean>() {
          @Override
          public Boolean apply(final Keyword it) {
            String _value = it.getValue();
            return Boolean.valueOf((!Objects.equal(_value, "ref")));
          }
        };
        Iterator<Keyword> _filter_1 = IteratorExtensions.<Keyword>filter(_filter, _function);
        final Function1<Keyword, Boolean> _function_1 = new Function1<Keyword, Boolean>() {
          @Override
          public Boolean apply(final Keyword it) {
            String _value = it.getValue();
            char[] _charArray = _value.toCharArray();
            final Function1<Character, Boolean> _function = new Function1<Character, Boolean>() {
              @Override
              public Boolean apply(final Character it) {
                return Boolean.valueOf(Character.isLetter((it).charValue()));
              }
            };
            return Boolean.valueOf(IterableExtensions.<Character>forall(((Iterable<Character>)Conversions.doWrapArray(_charArray)), _function));
          }
        };
        Iterator<Keyword> _filter_2 = IteratorExtensions.<Keyword>filter(_filter_1, _function_1);
        return IteratorExtensions.<Keyword>toIterable(_filter_2);
      }
    };
    List<Iterable<Keyword>> _map = ListExtensions.<AbstractRule, Iterable<Keyword>>map(_allRules, _function_2);
    final Iterable<Keyword> textKeywords = Iterables.<Keyword>concat(_map);
    ISemanticRegionsFinder _allRegionsFor_2 = this.textRegionExtensions.allRegionsFor(it);
    List<ISemanticRegion> _keywords_2 = _allRegionsFor_2.keywords(((Keyword[])Conversions.unwrapArray(textKeywords, Keyword.class)));
    final Procedure1<ISemanticRegion> _function_3 = new Procedure1<ISemanticRegion>() {
      @Override
      public void apply(final ISemanticRegion it) {
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.oneSpace();
          }
        };
        document.append(it, _function);
      }
    };
    IterableExtensions.<ISemanticRegion>forEach(_keywords_2, _function_3);
  }
  
  protected void _format(final RoomModel it, @Extension final IFormattableDocument document) {
    this.formatAllByKeywords(it, document);
    EList<EObject> _eContents = it.eContents();
    EObject _head = IterableExtensions.<EObject>head(_eContents);
    final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
      @Override
      public void apply(final IHiddenRegionFormatter it) {
        it.setNewLines(2);
      }
    };
    document.<EObject>prepend(_head, _function);
    EList<EObject> _eContents_1 = it.eContents();
    Iterable<EObject> _tail = IterableExtensions.<EObject>tail(_eContents_1);
    Iterable<DataClass> _filter = Iterables.<DataClass>filter(_tail, DataClass.class);
    final Procedure1<DataClass> _function_1 = new Procedure1<DataClass>() {
      @Override
      public void apply(final DataClass it) {
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.setNewLines(2);
          }
        };
        document.<DataClass>prepend(it, _function);
      }
    };
    IterableExtensions.<DataClass>forEach(_filter, _function_1);
    EList<EObject> _eContents_2 = it.eContents();
    Iterable<EObject> _tail_1 = IterableExtensions.<EObject>tail(_eContents_2);
    Iterable<GeneralProtocolClass> _filter_1 = Iterables.<GeneralProtocolClass>filter(_tail_1, GeneralProtocolClass.class);
    final Procedure1<GeneralProtocolClass> _function_2 = new Procedure1<GeneralProtocolClass>() {
      @Override
      public void apply(final GeneralProtocolClass it) {
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.setNewLines(2);
          }
        };
        document.<GeneralProtocolClass>prepend(it, _function);
      }
    };
    IterableExtensions.<GeneralProtocolClass>forEach(_filter_1, _function_2);
    EList<EObject> _eContents_3 = it.eContents();
    Iterable<EObject> _tail_2 = IterableExtensions.<EObject>tail(_eContents_3);
    Iterable<ActorClass> _filter_2 = Iterables.<ActorClass>filter(_tail_2, ActorClass.class);
    final Procedure1<ActorClass> _function_3 = new Procedure1<ActorClass>() {
      @Override
      public void apply(final ActorClass it) {
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.setNewLines(2);
          }
        };
        document.<ActorClass>prepend(it, _function);
      }
    };
    IterableExtensions.<ActorClass>forEach(_filter_2, _function_3);
    EList<EObject> _eContents_4 = it.eContents();
    Iterable<EObject> _tail_3 = IterableExtensions.<EObject>tail(_eContents_4);
    Iterable<SubSystemClass> _filter_3 = Iterables.<SubSystemClass>filter(_tail_3, SubSystemClass.class);
    final Procedure1<SubSystemClass> _function_4 = new Procedure1<SubSystemClass>() {
      @Override
      public void apply(final SubSystemClass it) {
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.setNewLines(2);
          }
        };
        document.<SubSystemClass>prepend(it, _function);
      }
    };
    IterableExtensions.<SubSystemClass>forEach(_filter_3, _function_4);
    EList<EObject> _eContents_5 = it.eContents();
    Iterable<EObject> _tail_4 = IterableExtensions.<EObject>tail(_eContents_5);
    Iterable<AnnotationType> _filter_4 = Iterables.<AnnotationType>filter(_tail_4, AnnotationType.class);
    final Procedure1<AnnotationType> _function_5 = new Procedure1<AnnotationType>() {
      @Override
      public void apply(final AnnotationType it) {
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.setNewLines(2);
          }
        };
        document.<AnnotationType>prepend(it, _function);
      }
    };
    IterableExtensions.<AnnotationType>forEach(_filter_4, _function_5);
    EList<EObject> _eContents_6 = it.eContents();
    Iterable<EObject> _tail_5 = IterableExtensions.<EObject>tail(_eContents_6);
    Iterable<AnnotationType> _filter_5 = Iterables.<AnnotationType>filter(_tail_5, AnnotationType.class);
    final Procedure1<AnnotationType> _function_6 = new Procedure1<AnnotationType>() {
      @Override
      public void apply(final AnnotationType it) {
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.setNewLines(2);
          }
        };
        document.<AnnotationType>prepend(it, _function);
      }
    };
    IterableExtensions.<AnnotationType>forEach(_filter_5, _function_6);
    EList<EObject> _eContents_7 = it.eContents();
    Iterable<EObject> _tail_6 = IterableExtensions.<EObject>tail(_eContents_7);
    Iterable<Import> _filter_6 = Iterables.<Import>filter(_tail_6, Import.class);
    final Procedure1<Import> _function_7 = new Procedure1<Import>() {
      @Override
      public void apply(final Import it) {
        RoomFormatter.this.prependDefaultNewLines(it, document);
      }
    };
    IterableExtensions.<Import>forEach(_filter_6, _function_7);
    EList<EObject> _eContents_8 = it.eContents();
    Iterable<EObject> _tail_7 = IterableExtensions.<EObject>tail(_eContents_8);
    Iterable<PrimitiveType> _filter_7 = Iterables.<PrimitiveType>filter(_tail_7, PrimitiveType.class);
    final Procedure1<PrimitiveType> _function_8 = new Procedure1<PrimitiveType>() {
      @Override
      public void apply(final PrimitiveType it) {
        RoomFormatter.this.prependDefaultNewLines(it, document);
      }
    };
    IterableExtensions.<PrimitiveType>forEach(_filter_7, _function_8);
    EList<EObject> _eContents_9 = it.eContents();
    Iterable<EObject> _tail_8 = IterableExtensions.<EObject>tail(_eContents_9);
    Iterable<EnumerationType> _filter_8 = Iterables.<EnumerationType>filter(_tail_8, EnumerationType.class);
    final Procedure1<EnumerationType> _function_9 = new Procedure1<EnumerationType>() {
      @Override
      public void apply(final EnumerationType it) {
        RoomFormatter.this.prependDefaultNewLines(it, document);
      }
    };
    IterableExtensions.<EnumerationType>forEach(_filter_8, _function_9);
    EList<EObject> _eContents_10 = it.eContents();
    Iterable<EObject> _tail_9 = IterableExtensions.<EObject>tail(_eContents_10);
    Iterable<ExternalType> _filter_9 = Iterables.<ExternalType>filter(_tail_9, ExternalType.class);
    final Procedure1<ExternalType> _function_10 = new Procedure1<ExternalType>() {
      @Override
      public void apply(final ExternalType it) {
        RoomFormatter.this.prependDefaultNewLines(it, document);
      }
    };
    IterableExtensions.<ExternalType>forEach(_filter_9, _function_10);
    TreeIterator<EObject> _eAllContents = it.eAllContents();
    final Procedure1<EObject> _function_11 = new Procedure1<EObject>() {
      @Override
      public void apply(final EObject it) {
        document.<EObject>format(it);
      }
    };
    IteratorExtensions.<EObject>forEach(_eAllContents, _function_11);
  }
  
  protected void _format(final RoomClass it, @Extension final IFormattableDocument document) {
    EList<EObject> _eContents = it.eContents();
    final Function1<EObject, Boolean> _function = new Function1<EObject, Boolean>() {
      @Override
      public Boolean apply(final EObject it) {
        return Boolean.valueOf((!((it instanceof DetailCode) || (it instanceof Documentation))));
      }
    };
    Iterable<EObject> _filter = IterableExtensions.<EObject>filter(_eContents, _function);
    final Procedure1<EObject> _function_1 = new Procedure1<EObject>() {
      @Override
      public void apply(final EObject it) {
        RoomFormatter.this.prependDefaultNewLines(it, document);
      }
    };
    IterableExtensions.<EObject>forEach(_filter, _function_1);
    ISemanticRegionsFinder _regionFor = this.textRegionExtensions.regionFor(it);
    List<ISemanticRegion> _keywords = _regionFor.keywords("usercode1", "usercode2", "usercode3", "incoming", "outgoing", "regular", "conjugated", "Interface", "Structure", "Behavior");
    final Procedure1<ISemanticRegion> _function_2 = new Procedure1<ISemanticRegion>() {
      @Override
      public void apply(final ISemanticRegion it) {
        RoomFormatter.this.prependDefaultNewLines(it, document);
      }
    };
    IterableExtensions.<ISemanticRegion>forEach(_keywords, _function_2);
  }
  
  protected void _format(final PortClass it, @Extension final IFormattableDocument document) {
    EList<EObject> _eContents = it.eContents();
    final Function1<EObject, Boolean> _function = new Function1<EObject, Boolean>() {
      @Override
      public Boolean apply(final EObject it) {
        return Boolean.valueOf((!((it instanceof DetailCode) || (it instanceof Documentation))));
      }
    };
    Iterable<EObject> _filter = IterableExtensions.<EObject>filter(_eContents, _function);
    final Procedure1<EObject> _function_1 = new Procedure1<EObject>() {
      @Override
      public void apply(final EObject it) {
        RoomFormatter.this.prependDefaultNewLines(it, document);
      }
    };
    IterableExtensions.<EObject>forEach(_filter, _function_1);
  }
  
  protected void _format(final Operation it, @Extension final IFormattableDocument document) {
    EList<VarDecl> _arguments = it.getArguments();
    final Procedure1<VarDecl> _function = new Procedure1<VarDecl>() {
      @Override
      public void apply(final VarDecl it) {
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.noSpace();
          }
        };
        document.<VarDecl>append(it, _function);
      }
    };
    IterableExtensions.<VarDecl>forEach(_arguments, _function);
  }
  
  protected void _format(final Attribute it, @Extension final IFormattableDocument document) {
    ISemanticRegionsFinder _regionFor = this.textRegionExtensions.regionFor(it);
    List<Pair<ISemanticRegion, ISemanticRegion>> _keywordPairs = _regionFor.keywordPairs("[", "]");
    final Procedure1<Pair<ISemanticRegion, ISemanticRegion>> _function = new Procedure1<Pair<ISemanticRegion, ISemanticRegion>>() {
      @Override
      public void apply(final Pair<ISemanticRegion, ISemanticRegion> it) {
        ISemanticRegion _key = it.getKey();
        final Procedure1<IHiddenRegionFormatter> _function = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.oneSpace();
          }
        };
        document.prepend(_key, _function);
        final Procedure1<IHiddenRegionFormatter> _function_1 = new Procedure1<IHiddenRegionFormatter>() {
          @Override
          public void apply(final IHiddenRegionFormatter it) {
            it.noSpace();
          }
        };
        document.<ISemanticRegion, ISemanticRegion>interior(it, _function_1);
      }
    };
    IterableExtensions.<Pair<ISemanticRegion, ISemanticRegion>>forEach(_keywordPairs, _function);
  }
  
  public void format(final Object it, final IFormattableDocument document) {
    if (it instanceof TriggeredTransition) {
      _format((TriggeredTransition)it, document);
      return;
    } else if (it instanceof State) {
      _format((State)it, document);
      return;
    } else if (it instanceof XtextResource) {
      _format((XtextResource)it, document);
      return;
    } else if (it instanceof Transition) {
      _format((Transition)it, document);
      return;
    } else if (it instanceof Annotation) {
      _format((Annotation)it, document);
      return;
    } else if (it instanceof AnnotationType) {
      _format((AnnotationType)it, document);
      return;
    } else if (it instanceof Documentation) {
      _format((Documentation)it, document);
      return;
    } else if (it instanceof Import) {
      _format((Import)it, document);
      return;
    } else if (it instanceof DetailCode) {
      _format((DetailCode)it, document);
      return;
    } else if (it instanceof ProtocolSemantics) {
      _format((ProtocolSemantics)it, document);
      return;
    } else if (it instanceof StateGraph) {
      _format((StateGraph)it, document);
      return;
    } else if (it instanceof Trigger) {
      _format((Trigger)it, document);
      return;
    } else if (it instanceof Attribute) {
      _format((Attribute)it, document);
      return;
    } else if (it instanceof Operation) {
      _format((Operation)it, document);
      return;
    } else if (it instanceof PortClass) {
      _format((PortClass)it, document);
      return;
    } else if (it instanceof RoomClass) {
      _format((RoomClass)it, document);
      return;
    } else if (it instanceof RoomModel) {
      _format((RoomModel)it, document);
      return;
    } else if (it instanceof EObject) {
      _format((EObject)it, document);
      return;
    } else if (it == null) {
      _format((Void)null, document);
      return;
    } else if (it != null) {
      _format(it, document);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(it, document).toString());
    }
  }
}
