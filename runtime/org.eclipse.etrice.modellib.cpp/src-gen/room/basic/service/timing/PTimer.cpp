/**
 * @author generated by eTrice
 *
 * Source File of ProtocolClass PTimer
 *
 */

#include "PTimer.h"

#include "common/debugging/DebuggingService.h"
#include "common/debugging/MSCFunctionObject.h"
#include "common/messaging/AbstractMessageReceiver.h"
#include "common/messaging/Address.h"
#include "common/messaging/Message.h"
#include "common/modelbase/IEventReceiver.h"

using namespace etRuntime;



/* message names as strings for debugging (generate MSC) */
const String PTimer::s_messageStrings[] = {"MIN", "timeout", "startTimer","startTimeout","kill","MAX"};

const String& PTimer::getMessageString(int msg_id) {
	if ((MSG_MIN < msg_id ) && ( msg_id < MSG_MAX )) {
		return s_messageStrings[msg_id];
	} else {
		// id out of range
		static const String errorMsg = "Message ID out of range";
		return errorMsg;
	}
}

//------------------------------------------------------------------------------------------------------------
// port class
//------------------------------------------------------------------------------------------------------------

PTimerPort::PTimerPort(IInterfaceItemOwner* actor, const String& name, int localId)
	: PortBase(actor, name, localId, 0)
{
}

PTimerPort::PTimerPort(IInterfaceItemOwner* actor, const String& name, int localId, int idx)
	: PortBase(actor, name, localId, idx)
{
}

void PTimerPort::destroy() {
	DebuggingService::getInstance().removePortInstance(*this);
	PortBase::destroy();
}

void PTimerPort::receive(const Message* msg) {
	// TODO JH further
	if (! PTimer::isValidIncomingEvtID(msg->getEvtId())) {
		//std::cout << "unknown" << std::endl;
	}

	DebuggingService::getInstance().addMessageAsyncIn(getPeerAddress(), getAddress(), PTimer::getMessageString(msg->getEvtId()).c_str());

	getActor()->receiveEvent(this, msg->getEvtId(),	msg->getData());
}


// sent messages
void PTimerPort::timeout() {
	timeout_impl();
}

void PTimerPort::timeout_impl() {
	DebuggingService::getInstance().addMessageAsyncOut(getAddress(), getPeerAddress(),
		PTimer::getMessageString(PTimer::OUT_timeout).c_str());
	if (getPeerAddress().isValid()) {
		Message* buffer = dynamic_cast<IMessageService*>(getPeerMsgReceiver())->getMessageBuffer(sizeof(Message));
		if (buffer) {
			getPeerMsgReceiver()->receive(new (buffer) Message(getPeerAddress(), PTimer::OUT_timeout));
		}
	}
}

//------------------------------------------------------------------------------------------------------------
// replicated port class
//------------------------------------------------------------------------------------------------------------
PTimerReplPort::PTimerReplPort(IInterfaceItemOwner* actor, const String& name, int localId) :
		ReplicatedPortBase(actor, name, localId)
{
}

// outgoing messages
void PTimerReplPort::timeout(){
	for (Vector<etRuntime::InterfaceItemBase*>::iterator it = getItems().begin(); it != getItems().end(); ++it) {
		(dynamic_cast<PTimerPort*>(*it))->timeout();
	}
}
//------------------------------------------------------------------------------------------------------------
// conjugated port class
//------------------------------------------------------------------------------------------------------------

PTimerConjPort::PTimerConjPort(IInterfaceItemOwner* actor, const String& name, int localId)
	: PortBase(actor, name, localId, 0)
	, status(0)
{
}

PTimerConjPort::PTimerConjPort(IInterfaceItemOwner* actor, const String& name, int localId, int idx)
	: PortBase(actor, name, localId, idx)
	, status(0)
{
}

void PTimerConjPort::destroy() {
	DebuggingService::getInstance().removePortInstance(*this);
	PortBase::destroy();
}

void PTimerConjPort::receive(const Message* msg) {
	// TODO JH further
	if (! PTimer::isValidOutgoingEvtID(msg->getEvtId())) {
		//std::cout << "unknown" << std::endl;
	}

	DebuggingService::getInstance().addMessageAsyncIn(getPeerAddress(), getAddress(), PTimer::getMessageString(msg->getEvtId()).c_str());

	switch (msg->getEvtId()) {
		case PTimer::OUT_timeout:
			{
				
							//TODO: clear active bit in case of single shot timer
							if (status!=0){
								if (status==ET_TIMER_RUNNING){
									// single shot timer
									status=0;
								}
								// msg to fsm
								getActor()->receiveEvent(this, msg->getEvtId(),	msg->getData());
							}
			}
			break;
		default:
	getActor()->receiveEvent(this, msg->getEvtId(),	msg->getData());
			break;
	}
}

/*--------------------- operations ---------------------*/

// sent messages
void PTimerConjPort::startTimer(uint32 time) {
		if (status==0){
					status=ET_TIMER_RUNNING | ET_TIMER_PERIODIC;
					startTimer_impl(time);
				}
}

void PTimerConjPort::startTimer_impl(uint32 time) {
	DebuggingService::getInstance().addMessageAsyncOut(getAddress(), getPeerAddress(),
		PTimer::getMessageString(PTimer::IN_startTimer).c_str());
	if (getPeerAddress().isValid()) {
		Message* buffer = dynamic_cast<IMessageService*>(getPeerMsgReceiver())->getMessageBuffer(sizeof(DataMessage<uint32>));
		if (buffer) {
			getPeerMsgReceiver()->receive(new (buffer) DataMessage<uint32>(getPeerAddress(), PTimer::IN_startTimer, time));
		}
	}
}
void PTimerConjPort::startTimeout(uint32 time) {
		if (status==0){
					status = ET_TIMER_RUNNING;
					startTimeout_impl(time);
				}
}

void PTimerConjPort::startTimeout_impl(uint32 time) {
	DebuggingService::getInstance().addMessageAsyncOut(getAddress(), getPeerAddress(),
		PTimer::getMessageString(PTimer::IN_startTimeout).c_str());
	if (getPeerAddress().isValid()) {
		Message* buffer = dynamic_cast<IMessageService*>(getPeerMsgReceiver())->getMessageBuffer(sizeof(DataMessage<uint32>));
		if (buffer) {
			getPeerMsgReceiver()->receive(new (buffer) DataMessage<uint32>(getPeerAddress(), PTimer::IN_startTimeout, time));
		}
	}
}
void PTimerConjPort::kill() {
		
				if (status!=0){
					status=0;
					kill_impl();
				}
}

void PTimerConjPort::kill_impl() {
	DebuggingService::getInstance().addMessageAsyncOut(getAddress(), getPeerAddress(),
		PTimer::getMessageString(PTimer::IN_kill).c_str());
	if (getPeerAddress().isValid()) {
		Message* buffer = dynamic_cast<IMessageService*>(getPeerMsgReceiver())->getMessageBuffer(sizeof(Message));
		if (buffer) {
			getPeerMsgReceiver()->receive(new (buffer) Message(getPeerAddress(), PTimer::IN_kill));
		}
	}
}

//------------------------------------------------------------------------------------------------------------
// conjugated replicated port class
//------------------------------------------------------------------------------------------------------------
PTimerConjReplPort::PTimerConjReplPort(IInterfaceItemOwner* actor, const String& name, int localId) :
		ReplicatedPortBase(actor, name, localId)
{
}

// incoming messages
void PTimerConjReplPort::startTimer(uint32 time){
	for (Vector<etRuntime::InterfaceItemBase*>::iterator it = getItems().begin(); it != getItems().end(); ++it) {
		(dynamic_cast<PTimerConjPort*>(*it))->startTimer( time);
	}
}
void PTimerConjReplPort::startTimeout(uint32 time){
	for (Vector<etRuntime::InterfaceItemBase*>::iterator it = getItems().begin(); it != getItems().end(); ++it) {
		(dynamic_cast<PTimerConjPort*>(*it))->startTimeout( time);
	}
}
void PTimerConjReplPort::kill(){
	for (Vector<etRuntime::InterfaceItemBase*>::iterator it = getItems().begin(); it != getItems().end(); ++it) {
		(dynamic_cast<PTimerConjPort*>(*it))->kill();
	}
}


