/**
 * @author generated by eTrice
 *
 * Header File of ProtocolClass PTimer
 * 
 */

#ifndef _PTIMER_H_
#define _PTIMER_H_

#include "platforms/generic/etDatatypes.h"
#include "common/messaging/IRTObject.h"
#include "common/modelbase/PortBase.h"
#include "common/modelbase/InterfaceItemBase.h"
#include "common/messaging/Address.h"
#include "common/messaging/Message.h"
#include <vector>
#include <string>
		
namespace etRuntime {
	class IEventReceiver;
	
}

/*--------------------- begin user code ---------------------*/

			#define ET_TIMER_RUNNING	0x01
			#define ET_TIMER_PERIODIC	0x02
			
/*--------------------- end user code ---------------------*/


class PTimer {
   public:
	   /* message IDs */
		typedef enum {
		MSG_MIN = 0,
		OUT_timeout = 1,
		IN_startTimer = 2,
		IN_startTimeout = 3,
		IN_kill = 4,
		MSG_MAX = 5,
		} msg_ids;
		static bool isValidEvtID(int evtId) {
			return ((MSG_MIN < evtId) && (evtId < MSG_MAX));
		};
		static bool isValidOutgoingEvtID(int evtId) {
			return ((MSG_MIN < evtId) && (evtId < IN_startTimer));
		};
		static bool isValidIncomingEvtID(int evtId) {
			return ((IN_startTimer <= evtId) && (evtId < MSG_MAX));
		};
		static std::string getMessageString(int msg_id);
	
	private:
		static std::string s_messageStrings[];
		/*--------------------- begin user code ---------------------*/
		//uc2		
		/*--------------------- end user code ---------------------*/
};

//------------------------------------------------------------------------------------------------------------
// port class
//------------------------------------------------------------------------------------------------------------
class PTimerPort : public etRuntime::PortBase {
   public:
	// constructors
	 PTimerPort(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, etRuntime::Address addr, etRuntime::Address peerAddress, bool doRegistration = true); 
	 PTimerPort(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, int idx, etRuntime::Address addr, etRuntime::Address peerAddress, bool doRegistration = true);

	 virtual void receive(etRuntime::Message* m);
	
	  // outgoing messages
	public: void timeout();
};

//------------------------------------------------------------------------------------------------------------
// replicated port class
//------------------------------------------------------------------------------------------------------------
class PTimerReplPort {
	private:
	    int m_replication;
	    PTimerPort* m_ports;  //dynamic array used instead of vector to avoid copy construction

	public:
		PTimerReplPort(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, std::vector<etRuntime::Address> addr, std::vector<etRuntime::Address> peerAddress);
		virtual ~PTimerReplPort() {};
		
		int getReplication() {	return m_replication; }
		int getIndexOf(const etRuntime::InterfaceItemBase& ifitem){ return ifitem.getIdx();	}
		PTimerPort get(int i) {return m_ports[i];}
		
		 // outgoing messages
		public: void timeout();
		
};
//------------------------------------------------------------------------------------------------------------
// conjugated port class
//------------------------------------------------------------------------------------------------------------
class PTimerConjPort : public etRuntime::PortBase {
   public:
	// constructors
	 PTimerConjPort(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, etRuntime::Address addr, etRuntime::Address peerAddress, bool doRegistration = true); 
	 PTimerConjPort(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, int idx, etRuntime::Address addr, etRuntime::Address peerAddress, bool doRegistration = true);

	 virtual void receive(etRuntime::Message* m);
	/*--------------------- attributes ---------------------*/
	int8 status;
	/*--------------------- operations ---------------------*/
	
	  // outgoing messages
	public: void startTimer(uint32 time);
	public: void startTimeout(uint32 time);
	public: void kill();
};

//------------------------------------------------------------------------------------------------------------
// conjugated replicated port class
//------------------------------------------------------------------------------------------------------------
class PTimerConjReplPort {
	private:
	    int m_replication;
	    PTimerConjPort* m_ports;  //dynamic array used instead of vector to avoid copy construction

	public:
		PTimerConjReplPort(etRuntime::IEventReceiver& actor, etRuntime::IRTObject* parent, std::string name, int localId, std::vector<etRuntime::Address> addr, std::vector<etRuntime::Address> peerAddress);
		virtual ~PTimerConjReplPort() {};
		
		int getReplication() {	return m_replication; }
		int getIndexOf(const etRuntime::InterfaceItemBase& ifitem){ return ifitem.getIdx();	}
		PTimerConjPort get(int i) {return m_ports[i];}
		
		 // outgoing messages
		public: void startTimer(uint32 time);
		public: void startTimeout(uint32 time);
		public: void kill();
		
};
#endif /* _PTIMER_H_ */
