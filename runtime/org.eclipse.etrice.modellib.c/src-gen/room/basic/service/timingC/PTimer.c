/**
 * @author generated by eTrice
 *
 * Source File of ProtocolClass PTimer
 * 
 */

#include "PTimer.h"
#include "debugging/etMSCLogger.h"


/*--------------------- port methods */

void PTimerPort_timeout(const PTimerPort* self) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerPort", "timeout")
		etPort_sendMessage(self, PTimer_OUT_timeout, 0, NULL);
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerReplPort_timeout_broadcast(const PTimerReplPort* self) {
	int i;
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerReplPort", "timeout")
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		etPort_sendMessage(((etPort*)&((etReplPort*)self)->ports[i]), PTimer_OUT_timeout, 0, NULL);
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerReplPort_timeout(const PTimerReplPort* self, int idx) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerReplPort", "timeout")
	if (0<=idx && idx<((etReplPort*)self)->size) {
		etPort_sendMessage(((etPort*)&((etReplPort*)self)->ports[idx]), PTimer_OUT_timeout, 0, NULL);
	}
	ET_MSC_LOGGER_SYNC_EXIT
}


// getReplication
etInt32 PTimerReplPort_getReplication(const PTimerReplPort* self) {
	return ((etReplPort*)self)->size;
}



void PTimerConjPort_startTimer(const PTimerConjPort* self, uint32 data) {
		if (((PTimerConjPort_var*)(self->varData))->status==0){
					((PTimerConjPort_var*)(self->varData))->status=ET_TIMER_RUNNING | ET_TIMER_PERIODIC;
					etPort_sendMessage(self, PTimer_IN_startTimer, sizeof(int32), &data);
					}
}

void PTimerConjReplPort_startTimer_broadcast(const PTimerConjReplPort* self, uint32 data) {
	int i;
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		PTimerConjPort_startTimer((etPort*)&((etReplPort*)self)->ports[i], data);
	}					
}

void PTimerConjReplPort_startTimer(const PTimerConjReplPort* self, int idx, uint32 data) {
	PTimerConjPort_startTimer((etPort*)&((etReplPort*)self)->ports[idx], data);
}

void PTimerConjPort_startTimeout(const PTimerConjPort* self, uint32 data) {
		if (((PTimerConjPort_var*)(self->varData))->status==0){
					((PTimerConjPort_var*)(self->varData))->status = ET_TIMER_RUNNING;
					etPort_sendMessage(self, PTimer_IN_startTimeout, sizeof(int32), &data);
					}
}

void PTimerConjReplPort_startTimeout_broadcast(const PTimerConjReplPort* self, uint32 data) {
	int i;
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		PTimerConjPort_startTimeout((etPort*)&((etReplPort*)self)->ports[i], data);
	}					
}

void PTimerConjReplPort_startTimeout(const PTimerConjReplPort* self, int idx, uint32 data) {
	PTimerConjPort_startTimeout((etPort*)&((etReplPort*)self)->ports[idx], data);
}

void PTimerConjPort_kill(const PTimerConjPort* self) {
		
				if (((PTimerConjPort_var*)(self->varData))->status!=0){
					((PTimerConjPort_var*)(self->varData))->status=0;
					etPort_sendMessage(self, PTimer_IN_kill, 0,NULL);
					}
}

void PTimerConjReplPort_kill_broadcast(const PTimerConjReplPort* self) {
	int i;
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		PTimerConjPort_kill((etPort*)&((etReplPort*)self)->ports[i]);
	}					
}

void PTimerConjReplPort_kill(const PTimerConjReplPort* self, int idx) {
	PTimerConjPort_kill((etPort*)&((etReplPort*)self)->ports[idx]);
}

/*--------------------- operations ---------------------*/
/*--------------------- operations ---------------------*/

// getReplication
etInt32 PTimerConjReplPort_getReplication(const PTimerConjReplPort* self) {
	return ((etReplPort*)self)->size;
}

/* receiver handlers */
void PTimerConjPort_timeout_receiveHandler(PTimerConjPort* self, const etMessage* msg, void * actor, etActorReceiveMessage receiveMessageFunc){
	/*--------------------- begin user code ---------------------*/
		//TODO: clear active bit in case of single shot timer
				if (((PTimerConjPort_var*)(self->varData))->status!=0){
					if (((PTimerConjPort_var*)(self->varData))->status==ET_TIMER_RUNNING){
						// single shot timer
						((PTimerConjPort_var*)(self->varData))->status=0;
						}
					// msg to fsm
					(*receiveMessageFunc)(actor, self, msg);
					}
	/*--------------------- end user code ---------------------*/
	/* hand over the message to the actor:      */
	/* (*receiveMessageFunc)(actor, self, msg); */
}


/*--------------------- debug helpers */

/* message names as strings for debugging (generate MSC) */
static const char* PTimer_messageStrings[] = {"MIN", "timeout","startTimer", "startTimeout", "kill", "MAX"};

const char* PTimer_getMessageString(int msg_id) {
	if (msg_id<PTimer_MSG_MIN || msg_id>PTimer_MSG_MAX+1){
		/* id out of range */
		return "Message ID out of range";
	}
	else{
		return PTimer_messageStrings[msg_id];
	}
}
